{"version":3,"sources":["raw-mjs/kendo.dataviz.diagram.js"],"names":["$","kendo","window","diagram","dataviz","deepExtend","isArray","Array","Utils","isNearZero","num","Math","abs","isDefined","obj","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString","prototype","toString","isBoolean","isType","type","isNumber","isNaN","parseFloat","isFinite","isEmpty","length","simpleExtend","destination","source","name","initArray","size","value","array","i","serializePoints","points","res","p","push","x","y","join","deserializePoints","s","v","split","Point","parseInt","randomInteger","lower","upper","floor","random","DFT","el","func","childNodes","item","this","getMatrixAngle","m","d","atan2","b","PI","getMatrixScaling","sqrt","a","c","sign","number","findAngle","center","end","start","sngXComp","sngYComp","atan","findRadian","forEach","arr","iterator","thisRef","any","predicate","remove","what","ax","indexOf","splice","contains","inArray","fold","list","acc","context","initial","arguments","find","result","index","first","constraint","insert","element","position","all","clear","bisort","sortfunc","sort","n","addRange","range","apply","Easing","pos","cos","Ticker","Class","extend","init","adapters","target","tick","interval","duration","lastTime","handlers","_this","transition","timerDelegate","onTimerEvent","addAdapter","onComplete","handler","removeHandler","grep","h","trigger","caller","onStep","seekTo","to","seekFromTo","from","max","min","Date","getTime","intervalId","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","ui","Range","step","Infinity","j","k","rangeIntegerScale","jQuery","geometry","isFunction","map","ExtendedPoint","constructor","super","clone","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","len","Polar","isOnLine","temp","o1","u1","r1","Rect","inflate","r2","union","height","width","parse","str","xy","slice","PathDefiner","left","right","point","dx","dy","r","x1","y1","x2","y2","top","bottom","topLeft","topRight","bottomLeft","bottomRight","equals","rect","rotatedBounds","angle","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","Size","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Empty","toRect","empty","fromPoints","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Matrix","e","f","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","sin","scaling","parts","nums","trim","substr","MatrixVector","fromMatrix","randomId","chars","charAt","round","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","Number","MAX_VALUE","p1","p2","HashTable","_buckets","add","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","hash","bucket","ht","_hashString","_objectHashId","charCodeAt","id","_hashId","Dictionary","Observable","dictionary","fn","_hashTable","entry","Error","forEachValue","forEachKey","keys","Queue","_tail","_head","enqueue","next","dequeue","current","Set","resource","kv","toArray","Node","shape","links","outgoing","incoming","weight","associatedShape","bounds","data","shortForm","isVirtual","isIsolated","isLinkedTo","node","that","link","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","associatedConnection","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","nodes","_nodeMap","_root","_hasCachedRelationships","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","componentIndex","setItemIndices","componentId","_collectConnectedNodes","components","addNodeAndOutgoings","setIds","nodeIndex","nextId","calcBounds","getSpanningTree","tree","remaining","_addNode","levelCount","pop","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nodeMap","linkMap","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","component","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","unshift","sources","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","options","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","limitToView","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","normalVariable","mean","deviation","log","undefined$1","drawing","defined","util","TRANSPARENT","Markers","none","arrowStart","filledCircle","arrowEnd","START","END","WIDTH","HEIGHT","diffNumericOptions","fields","field","elementOptions","hasChanges","Scale","toMatrix","format","invert","Translation","toMatrixVector","Length","Rotation","ZERO","create","values","CompositeTransform","translate","transform","render","visual","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","AutoSizeableMixin","_setScale","originWidth","_originWidth","originHeight","_originHeight","_setTranslate","_initSize","autoSize","_measure","_updateSize","_diffNumericOptions","Element","_originSize","visible","drawingContainer","redraw","drawingElement","matrix","_hover","force","_measured","box","_boundingBox","startPoint","rawBBox","VisualBase","normalizeDrawingOptions","stroke","opacity","_fill","getColor","_stroke","show","hover","strokeOptions","dashType","fillOptions","gradient","GradientClass","RadialGradient","LinearGradient","TextBlock","_textColor","_font","_initText","fontSize","fontFamily","Text","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","Rectangle","_initPath","_setPosition","_drawPath","Path","closed","sizeOptions","sizeOptionsOrDefault","elements","createSegment","MarkerBase","anchor","createElement","_transformToPath","path","transformCopy","CircleMarker","Circle","positionMarker","targetSegment","ArrowMarker","xDiff","yDiff","_linePoints","deg","endPoint","controlOut","nextSegment","controlIn","prevSegment","MarkerPathMixin","_getPath","MultiPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","append","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","Group","_createElements","_setData","multipath","Line","Polyline","_updatePath","_pointsDiffer","currentPoints","differ","Image","_initImage","src","_rect","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","clippedBBox","Layout","toDrawingRect","drawingRect","reflow","_initCircle","circleOptions","move","_circle","setRadius","Canvas","surface","Surface","_translate","_viewBox","viewBox","setSize","draw","insertBefore","destroy","clearHtml","drawingOptions","Color","toHex","Segment","Movable","Cursors","arrow","grip","cross","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMBOUNDSCHANGE","ROTATED","TARGET","HANDLE_NAMES","PositionAdapter","layoutState","froms","tos","subjects","getShapeById","LayoutUndoUnit","initialState","finalState","animate","_initialState","_finalState","title","undo","setState","redo","state","conn","ticker","CompositeUnit","units","undoUnit","ConnectionEditUnit","redoSource","redoTarget","_redoSource","_redoTarget","_undoSource","_undoTarget","_updateConnector","updateModel","ConnectionEditUndoUnit","undoSource","undoTarget","DeleteConnectionUnit","targetConnector","DeleteShapeUnit","TransformUnit","shapes","undoStates","adorner","redoStates","layout","refreshBounds","refresh","AddConnectionUnit","AddShapeUnit","deselect","PanUndoUnit","initialPosition","finalPosition","finalPos","pan","RotateUnit","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","ToFrontUnit","items","initialIndices","_toIndex","ToBackUnit","UndoRedoService","bind","events","capacity","begin","composite","cancel","commit","execute","_restart","addCompositeItem","count","EmptyTool","toolService","tryActivate","getCursor","ScrollerTool","tool","friction","support","mobileOS","canvas","scroller","scrollable","kendoMobileScroller","velocityMultiplier","mousewheelScrolling","scroll","_move","movableCanvas","virtualScroll","dimension","makeVirtual","virtualSize","dimensions","disable","meta","pannable","enabled","ctrlKey","noMeta","hoveredItem","hoveredAdorner","_hoveredConnector","enable","args","scrollPos","scrollLeft","scrollTop","_storePan","moveTo","_pan","PointerTool","selectSingle","handle","_hitTest","_resizingAdorner","isDragHandle","connections","undoRedoService","_getCursor","SelectionTool","selectable","multiple","selector","isSelected","selectArea","ConnectionTool","connector","_createConnection","_c","canDrag","connectionHandle","_connectionManipulation","_removeHover","activeConnection","_cachedTouchTarget","cachedTouchTarget","sourceConnector","Shape","getConnector","_syncConnectionChanges","_connectorsAdorner","ConnectionEditTool","isActive","handleName","testKey","toUpperCase","ToolService","tools","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","metaKey","altKey","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","cut","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","addToSelection","newConnection","cursor","css","disabledShape","isNew","hit","_visible","selectedConnections","_selectedItems","Connection","_hitTestItems","_hitTestElements","shapeHit","connectionHit","idx","connectors","hitTestShapeConnectors","mainLayer","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","PolylineRouter","route","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","routePoints","_connectorPoints","_floatingPoints","_resolvedSourceConnector","_resolvedTargetConnector","sourcePoint","targetPoint","_connectorSides","axis","boundsPoint","secondarySign","_connectorSide","sideDistance","minSide","side","shapeBounds","sides","MAX_NUM","_sameSideDistance","pointX","pointY","sourceConnectorSide","targetConnectorSide","deltaX","deltaY","sameSideDistance","shiftX","shiftY","cascadeStartHorizontal","_startHorizontal","sourceSide","AdornerBase","_adorners","ConnectionEditAdorner","_ts","sp","tp","spVisual","handles","epVisual","_initialSource","_initialTarget","ts","radiusX","radiusY","sourcePointDistance","distanceTo","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorsAdorner","_refreshHandler","ctr","_clearVisual","ConnectorVisual","_keepCachedTouchTarget","visualChildren","childrenCount","unbind","each","ResizingAdorner","_manipulating","_initSelection","_createHandles","selected","_internalChange","_rotatedHandler","_resizable","editable","resize","_handleOptions","_bounds","handleBounds","handlesCount","_getHandleBounds","_rotationOffset","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","shapeStates","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","hitToOppositeSide","_displaceBounds","newCenter","minWidth","minHeight","oldBounds","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","drag","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","Selector","_ep","_adorn","visualBounds","modelToView","relative","_visualBounds","shiftKey","HyperTree","EPSILON","DEG_TO_RAD","LayoutBase","defaultOptions","subtype","roots","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","gridLayoutComponents","maxWidth","startX","resultLinkSet","resultNodeSet","moveToOffset","boundingRect","currentHeight","currentWidth","deltax","deltay","nodeBounds","newpoints","pt","currentHorizontalOffset","transferOptions","DiagramToHyperTreeAdapter","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","convert","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","_isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isIgnorableItem","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","_isCollapsed","sink","sourceNode","sinkNode","areConnectedAlready","newEdge","finalNodeSet","LayoutState","initialTemperature","temperature","guessBounds","_expectedBounds","refineStage","_repulsion","_attraction","_shake","rho","alpha","_InverseSquareForce","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","measure","Width","arrange","layoutRight","layoutUp","up","layoutDown","down","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","aw","diameter","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","col","deltaTheta","deltaThetaHalf","parentSector","fraction","sorted","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","targetLayer","layerMap","layerCount","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","minDist","layerIndex","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","dest","currentNode","currDown","downNode","order","placed","sequenceStart","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","ctx","fromLayerIndex","layerIncrement","maximumHeight","MIN_VALUE","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","pair","leftHeap","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","o","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","sum","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node2","node1GridPos","node2GridPos","crossAfter","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","graphOrNodes","capture","diagramOrGraphOrNodes","GraphAdapter","geom","Widget","outerWidth","_outerWidth","outerHeight","_outerHeight","HierarchicalDataSource","isPlainObject","math","NS","CASCADING","CHANGE","CLICK","ERROR","MAXINT","SELECT","ITEMROTATE","PAN","ZOOM_START","ZOOM_END","NONE","TRANSFORMED","MOUSEWHEEL_NS","BUTTON_TEMPLATE","className","icon","themeColor","html","renderButton","DefaultConnectors","getPosition","defaultButtons","imageClass","isAutoConnector","closestConnector","resCtr","minimumDistance","indicesOfItems","extra","defaults","DiagramElement","dataItem","_template","serializable","serialize","json","_content","contentOptions","_contentVisual","_updateContentVisual","_createContentVisual","template","elementTemplate","paramName","_canSelect","toJSON","Connector","shapeId","tempStr","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","filterShapeDataItem","redrawVisual","_isEditable","_redrawVisual","syncChanges","_suspendModelRefresh","_resumeModelRefresh","_rotate","_alignContent","contentVisual","containerRect","aligner","contentBounds","bbox","contentRect","alignedBounds","connectorDefaults","_transformedBounds","_rotatedBounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","deselected","_internalSelection","_selectionChanged","deltaAngle","newPosition","sc","con","cons","nameOrPoint","toLocaleLowerCase","fnName","_transformPoint","boundsChange","shapeOptions","shapeVisual","_visualOptions","_updateConnectors","_showConnectors","rotatedPoint","visualOptions","visualTemplate","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","fromConnector","toConnector","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","connectionsDataSource","getByUid","uid","clearField","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","_deferredConnectionUpdates","onActivate","endIdx","startIdx","alignToPath","midIdx","selection","_router","pts","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","minNonConflict","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","Diagram","userOptions","_initTheme","_initElements","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","ShapesQuadTree","adornerLayer","_createHandlers","_clipboard","pauseMouseHandlers","_fetchFreshData","_createGlobalToolBar","_createOptionElements","theme","dataSource","draggable","autoBind","tooltip","connectionDefaults","toolBar","DiagramToolBar","click","_toolBarClick","modal","textAlign","prepend","_resize","createShape","editor","view","createModel","_createShape","edit","createConnection","_connectionsDataMap","addConnection","editModel","editorType","editors","cancelEdit","shapeEditors","shapeTemplate","connectionSelectorHandler","connectionSelector","connectionEditors","connectionTemplate","PopupEditor","_update","_cancel","_editArgs","_getEditDataSource","cancelChanges","_destroyEditor","saveEdit","sync","wrapper","close","attr","addClass","appendTo","userShapeDefaults","copyDefaultOptions","mobile","canvasContainer","viewPort","viewport","on","_wheel","_keydown","_userEvents","UserEvents","multiTouch","fastTap","tap","_tap","_dragStart","_drag","_dragEnd","gesturestart","_gestureStart","gesturechange","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","supportDoubleTap","_mouseover","_mouseout","_mouseMove","_mouseDown","_mouseUp","_syncHandler","_resizeHandler","onResize","_pauseMouseHandlers","_eventPositions","event","_meta","preventDefault","_createToolBar","focused","ctrlPressed","keyCode","origEvent","originalEvent","wheelDelta","detail","mwDelta","touch","pageX","pageY","documentToModel","initialCenter","eventArgs","_gesture","_initialCenter","previousGesture","documentToView","scaleDelta","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","_kendoNode","srcElement","themeOptions","themeName","themes","SASS_THEMES","autoTheme","shapesLength","_createShapes","_createConnections","_findConnectionTarget","unbindResize","off","destroyScroller","_destroyGlobalToolBar","is","_activeElement","scrollContainer","offsets","documentElement","document","parentNode","scrollHeight","load","setOptions","added","removed","_parseBounds","splitDiagramElements","_removeItem","_removeShapeDataItem","_removeConnectionDataItem","_getDiagramItems","_fixOrdering","bringIntoView","original","newPan","_zoomMainLayer","alignShapes","val","raw","hideTooltip","_getPan","animatedScrollTo","scrollTo","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","setDataSource","_dataSource","fetch","setConnectionsDataSource","_connectionDataSource","_redrawConnections","getShapeByModelId","getShapeByModelUid","getConnectionByModelId","getConnectionByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","removedConnections","_removeShape","_removeConnection","_removeDataItems","recursive","_removeShapeConnections","hasChildren","loaded","_addDataItem","_addDataItemByUid","_addDataItems","parentShape","_refreshSource","dataBound","_bindingRoots","_addItem","preventClosing","singleToolBar","popupZIndex","closest","popupWidth","_popup","popupHeight","connectionBounds","showAt","one","_normalizePointZoom","InactiveItemsCollection","undone","redone","_loadingShapes","_loadingConnections","dsOptions","ds","_shapesRefreshHandler","_shapesRequestStartHandler","_shapesErrorHandler","_refreshShapes","_shapesRequestStart","_error","DataSource","_treeDataSource","_connectionsRefreshHandler","_connectionsRequestStartHandler","_connectionsErrorHandler","_refreshConnections","_connectionsRequestStart","_connectionsError","_shouldRefresh","_removeShapes","_updateShapes","_syncShapes","_suspended","_rebindShapesAndConnections","_addShapes","_addConnections","inactiveItems","activate","dataItems","_removeConnections","_updateConnections","_addConnectionDataItem","_validateConnector","_unbindDataSource","_errorHandler","adorners","_refresh","hide","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","when","then","deferredConnectionUpdates","ExportMixin","PDFMixin","_tools","createToolBar","createTools","appendTools","createPopup","kendoPopup","getKendoPopup","buttons","_toolBar","kendoToolBar","resizable","getKendoToolBar","createTool","toolName","attributes","_setAttributes","open","newGroup","editTool","showText","deleteTool","rotateAnticlockwiseTool","_appendGroup","_rotateGroup","rotateClockwiseTool","createShapeTool","_createGroup","createConnectionTool","undoTool","_historyGroup","redoTool","prop","_getAttributes","eventData","selectedElements","delete","selectedElemens","rotateClockwise","rotateAnticlockwise","Editor","_getFields","_initContainer","createEditable","Editable","clearContainer","modelFields","columns","formContent","_renderTemplate","_renderFields","_renderButtons","Window","userTriggered","sender","_cancelClick","_attachButtonEvents","unescape","form","_createButton","_cancelClickHandler","_updateClickHandler","_updateClick","_editUpdateClickHandler","reader","textField","idField","kendoDropDownList","dataValueField","dataTextField","optionLabel","valuePrimitive","InactiveItem","callbacks","callback","deffered","Deferred","deferred","resolve","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","childIdx","shapeIdx","halfWidth","halfHeight","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","bottomY","xIdx","yIdx","Model","_defaultId","ObservableObject","mainOptions","plugin","__meta__","category","description","depends","features","kendo$1"],"mappings":"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","file":"kendo.dataviz.diagram.js","sourcesContent":["import './kendo.data.js';\nimport './kendo.draganddrop.js';\nimport './kendo.userevents.js';\nimport './kendo.mobile.scroller.js';\nimport './kendo.core.js';\nimport './kendo.dataviz.core.js';\nimport './kendo.drawing.js';\nimport './kendo.toolbar.js';\nimport './kendo.editable.js';\nimport './kendo.window.js';\nimport './kendo.dropdownlist.js';\nimport './kendo.dataviz.themes.js';\nimport './kendo.html.button.js';\n\n(function($, undefined$1) {\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram = {},\n        deepExtend = kendo.deepExtend,\n        isArray = Array.isArray,\n        EPSILON = 1e-06;\n\n    /*-------------------Diverse utilities----------------------------*/\n    var Utils = {\n    };\n\n    deepExtend(Utils, {\n        isNearZero: function(num) {\n            return Math.abs(num) < EPSILON;\n        },\n        isDefined: function(obj) {\n            return typeof obj !== 'undefined';\n        },\n\n        isUndefined: function(obj) {\n            return (typeof obj === 'undefined') || obj === null;\n        },\n        /**\n         * Returns whether the given object is an object or a value.\n         */\n        isObject: function(obj) {\n            return obj === Object(obj);\n        },\n        /**\n         * Returns whether the object has a property with the given name.\n         */\n        has: function(obj, key) {\n            return Object.hasOwnProperty.call(obj, key);\n        },\n        /**\n         * Returns whether the given object is a string.\n         */\n        isString: function(obj) {\n            return Object.prototype.toString.call(obj) == '[object String]';\n        },\n        isBoolean: function(obj) {\n            return Object.prototype.toString.call(obj) == '[object Boolean]';\n        },\n        isType: function(obj, type) {\n            return Object.prototype.toString.call(obj) == '[object ' + type + ']';\n        },\n        /**\n         * Returns whether the given object is a number.\n         */\n        isNumber: function(obj) {\n            return !isNaN(parseFloat(obj)) && isFinite(obj);\n        },\n        /**\n         * Return whether the given object (array or dictionary).\n         */\n        isEmpty: function(obj) {\n            if (obj === null) {\n                return true;\n            }\n            if (isArray(obj) || Utils.isString(obj)) {\n                return obj.length === 0;\n            }\n            for (var key in obj) {\n                if (Utils.has(obj, key)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        simpleExtend: function(destination, source) {\n            if (!Utils.isObject(source)) {\n                return;\n            }\n\n            for (var name in source) {\n                destination[name] = source[name];\n            }\n        },\n        /**\n         * Returns an array of the specified size and with each entry set to the given value.\n         * @param size\n         * @param value\n         * @returns {Array}\n         */\n        initArray: function createIdArray(size, value) {\n            var array = [];\n            for (var i = 0; i < size; ++i) {\n                array[i] = value;\n            }\n            return array;\n        },\n        serializePoints: function(points) {\n            var res = [];\n            for (var i = 0; i < points.length; i++) {\n                var p = points[i];\n                res.push(p.x + \";\" + p.y);\n            }\n            return res.join(\";\");\n        },\n        deserializePoints: function(s) {\n            var v = s.split(\";\"), points = [];\n            if (v.length % 2 !== 0) {\n                throw \"Not an array of points.\";\n            }\n            for (var i = 0; i < v.length; i += 2) {\n                points.push(new diagram.Point(\n                    parseInt(v[i], 10),\n                    parseInt(v[i + 1], 10)\n                ));\n            }\n            return points;\n        },\n        /**\n         * Returns an integer within the given bounds.\n         * @param lower The inclusive lower bound.\n         * @param upper The exclusive upper bound.\n         * @returns {number}\n         */\n        randomInteger: function(lower, upper) {\n            return parseInt(Math.floor(Math.random() * upper) + lower, 10);\n        } ,\n        /*\n         Depth-first traversal of the given node.\n         */\n        DFT: function(el, func) {\n            func(el);\n            if (el.childNodes) {\n                for (var i = 0; i < el.childNodes.length; i++) {\n                    var item = el.childNodes[i];\n                    this.DFT(item, func);\n                }\n            }\n        },\n        /*\n         Returns the angle in degrees for the given matrix\n         */\n        getMatrixAngle: function(m) {\n            if (m === null || m.d === 0) {\n                return 0;\n            }\n            return Math.atan2(m.b, m.d) * 180 / Math.PI;\n        },\n\n        /*\n         Returns the scaling factors for the given matrix.\n         */\n        getMatrixScaling: function(m) {\n            var sX = Math.sqrt(m.a * m.a + m.c * m.c);\n            var sY = Math.sqrt(m.b * m.b + m.d * m.d);\n            return [sX, sY];\n        }\n\n    });\n\n    /**\n     * The Range defines an array of equally separated numbers.\n     * @param start The start-value of the Range.\n     * @param stop The end-value of the Range.\n     * @param step The separation between the values (default:1).\n     * @returns {Array}\n     */\n    function Range(start, stop, step) {\n        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n            return [];\n        }\n        if (step && Utils.sign(stop - start) != Utils.sign(step)) {\n            throw \"The sign of the increment should allow to reach the stop-value.\";\n        }\n        step = step || 1;\n        start = start || 0;\n        stop = stop || start;\n        if ((stop - start) / step === Infinity) {\n            throw \"Infinite range defined.\";\n        }\n        var range = [], i = -1, j;\n\n        function rangeIntegerScale(x) {\n            var k = 1;\n            while (x * k % 1) {\n                k *= 10;\n            }\n            return k;\n        }\n\n        var k = rangeIntegerScale(Math.abs(step));\n        start *= k;\n        stop *= k;\n        step *= k;\n        if (start > stop && step > 0) {\n            step = -step;\n        }\n        if (step < 0) {\n            while ((j = start + step * ++i) >= stop) {\n                range.push(j / k);\n            }\n        }\n        else {\n            while ((j = start + step * ++i) <= stop) {\n                range.push(j / k);\n            }\n        }\n        return range;\n    }\n\n    /*-------------------Diverse math functions----------------------------*/\n\n    function findRadian(start, end) {\n        if (start == end) {\n            return 0;\n        }\n        var sngXComp = end.x - start.x,\n            sngYComp = start.y - end.y,\n            atan = Math.atan(sngXComp / sngYComp);\n        if (sngYComp >= 0) {\n            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n        }\n        return atan + Math.PI;\n    }\n\n    Utils.sign = function(number) {\n        return number ? number < 0 ? -1 : 1 : 0;\n    };\n\n    Utils.findAngle = function(center, end) {\n        return findRadian(center, end) * 180 / Math.PI;\n    };\n\n    /*-------------------Array Helpers ----------------------------*/\n\n    Utils.forEach = function(arr, iterator, thisRef) {\n        for (var i = 0; i < arr.length; i++) {\n            iterator.call(thisRef, arr[i], i, arr);\n        }\n    };\n\n    Utils.any = function(arr, predicate) {\n        for (var i = 0; i < arr.length; ++i) {\n            if (predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n        return null;\n    };\n\n    Utils.remove = function(arr, what) {\n        var ax;\n        while ((ax = Utils.indexOf(arr, what)) !== -1) {\n            arr.splice(ax, 1);\n        }\n        return arr;\n    };\n\n    Utils.contains = function(arr, obj) {\n        return Utils.indexOf(arr, obj) !== -1;\n    };\n\n    Utils.indexOf = function(arr, what) {\n        return $.inArray(what, arr);\n    };\n\n    Utils.fold = function(list, iterator, acc, context) {\n        var initial = arguments.length > 2;\n\n        for (var i = 0; i < list.length; i++) {\n            var value = list[i];\n            if (!initial) {\n                acc = value;\n                initial = true;\n            }\n            else {\n                acc = iterator.call(context, acc, value, i, list);\n            }\n        }\n\n        if (!initial) {\n            throw 'Reduce of empty array with no initial value';\n        }\n\n        return acc;\n    };\n\n    Utils.find = function(arr, iterator, context) {\n        var result;\n        Utils.any(arr, function(value, index, list) {\n            if (iterator.call(context, value, index, list)) {\n                result = value;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    };\n\n    Utils.first = function(arr, constraint, context) {\n        if (arr.length === 0) {\n            return null;\n        }\n        if (Utils.isUndefined(constraint)) {\n            return arr[0];\n        }\n\n        return Utils.find(arr, constraint, context);\n    };\n\n    /**\n     * Inserts the given element at the specified position and returns the result.\n     */\n    Utils.insert = function(arr, element, position) {\n        arr.splice(position, 0, element);\n        return arr;\n    };\n\n    Utils.all = function(arr, iterator, context) {\n        var result = true;\n        var value;\n\n        for (var i = 0; i < arr.length; i++) {\n            value = arr[i];\n            result = result && iterator.call(context, value, i, arr);\n\n            if (!result) {\n                break;\n            }\n        }\n\n        return result;\n    };\n\n    Utils.clear = function(arr) {\n        arr.splice(0, arr.length);\n    };\n\n    /**\n     * Sort the arrays on the basis of the first one (considered as keys and the other array as values).\n     * @param a\n     * @param b\n     * @param sortfunc (optiona) sorting function for the values in the first array\n     */\n    Utils.bisort = function(a, b, sortfunc) {\n        if (Utils.isUndefined(a)) {\n            throw \"First array is not specified.\";\n        }\n        if (Utils.isUndefined(b)) {\n            throw \"Second array is not specified.\";\n        }\n        if (a.length != b.length) {\n            throw \"The two arrays should have equal length\";\n        }\n\n        var all = [], i;\n\n        for (i = 0; i < a.length; i++) {\n            all.push({ 'x': a[i], 'y': b[i] });\n        }\n        if (Utils.isUndefined(sortfunc)) {\n            all.sort(function(m, n) {\n                return m.x - n.x;\n            });\n        }\n        else {\n            all.sort(function(m, n) {\n                return sortfunc(m.x, n.x);\n            });\n        }\n\n        Utils.clear(a);\n        Utils.clear(b);\n\n        for (i = 0; i < all.length; i++) {\n            a.push(all[i].x);\n            b.push(all[i].y);\n        }\n    };\n\n    Utils.addRange = function(arr, range) {\n        arr.push.apply(arr, range);\n    };\n\n    var Easing = {\n        easeInOut: function(pos) {\n            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n        }\n    };\n\n    /**\n     * An animation ticker driving an adapter which sets a particular\n     * property in function of the tick.\n     * @type {*}\n     */\n    var Ticker = kendo.Class.extend({\n        init: function() {\n            this.adapters = [];\n            this.target = 0;\n            this.tick = 0;\n            this.interval = 20;\n            this.duration = 800;\n            this.lastTime = null;\n            this.handlers = [];\n            var _this = this;\n            this.transition = Easing.easeInOut;\n            this.timerDelegate = function() {\n                _this.onTimerEvent();\n            };\n        },\n        addAdapter: function(a) {\n            this.adapters.push(a);\n        },\n        onComplete: function(handler) {\n            this.handlers.push(handler);\n        },\n        removeHandler: function(handler) {\n            this.handlers = $.grep(this.handlers, function(h) {\n                return h !== handler;\n            });\n        },\n        trigger: function() {\n            var _this = this;\n            if (this.handlers) {\n                Utils.forEach(this.handlers, function(h) {\n                    return h.call(_this.caller !== null ? _this.caller : _this);\n                });\n            }\n        },\n        onStep: function() {\n        },\n        seekTo: function(to) {\n            this.seekFromTo(this.tick, to);\n        },\n        seekFromTo: function(from, to) {\n            this.target = Math.max(0, Math.min(1, to));\n            this.tick = Math.max(0, Math.min(1, from));\n            this.lastTime = new Date().getTime();\n            if (!this.intervalId) {\n                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n            }\n        },\n        stop: function() {\n            if (this.intervalId) {\n                window.clearInterval(this.intervalId);\n                this.intervalId = null;\n\n                //this.trigger.call(this);\n                this.trigger();\n                // this.next();\n            }\n        },\n        play: function(origin) {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            if (origin !== null) {\n                this.caller = origin;\n            }\n            this.initState();\n            this.seekFromTo(0, 1);\n        },\n        reverse: function() {\n            this.seekFromTo(1, 0);\n        },\n        initState: function() {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            for (var i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].initState();\n            }\n        },\n        propagate: function() {\n            var value = this.transition(this.tick);\n\n            for (var i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].update(value);\n            }\n        },\n        onTimerEvent: function() {\n            var now = new Date().getTime();\n            var timePassed = now - this.lastTime;\n            this.lastTime = now;\n            var movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                this.tick = this.target;\n            } else {\n                this.tick += movement;\n            }\n\n            try {\n                this.propagate();\n            } finally {\n                this.onStep.call(this);\n                if (this.target == this.tick) {\n                    this.stop();\n                }\n            }\n        }\n    });\n\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n\n        Utils: Utils,\n        Range: Range,\n        Ticker: Ticker\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    // Imports ================================================================\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Class = kendo.Class,\n        deepExtend = kendo.deepExtend,\n        Utils = diagram.Utils,\n        Point = kendo.geometry.Point,\n        isFunction = kendo.isFunction,\n        contains = Utils.contains,\n        map = $.map;\n\n    // Constants ==============================================================\n    var HITTESTAREA = 3,\n        EPSILON = 1e-06;\n\n    class ExtendedPoint extends Point {\n        constructor(x, y) {\n            super(x, y);\n        }\n\n        clone() {\n            return new ExtendedPoint(this.x, this.y);\n        }\n\n        plus(p) {\n            return new ExtendedPoint(this.x + p.x, this.y + p.y);\n        }\n\n        minus(p) {\n            return new ExtendedPoint(this.x - p.x, this.y - p.y);\n        }\n\n        offset(value) {\n            return new ExtendedPoint(this.x - value, this.y - value);\n        }\n\n        times(s) {\n            return new ExtendedPoint(this.x * s, this.y * s);\n        }\n\n        normalize() {\n            if (this.length() === 0) {\n                return new ExtendedPoint();\n            }\n            return this.times(1 / this.length());\n        }\n\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n\n        toString() {\n            return \"(\" + this.x + \",\" + this.y + \")\";\n        }\n\n        lengthSquared() {\n            return (this.x * this.x + this.y * this.y);\n        }\n\n        middleOf(p, q) {\n            return new ExtendedPoint(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n        }\n\n        toPolar(useDegrees) {\n            var factor = 1;\n            if (useDegrees) {\n                factor = 180 / Math.PI;\n            }\n            var a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            var halfpi = Math.PI / 2;\n            var len = this.length();\n            if (this.x === 0) {\n                // note that the angle goes down and not the usual mathematical convention\n\n                if (this.y === 0) {\n                    return new Polar(0, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * halfpi);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * 3 * halfpi);\n                }\n            }\n            else if (this.x > 0) {\n                if (this.y === 0) {\n                    return new Polar(len, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * a);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (4 * halfpi - a));\n                }\n            }\n            else {\n                if (this.y === 0) {\n                    return new Polar(len, 2 * halfpi);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * (2 * halfpi - a));\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (2 * halfpi + a));\n                }\n            }\n        }\n        isOnLine(from, to) {\n            if (from.x > to.x) { // from must be the leftmost point\n                var temp = to;\n                to = from;\n                from = temp;\n            }\n            var r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA),\n                r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA), o1, u1;\n            if (r1.union(r2).contains(this)) {\n                if (from.x === to.x || from.y === to.y) {\n                    return true;\n                }\n                else if (from.y < to.y) {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                }\n                else {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                }\n                return (this.x > o1 && this.x < u1);\n            }\n            return false;\n        }\n        parse(str) {\n            var tempStr = str.slice(1, str.length - 1),\n                xy = tempStr.split(\",\"),\n                x = parseInt(xy[0], 10),\n                y = parseInt(xy[1], 10);\n            if (!isNaN(x) && !isNaN(y)) {\n                return new ExtendedPoint(x, y);\n            }\n        }\n    }\n\n    /**\n     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n     * If the additional points are null or equal to the first point the path will be sharp.\n     * Left and right correspond to the direction of the underlying path.\n     */\n    var PathDefiner = Class.extend(\n        {\n            init: function(p, left, right) {\n                this.point = p;\n                this.left = left;\n                this.right = right;\n            }\n        }\n    );\n\n    /**\n     * Defines a rectangular region.\n     */\n    var Rect = Class.extend({\n        init: function(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        },\n        contains: function(point) {\n            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n        },\n        inflate: function(dx, dy) {\n            if (dy === undefined$1) {\n                dy = dx;\n            }\n\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n        },\n        offset: function(dx, dy) {\n            var x = dx, y = dy;\n            if (dx instanceof ExtendedPoint) {\n                x = dx.x;\n                y = dx.y;\n            }\n            this.x += x;\n            this.y += y;\n            return this;\n        },\n        union: function(r) {\n            var x1 = Math.min(this.x, r.x);\n            var y1 = Math.min(this.y, r.y);\n            var x2 = Math.max((this.x + this.width), (r.x + r.width));\n            var y2 = Math.max((this.y + this.height), (r.y + r.height));\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        },\n        center: function() {\n            return new ExtendedPoint(this.x + this.width / 2, this.y + this.height / 2);\n        },\n        top: function() {\n            return new ExtendedPoint(this.x + this.width / 2, this.y);\n        },\n        right: function() {\n            return new ExtendedPoint(this.x + this.width, this.y + this.height / 2);\n        },\n        bottom: function() {\n            return new ExtendedPoint(this.x + this.width / 2, this.y + this.height);\n        },\n        left: function() {\n            return new ExtendedPoint(this.x, this.y + this.height / 2);\n        },\n        topLeft: function() {\n            return new ExtendedPoint(this.x, this.y);\n        },\n        topRight: function() {\n            return new ExtendedPoint(this.x + this.width, this.y);\n        },\n        bottomLeft: function() {\n            return new ExtendedPoint(this.x, this.y + this.height);\n        },\n        bottomRight: function() {\n            return new ExtendedPoint(this.x + this.width, this.y + this.height);\n        },\n        clone: function() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        },\n        isEmpty: function() {\n            return !this.width && !this.height;\n        },\n        equals: function(rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n        },\n        rotatedBounds: function(angle) {\n            var rect = this.clone(),\n                points = this.rotatedPoints(angle),\n                tl = points[0],\n                tr = points[1],\n                br = points[2],\n                bl = points[3];\n\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n\n            return rect;\n        },\n        rotatedPoints: function(angle) {\n            var rect = this,\n                c = rect.center(),\n                br = rect.bottomRight().rotate(angle, c),\n                tl = rect.topLeft().rotate(angle, c),\n                tr = rect.topRight().rotate(angle, c),\n                bl = rect.bottomLeft().rotate(angle, c);\n\n            return [tl, tr, br, bl];\n        },\n        toString: function(delimiter) {\n            delimiter = delimiter || \" \";\n\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n        },\n        scale: function(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            var tl = this.topLeft();\n            var thisCenter = this.center();\n            tl.rotate(angle, thisCenter).rotate(angle, adornerCenter);\n\n            var delta = staicPoint.minus(tl);\n            var scaled = new ExtendedPoint(delta.x * scaleX, delta.y * scaleY);\n            var position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(angle, adornerCenter).rotate(angle, thisCenter);\n\n            this.x = tl.x;\n            this.y = tl.y;\n\n            this.width *= scaleX;\n            this.height *= scaleY;\n        },\n\n        zoom: function(zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n        },\n\n        overlaps: function(rect) {\n            var bottomRight = this.bottomRight();\n            var rectBottomRight = rect.bottomRight();\n            var overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n        }\n    });\n\n    var Size = Class.extend({\n        init: function(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n    });\n\n    Size.prototype.Empty = new Size(0, 0);\n\n    Rect.toRect = function(rect) {\n        if (!(rect instanceof Rect)) {\n            rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n        }\n\n        return rect;\n    };\n\n    Rect.empty = function() {\n        return new Rect(0, 0, 0, 0);\n    };\n\n    Rect.fromPoints = function(p, q) {\n        if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n            throw \"Some values are NaN.\";\n        }\n        return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n    };\n\n    function isNearZero(num) {\n        return Math.abs(num) < EPSILON;\n    }\n\n    function intersectLine(start1, end1, start2, end2, isSegment) {\n        var tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n        if (isNearZero(tangensdiff)) {\n            //parallel lines\n            return;\n        }\n\n        var num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n        var num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n        var r = num1 / tangensdiff;\n        var s = num2 / tangensdiff;\n\n        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            //r < 0 => line 1 is below line 2\n            //r > 1 => line 1 is above line 2\n            //s < 0 => line 2 is below line 1\n            //s > 1 => line 2 is above line 1\n            return;\n        }\n\n        return new ExtendedPoint(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n    }\n\n    var Intersect = {\n        lines: function(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n        },\n        segments: function(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n        },\n        rectWithLine: function(rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n        },\n        rects: function(rect1, rect2, angle) {\n            var tl = rect2.topLeft(),\n                tr = rect2.topRight(),\n                bl = rect2.bottomLeft(),\n                br = rect2.bottomRight();\n            var center = rect2.center();\n            if (angle) {\n                tl = tl.rotate(angle, center);\n                tr = tr.rotate(angle, center);\n                bl = bl.rotate(angle, center);\n                br = br.rotate(angle, center);\n            }\n\n            var intersect = rect1.contains(tl) ||\n                rect1.contains(tr) ||\n                rect1.contains(bl) ||\n                rect1.contains(br) ||\n                Intersect.rectWithLine(rect1, tl, tr) ||\n                Intersect.rectWithLine(rect1, tl, bl) ||\n                Intersect.rectWithLine(rect1, tr, br) ||\n                Intersect.rectWithLine(rect1, bl, br);\n\n            if (!intersect) {//last possible case is rect1 to be completely within rect2\n                tl = rect1.topLeft();\n                tr = rect1.topRight();\n                bl = rect1.bottomLeft();\n                br = rect1.bottomRight();\n\n                if (angle) {\n                    var reverseAngle = 360 - angle;\n                    tl = tl.rotate(reverseAngle, center);\n                    tr = tr.rotate(reverseAngle, center);\n                    bl = bl.rotate(reverseAngle, center);\n                    br = br.rotate(reverseAngle, center);\n                }\n\n                intersect = rect2.contains(tl) ||\n                    rect2.contains(tr) ||\n                    rect2.contains(bl) ||\n                    rect2.contains(br);\n            }\n\n            return intersect;\n        }\n    };\n\n    /**\n     * Aligns two rectangles, where one is the container and the other is content.\n     */\n    var RectAlign = Class.extend({\n        init: function(container) {\n            this.container = Rect.toRect(container);\n        },\n\n        align: function(content, alignment) {\n            var alignValues = alignment.toLowerCase().split(\" \");\n\n            for (var i = 0; i < alignValues.length; i++) {\n                content = this._singleAlign(content, alignValues[i]);\n            }\n\n            return content;\n        },\n        _singleAlign: function(content, alignment) {\n            if (isFunction(this[alignment])) {\n                return this[alignment](content);\n            }\n            else {\n                return content;\n            }\n        },\n\n        left: function(content) {\n            return this._align(content, this._left);\n        },\n        center: function(content) {\n            return this._align(content, this._center);\n        },\n        right: function(content) {\n            return this._align(content, this._right);\n        },\n        stretch: function(content) {\n            return this._align(content, this._stretch);\n        },\n        top: function(content) {\n            return this._align(content, this._top);\n        },\n        middle: function(content) {\n            return this._align(content, this._middle);\n        },\n        bottom: function(content) {\n            return this._align(content, this._bottom);\n        },\n\n        _left: function(container, content) {\n            content.x = container.x;\n        },\n        _center: function(container, content) {\n            content.x = ((container.width - content.width) / 2) || 0;\n        },\n        _right: function(container, content) {\n            content.x = container.width - content.width;\n        },\n        _top: function(container, content) {\n            content.y = container.y;\n        },\n        _middle: function(container, content) {\n            content.y = ((container.height - content.height) / 2) || 0;\n        },\n        _bottom: function(container, content) {\n            content.y = container.height - content.height;\n        },\n        _stretch: function(container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n        },\n        _align: function(content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n\n            return content;\n        }\n    });\n\n    var Polar = Class.extend({\n        init: function(r, a) {\n            this.r = r;\n            this.angle = a;\n        }\n    });\n\n    /**\n     * SVG transformation matrix.\n     */\n    var Matrix = Class.extend({\n        init: function(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        },\n        plus: function(m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n        },\n        minus: function(m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n        },\n        times: function(m) {\n            return new Matrix(\n                this.a * m.a + this.c * m.b,\n                this.b * m.a + this.d * m.b,\n                this.a * m.c + this.c * m.d,\n                this.b * m.c + this.d * m.d,\n                this.a * m.e + this.c * m.f + this.e,\n                this.b * m.e + this.d * m.f + this.f\n            );\n        },\n        apply: function(p) {\n            return new ExtendedPoint(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n        },\n        applyRect: function(r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n        },\n        toString: function() {\n            return \"matrix(\" + this.a + \" \" + this.b + \" \" + this.c + \" \" + this.d + \" \" + this.e + \" \" + this.f + \")\";\n        }\n    });\n\n    deepExtend(Matrix, {\n        fromSVGMatrix: function(vm) {\n            var m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n        },\n        fromMatrixVector: function(v) {\n            var m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n        },\n        fromList: function(v) {\n            if (v.length !== 6) {\n                throw \"The given list should consist of six elements.\";\n            }\n            var m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n        },\n        translation: function(x, y) {\n            var m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n        },\n        unit: function() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        },\n        rotation: function(angle, x, y) {\n            var m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = (x - x * m.a + y * m.b) || 0;\n            m.f = (y - y * m.a - x * m.b) || 0;\n            return m;\n        },\n        scaling: function(scaleX, scaleY) {\n            var m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n        },\n        parse: function(v) {\n            var parts, nums;\n            if (v) {\n                v = v.trim();\n                // of the form \"matrix(...)\"\n                if (v.slice(0, 6).toLowerCase() === \"matrix\") {\n                    nums = v.slice(7, v.length - 1).trim();\n                    parts = nums.split(\",\");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                    parts = nums.split(\" \");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                // of the form \"(...)\"\n                if (v.slice(0, 1) === \"(\" && v.slice(v.length - 1) === \")\") {\n                    v = v.substr(1, v.length - 1);\n                }\n                if (v.indexOf(\",\") > 0) {\n                    parts = v.split(\",\");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                if (v.indexOf(\" \") > 0) {\n                    parts = v.split(\" \");\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function(p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n            }\n            return parts;\n        }\n    });\n\n    /**\n     * SVG transformation represented as a vector.\n     */\n    var MatrixVector = Class.extend({\n        init: function(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        },\n        fromMatrix: function FromMatrix(m) {\n            var v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n        }\n    });\n\n    /**\n     * Returns a value with Gaussian (normal) distribution.\n     * @param mean The mean value of the distribution.\n     * @param deviation The deviation (spreading at half-height) of the distribution.\n     * @returns {number}\n     */\n    function normalVariable(mean, deviation) {\n        var x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        }\n        while (!r || r > 1);\n        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    }\n\n    /**\n     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n     * @returns {string}\n     */\n    function randomId(length) {\n        if (Utils.isUndefined(length)) {\n            length = 10;\n        }\n        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n        var result = '';\n        var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for (var i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n        }\n        return result;\n    }\n\n    var Geometry = {\n\n        /**\n         * Returns the squared distance to the line defined by the two given Points.\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        _distanceToLineSquared: function(p, a, b) {\n            function d2(pt1, pt2) {\n                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n\n            if (a === b) { // returns the distance of p to a\n                return d2(p, a);\n            }\n\n            var vx = b.x - a.x,\n                vy = b.y - a.y,\n                dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n            if (dot < 0) {\n                return d2(a, p); // sits on side of a\n            }\n\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n            if (dot < 0) {\n                return d2(b, p); // sits on side of b\n            }\n            // regular case, use crossproduct to get the sine out\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n        },\n\n        /**\n         * Returns the distance to the line defined by the two given Points.\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        distanceToLine: function(p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n        },\n\n        /**\n         * Returns the distance of the given points to the polyline defined by the points.\n         * @param p An arbitrary point.\n         * @param points The points defining the polyline.\n         * @returns {Number}\n         */\n        distanceToPolyline: function(p, points) {\n            var minimum = Number.MAX_VALUE;\n            if (Utils.isUndefined(points) || points.length === 0) {\n                return Number.MAX_VALUE;\n            }\n            for (var s = 0; s < points.length - 1; s++) {\n                var p1 = points[s];\n                var p2 = points[s + 1];\n\n                var d = this._distanceToLineSquared(p, p1, p2);\n                if (d < minimum) {\n                    minimum = d;\n                }\n            }\n            return Math.sqrt(minimum);\n        }\n    };\n\n    /*---------------The HashTable structure--------------------------------*/\n\n    /**\n     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n     * _buckets[hashId] = {key: key, value:...}\n     * Important: do not use the standard Array access method, use the get/set methods instead.\n     * See http://en.wikipedia.org/wiki/Hash_table\n     */\n    var HashTable = kendo.Class.extend({\n        init: function() {\n            this._buckets = [];\n            this.length = 0;\n        },\n\n        /**\n         * Adds the literal object with the given key (of the form {key: key,....}).\n         */\n        add: function(key, value) {\n\n            var obj = this._createGetBucket(key);\n            if (Utils.isDefined(value)) {\n                obj.value = value;\n            }\n            return obj;\n        },\n\n        /**\n         * Gets the literal object with the given key.\n         */\n        get: function(key) {\n            if (this._bucketExists(key)) {\n                return this._createGetBucket(key);\n            }\n            return null;\n        },\n\n        /**\n         * Set the key-value pair.\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set: function(key, value) {\n            this.add(key, value);\n        },\n\n        /**\n         * Determines whether the HashTable contains a specific key.\n         */\n        containsKey: function(key) {\n            return this._bucketExists(key);\n        },\n\n        /**\n         * Removes the element with the specified key from the hashtable.\n         * Returns the removed bucket.\n         */\n        remove: function(key) {\n            if (this._bucketExists(key)) {\n                var hashId = this._hash(key);\n                delete this._buckets[hashId];\n                this.length--;\n                return key;\n            }\n        },\n\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         * @param func\n         */\n        forEach: function(func) {\n            var hashes = this._hashes();\n            for (var i = 0, len = hashes.length; i < len; i++) {\n                var hash = hashes[i];\n                var bucket = this._buckets[hash];\n                if (Utils.isUndefined(bucket)) {\n                    continue;\n                }\n                func(bucket);\n            }\n        },\n\n        /**\n         * Returns a (shallow) clone of the current HashTable.\n         * @returns {HashTable}\n         */\n        clone: function() {\n            var ht = new HashTable();\n            var hashes = this._hashes();\n            for (var i = 0, len = hashes.length; i < len; i++) {\n                var hash = hashes[i];\n                var bucket = this._buckets[hash];\n                if (Utils.isUndefined(bucket)) {\n                    continue;\n                }\n                ht.add(bucket.key, bucket.value);\n            }\n            return ht;\n        },\n\n        /**\n         * Returns the hashes of the buckets.\n         * @returns {Array}\n         * @private\n         */\n        _hashes: function() {\n            var hashes = [];\n            for (var hash in this._buckets) {\n                if (this._buckets.hasOwnProperty(hash)) {\n                    hashes.push(hash);\n                }\n            }\n            return hashes;\n        },\n\n        _bucketExists: function(key) {\n            var hashId = this._hash(key);\n            return Utils.isDefined(this._buckets[hashId]);\n        },\n\n        /**\n         * Returns-adds the createGetBucket with the given key. If not present it will\n         * be created and returned.\n         * A createGetBucket is a literal object of the form {key: key, ...}.\n         */\n        _createGetBucket: function(key) {\n            var hashId = this._hash(key);\n            var bucket = this._buckets[hashId];\n            if (Utils.isUndefined(bucket)) {\n                bucket = { key: key };\n                this._buckets[hashId] = bucket;\n                this.length++;\n            }\n            return bucket;\n        },\n\n        /**\n         * Hashing of the given key.\n         */\n        _hash: function(key) {\n            if (Utils.isNumber(key)) {\n                return key;\n            }\n            if (Utils.isString(key)) {\n                return this._hashString(key);\n            }\n            if (Utils.isObject(key)) {\n                return this._objectHashId(key);\n            }\n            throw \"Unsupported key type.\";\n        },\n\n        /**\n         * Hashing of a string.\n         */\n        _hashString: function(s) {\n            // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n            var result = 0;\n            if (s.length === 0) {\n                return result;\n            }\n            for (var i = 0; i < s.length; i++) {\n                var ch = s.charCodeAt(i);\n                result = ((result * 32) - result) + ch;\n            }\n            return result;\n        },\n\n        /**\n         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n         */\n        _objectHashId: function(key) {\n            var id = key._hashId;\n            if (Utils.isUndefined(id)) {\n                id = randomId();\n                key._hashId = id;\n            }\n            return id;\n        }\n    });\n\n    /*---------------The Dictionary structure--------------------------------*/\n\n    /**\n     * Represents a collection of key-value pairs.\n     * Important: do not use the standard Array access method, use the get/Set methods instead.\n     */\n    var Dictionary = kendo.Observable.extend({\n        /**\n         * Initializes a new instance of the Dictionary class.\n         * @param dictionary Loads the content of the given dictionary into this new one.\n         */\n        init: function(dictionary) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (Utils.isDefined(dictionary)) {\n                if (Array.isArray(dictionary)) {\n                    for (var i = 0; i < dictionary.length; i++) {\n                        this.add(dictionary[i]);\n                    }\n                } else {\n                    dictionary.forEach(function(k, v) {\n                        this.add(k, v);\n                    }, this);\n                }\n            }\n        },\n\n        /**\n         * Adds a key-value to the dictionary.\n         * If the key already exists this will assign the given value to the existing entry.\n         */\n        add: function(key, value) {\n            var entry = this._hashTable.get(key);\n            if (!entry) {\n                entry = this._hashTable.add(key);\n                this.length++;\n                this.trigger('changed');\n            }\n            entry.value = value;\n        },\n\n        /**\n         * Set the key-value pair.\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set: function(key, value) {\n            this.add(key, value);\n        },\n\n        /**\n         * Gets the value associated with the given key in the dictionary.\n         */\n        get: function(key) {\n            var entry = this._hashTable.get(key);\n            if (entry) {\n                return entry.value;\n            }\n            throw new Error(\"Cannot find key \" + key);\n        },\n\n        /**\n         * Returns whether the dictionary contains the given key.\n         */\n        containsKey: function(key) {\n            return this._hashTable.containsKey(key);\n        },\n\n        /**\n         * Removes the element with the specified key from the dictionary.\n         */\n        remove: function(key) {\n            if (this.containsKey(key)) {\n                this.trigger(\"changed\");\n                this.length--;\n                return this._hashTable.remove(key);\n            }\n        },\n\n        /**\n         * The functional gets the key and value as parameters.\n         */\n        forEach: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.key, entry.value);\n            });\n        },\n\n        /**\n         * Same as forEach except that only the value is passed to the functional.\n         */\n        forEachValue: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.value);\n            });\n        },\n\n        /**\n         * Calls a defined callback function for each key in the dictionary.\n         */\n        forEachKey: function(func, thisRef) {\n            this._hashTable.forEach(function(entry) {\n                func.call(thisRef, entry.key);\n            });\n        },\n\n        /**\n         * Gets an array with all keys in the dictionary.\n         */\n        keys: function() {\n            var keys = [];\n            this.forEachKey(function(key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n    });\n\n    /*---------------Queue structure--------------------------------*/\n\n    var Queue = kendo.Class.extend({\n\n        init: function() {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n        },\n\n        /**\n         * Enqueues an object to the end of the queue.\n         */\n        enqueue: function(value) {\n            var entry = { value: value, next: null };\n            if (!this._head) {\n                this._head = entry;\n                this._tail = this._head;\n            }\n            else {\n                this._tail.next = entry;\n                this._tail = this._tail.next;\n            }\n            this.length++;\n        },\n\n        /**\n         * Removes and returns the object at top of the queue.\n         */\n        dequeue: function() {\n            if (this.length < 1) {\n                throw new Error(\"The queue is empty.\");\n            }\n            var value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n        },\n\n        contains: function(item) {\n            var current = this._head;\n            while (current) {\n                if (current.value === item) {\n                    return true;\n                }\n                current = current.next;\n            }\n            return false;\n        }\n    });\n\n\n    /**\n     * While other data structures can have multiple times the same item a Set owns only\n     * once a particular item.\n     * @type {*}\n     */\n    var Set = kendo.Observable.extend({\n        init: function(resource) {\n            var that = this;\n            kendo.Observable.fn.init.call(that);\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (Utils.isDefined(resource)) {\n                if (resource instanceof HashTable) {\n                    resource.forEach(function(d) {\n                        this.add(d);\n                    });\n                }\n                else if (resource instanceof Dictionary) {\n                    resource.forEach(function(k, v) {\n                        this.add({ key: k, value: v });\n                    }, this);\n                }\n            }\n        },\n\n        contains: function(item) {\n            return this._hashTable.containsKey(item);\n        },\n\n        add: function(item) {\n            var entry = this._hashTable.get(item);\n            if (!entry) {\n                this._hashTable.add(item, item);\n                this.length++;\n                this.trigger('changed');\n            }\n        },\n\n        get: function(item) {\n            if (this.contains(item)) {\n                return this._hashTable.get(item).value;\n            }\n            else {\n                return null;\n            }\n        },\n\n        /**\n         * Returns the hash of the item.\n         * @param item\n         * @returns {*}\n         */\n        hash: function(item) {\n            return this._hashTable._hash(item);\n        },\n\n        /**\n         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n         * @param item\n         */\n        remove: function(item) {\n            if (this.contains(item)) {\n                this._hashTable.remove(item);\n                this.length--;\n                this.trigger('changed');\n            }\n        },\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         * @param func\n         */\n        forEach: function(func, context) {\n            this._hashTable.forEach(function(kv) {\n                func(kv.value);\n            }, context);\n        },\n        toArray: function() {\n            var r = [];\n            this.forEach(function(d) {\n                r.push(d);\n            });\n            return r;\n        }\n    });\n\n    /*----------------Node-------------------------------*/\n\n    /**\n     * Defines the node (vertex) of a Graph.\n     */\n    var Node = kendo.Class.extend({\n\n        init: function(id, shape) {\n\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.outgoing = [];\n\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.incoming = [];\n\n            /**\n             * Holds the weight of this Node.\n             */\n            this.weight = 1;\n\n            if (Utils.isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (Utils.isDefined(shape)) {\n                this.associatedShape = shape;\n                // transfer the shape's bounds to the runtime props\n                var b = shape.bounds();\n                this.width = b.width;\n                this.height = b.height;\n                this.x = b.x;\n                this.y = b.y;\n            }\n            else {\n                this.associatedShape = null;\n            }\n            /**\n             * The payload of the node.\n             * @type {null}\n             */\n            this.data = null;\n            this.type = \"Node\";\n            this.shortForm = \"Node '\" + this.id + \"'\";\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             * @type {boolean}\n             */\n            this.isVirtual = false;\n        },\n\n        /**\n         * Returns whether this node has no links attached.\n         */\n        isIsolated: function() {\n            return Utils.isEmpty(this.links);\n        },\n\n        /**\n         * Gets or sets the bounding rectangle of this node.\n         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n         */\n        bounds: function(r) {\n            if (!Utils.isDefined(r)) {\n                return new diagram.Rect(this.x, this.y, this.width, this.height);\n            }\n\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n        },\n\n        /**\n         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n         * incoming or outgoing link.\n         */\n        isLinkedTo: function(node) {\n            var that = this;\n            return Utils.any(that.links, function(link) {\n                return link.getComplement(that) === node;\n            });\n        },\n\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         * @returns {Array}\n         */\n        getChildren: function() {\n            if (this.outgoing.length === 0) {\n                return [];\n            }\n            var children = [];\n            for (var i = 0, len = this.outgoing.length; i < len; i++) {\n                var link = this.outgoing[i];\n                children.push(link.getComplement(this));\n            }\n            return children;\n        },\n\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         * @returns {Array}\n         */\n        getParents: function() {\n            if (this.incoming.length === 0) {\n                return [];\n            }\n            var parents = [];\n            for (var i = 0, len = this.incoming.length; i < len; i++) {\n                var link = this.incoming[i];\n                parents.push(link.getComplement(this));\n            }\n            return parents;\n        },\n\n        /**\n         * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n         * @returns {Node}\n         */\n        clone: function() {\n            var copy = new Node();\n            if (Utils.isDefined(this.weight)) {\n                copy.weight = this.weight;\n            }\n            if (Utils.isDefined(this.balance)) {\n                copy.balance = this.balance;\n            }\n            if (Utils.isDefined(this.owner)) {\n                copy.owner = this.owner;\n            }\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n        },\n\n        /**\n         * Returns whether there is a link from the current node to the given node.\n         */\n        adjacentTo: function(node) {\n            return this.isLinkedTo(node) !== null;\n        },\n\n        /**\n         * Removes the given link from the link collection this node owns.\n         * @param link\n         */\n        removeLink: function(link) {\n            if (link.source === this) {\n                Utils.remove(this.links, link);\n                Utils.remove(this.outgoing, link);\n                link.source = null;\n            }\n\n            if (link.target === this) {\n                Utils.remove(this.links, link);\n                Utils.remove(this.incoming, link);\n                link.target = null;\n            }\n        },\n\n        /**\n         * Returns whether there is a (outgoing) link from the current node to the given one.\n         */\n        hasLinkTo: function(node) {\n            return Utils.any(this.outgoing, function(link) {\n                return link.target === node;\n            });\n        },\n\n        /**\n         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n         */\n        degree: function() {\n            return this.links.length;\n        },\n\n        /**\n         * Returns whether this node is either the source or the target of the given link.\n         */\n        incidentWith: function(link) {\n            return contains(this.links, link);\n        },\n\n        /**\n         * Returns the links between this node and the given one.\n         */\n        getLinksWith: function(node) {\n            return Utils.all(this.links, function(link) {\n                return link.getComplement(this) === node;\n            }, this);\n        },\n\n        /**\n         * Returns the nodes (either parent or child) which are linked to the current one.\n         */\n        getNeighbors: function() {\n            var neighbors = [];\n            Utils.forEach(this.incoming, function(e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            Utils.forEach(this.outgoing, function(e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n        }\n    });\n\n    /**\n     * Defines a directed link (edge, connection) of a Graph.\n     */\n    var Link = kendo.Class.extend({\n\n        init: function(source, target, id, connection) {\n            if (Utils.isUndefined(source)) {\n                throw \"The source of the new link is not set.\";\n            }\n            if (Utils.isUndefined(target)) {\n                throw \"The target of the new link is not set.\";\n            }\n            var sourceFound, targetFound;\n            if (Utils.isString(source)) {\n                sourceFound = new Node(source);\n            }\n            else {\n                sourceFound = source;\n            }\n            if (Utils.isString(target)) {\n                targetFound = new Node(target);\n            }\n            else {\n                targetFound = target;\n            }\n\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n            if (Utils.isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (Utils.isDefined(connection)) {\n                this.associatedConnection = connection;\n            }\n            else {\n                this.associatedConnection = null;\n            }\n            this.type = \"Link\";\n            this.shortForm = \"Link '\" + this.source.id + \"->\" + this.target.id + \"'\";\n        },\n\n        /**\n         * Returns the complementary node of the given one, if any.\n         */\n        getComplement: function(node) {\n            if (this.source !== node && this.target !== node) {\n                throw \"The given node is not incident with this link.\";\n            }\n            return this.source === node ? this.target : this.source;\n        },\n\n        /**\n         * Returns the overlap of the current link with the given one, if any.\n         */\n        getCommonNode: function(link) {\n            if (this.source === link.source || this.source === link.target) {\n                return this.source;\n            }\n            if (this.target === link.source || this.target === link.target) {\n                return this.target;\n            }\n            return null;\n        },\n\n        /**\n         * Returns whether the current link is bridging the given nodes.\n         */\n        isBridging: function(v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n        },\n\n        /**\n         * Returns the source and target of this link as a tuple.\n         */\n        getNodes: function() {\n            return [this.source, this.target];\n        },\n\n        /**\n         * Returns whether the given node is either the source or the target of the current link.\n         */\n        incidentWith: function(node) {\n            return this.source === node || this.target === node;\n        },\n\n        /**\n         * Returns whether the given link is a continuation of the current one. This can be both\n         * via an incoming or outgoing link.\n         */\n        adjacentTo: function(link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n        },\n\n        /**\n         * Changes the source-node of this link.\n         */\n        changeSource: function(node) {\n            Utils.remove(this.source.links, this);\n            Utils.remove(this.source.outgoing, this);\n\n            node.links.push(this);\n            node.outgoing.push(this);\n\n            this.source = node;\n        },\n\n        /**\n         * Changes the target-node of this link.\n         * @param node\n         */\n        changeTarget: function(node) {\n            Utils.remove(this.target.links, this);\n            Utils.remove(this.target.incoming, this);\n\n            node.links.push(this);\n            node.incoming.push(this);\n\n            this.target = node;\n        },\n\n        /**\n         * Changes both the source and the target nodes of this link.\n         */\n        changesNodes: function(v, w) {\n            if (this.source === v) {\n                this.changeSource(w);\n            }\n            else if (this.target === v) {\n                this.changeTarget(w);\n            }\n        },\n\n        /**\n         * Reverses the direction of this link.\n         */\n        reverse: function() {\n            var oldSource = this.source;\n            var oldTarget = this.target;\n\n            this.source = oldTarget;\n            Utils.remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n\n            this.target = oldSource;\n            Utils.remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n        },\n\n        /**\n         * Ensures that the given target defines the endpoint of this link.\n         */\n        directTo: function(target) {\n            if (this.source !== target && this.target !== target) {\n                throw \"The given node is not incident with this link.\";\n            }\n            if (this.target !== target) {\n                this.reverse();\n            }\n        },\n\n        /**\n         * Returns a reversed clone of this link.\n         */\n        createReverseEdge: function() {\n            var r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n        },\n\n        /**\n         * Returns a clone of this link.\n         */\n        clone: function() {\n            var clone = new Link(this.source, this.target);\n            return clone;\n        }\n    });\n\n    /*--------------Graph structure---------------------------------*/\n    /**\n     * Defines a directed graph structure.\n     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n     * inside the Graph.\n     */\n    var Graph = kendo.Class.extend({\n        init: function(idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             * @type {Array}\n             */\n            this.nodes = [];\n\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             * @type {null}\n             */\n            this.diagram = null;\n\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             * @type {null}\n             * @private\n             */\n            this._root = null;\n            if (Utils.isDefined(idOrDiagram)) {\n                if (Utils.isString(idOrDiagram)) {\n                    this.id = idOrDiagram;\n                }\n                else {\n                    this.diagram = idOrDiagram;\n                    this.id = idOrDiagram.id;\n                }\n            }\n            else {\n                this.id = randomId();\n            }\n\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             * @type {Rect}\n             */\n            this.bounds = new Rect();\n            // keeps track whether the children & parents have been created\n            this._hasCachedRelationships = false;\n            this.type = \"Graph\";\n        },\n        /**\n         * Caches the relational information of parents and children in the 'parents' and 'children'\n         * properties.\n         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n         */\n        cacheRelationships: function(forceRebuild) {\n            if (Utils.isUndefined(forceRebuild)) {\n                forceRebuild = false;\n            }\n            if (this._hasCachedRelationships && !forceRebuild) {\n                return;\n            }\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                node.children = this.getChildren(node);\n                node.parents = this.getParents(node);\n            }\n            this._hasCachedRelationships = true;\n        },\n\n        /**\n         * Assigns tree-levels to the nodes assuming this is a tree graph.\n         * If not connected or not a tree the process will succeed but\n         * will have little meaning.\n         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n         * @param visited The collection of visited nodes.\n         * @param offset The offset or starting counter of the level info.\n         */\n        assignLevels: function(startNode, offset, visited) {\n            if (!startNode) {\n                throw \"Start node not specified.\";\n            }\n            if (Utils.isUndefined(offset)) {\n                offset = 0;\n            }\n            // if not done before, cache the parents and children\n            this.cacheRelationships();\n            if (Utils.isUndefined(visited)) {\n                visited = new Dictionary();\n                Utils.forEach(this.nodes, function(n) {\n                    visited.add(n, false);\n                });\n            }\n            visited.set(startNode, true);\n            startNode.level = offset;\n            var children = startNode.children;\n            for (var i = 0, len = children.length; i < len; i++) {\n                var child = children[i];\n                if (!child || visited.get(child)) {\n                    continue;\n                }\n                this.assignLevels(child, offset + 1, visited);\n            }\n        },\n\n        /**\n         * Gets or set the root of this graph.\n         * If not set explicitly the first Node with zero incoming links will be taken.\n         * @param value\n         * @returns {*}\n         */\n        root: function(value) {\n            if (Utils.isUndefined(value)) {\n                if (!this._root) {\n                    // TODO: better to use the longest path for the most probable root?\n                    var found = Utils.first(this.nodes, function(n) {\n                        return n.incoming.length === 0;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    return Utils.first(this.nodes);\n                }\n                else {\n                    return this._root;\n                }\n            }\n            else {\n                this._root = value;\n            }\n        },\n\n        /**\n         * Returns the connected components of this graph.\n         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n         * If you alter the items of the components you'll alter the original graph and vice versa.\n         * @returns {Array}\n         */\n        getConnectedComponents: function() {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            var componentId = Utils.initArray(this.nodes.length, -1);\n\n            for (var v = 0; v < this.nodes.length; v++) {\n                if (componentId[v] === -1) {\n                    this._collectConnectedNodes(componentId, v);\n                    this.componentIndex++;\n                }\n            }\n\n            var components = [], i;\n            for (i = 0; i < this.componentIndex; ++i) {\n                components[i] = new Graph();\n            }\n            for (i = 0; i < componentId.length; ++i) {\n                var graph = components[componentId[i]];\n                graph.addNodeAndOutgoings(this.nodes[i]);\n            }\n            // sorting the components in decreasing order of node count\n            components.sort(function(a, b) {\n                return b.nodes.length - a.nodes.length;\n            });\n            return components;\n        },\n\n        _collectConnectedNodes: function(setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n            var node = this.nodes[nodeIndex];\n            Utils.forEach(node.links,\n                function(link) {\n                    var next = link.getComplement(node);\n                    var nextId = next.index;\n                    if (setIds[nextId] === -1) {\n                        this._collectConnectedNodes(setIds, nextId);\n                    }\n                }, this);\n        },\n\n        /**\n         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n         * @returns {Rect}\n         */\n        calcBounds: function() {\n            if (this.isEmpty()) {\n                this.bounds = new Rect();\n                return this.bounds;\n            }\n            var b = null;\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                if (!b) {\n                    b = node.bounds();\n                }\n                else {\n                    b = b.union(node.bounds());\n                }\n            }\n            this.bounds = b;\n            return this.bounds;\n        },\n\n        /**\n         * Creates a spanning tree for the current graph.\n         * Important: this will not return a spanning forest if the graph is disconnected.\n         * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n         * @param root The root of the spanning tree.\n         * @returns {Graph}\n         */\n        getSpanningTree: function(root) {\n            var tree = new Graph();\n            var map = new Dictionary(), source, target;\n            tree.root = root.clone();\n            tree.root.level = 0;\n            tree.root.id = root.id;\n            map.add(root, tree.root);\n            root.level = 0;\n\n            var visited = [];\n            var remaining = [];\n            tree._addNode(tree.root);\n            visited.push(root);\n            remaining.push(root);\n\n            var levelCount = 1;\n            while (remaining.length > 0) {\n                var next = remaining.pop();\n                for (var ni = 0; ni < next.links.length; ni++) {\n                    var link = next.links[ni];\n                    var cn = link.getComplement(next);\n                    if (contains(visited, cn)) {\n                        continue;\n                    }\n\n                    cn.level = next.level + 1;\n                    if (levelCount < cn.level + 1) {\n                        levelCount = cn.level + 1;\n                    }\n                    if (!contains(remaining, cn)) {\n                        remaining.push(cn);\n                    }\n                    if (!contains(visited, cn)) {\n                        visited.push(cn);\n                    }\n                    if (map.containsKey(next)) {\n                        source = map.get(next);\n                    }\n                    else {\n                        source = next.clone();\n                        source.level = next.level;\n                        source.id = next.id;\n                        map.add(next, source);\n                    }\n                    if (map.containsKey(cn)) {\n                        target = map.get(cn);\n                    }\n                    else {\n                        target = cn.clone();\n                        target.level = cn.level;\n                        target.id = cn.id;\n                        map.add(cn, target);\n                    }\n                    var newLink = new Link(source, target);\n                    tree.addLink(newLink);\n                }\n\n            }\n\n            var treeLevels = [];\n            for (var i = 0; i < levelCount; i++) {\n                treeLevels.push([]);\n            }\n\n            Utils.forEach(tree.nodes, function(node) {\n                treeLevels[node.level].push(node);\n            });\n\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n        },\n\n        /**\n         * Returns a random node in this graph.\n         * @param excludedNodes The collection of nodes which should not be considered.\n         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n         * @returns {*}\n         */\n        takeRandomNode: function(excludedNodes, incidenceLessThan) {\n            if (Utils.isUndefined(excludedNodes)) {\n                excludedNodes = [];\n            }\n            if (Utils.isUndefined(incidenceLessThan)) {\n                incidenceLessThan = 4;\n            }\n            if (this.nodes.length === 0) {\n                return null;\n            }\n            if (this.nodes.length === 1) {\n                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n            var pool = $.grep(this.nodes, function(node) {\n                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n            if (Utils.isEmpty(pool)) {\n                return null;\n            }\n            return pool[Utils.randomInteger(0, pool.length)];\n        },\n\n        /**\n         * Returns whether this is an empty graph.\n         */\n        isEmpty: function() {\n            return Utils.isEmpty(this.nodes);\n        },\n\n        /**\n         * Checks whether the endpoints of the links are all in the nodes collection.\n         */\n        isHealthy: function() {\n            return Utils.all(this.links, function(link) {\n                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n        },\n\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         * @returns {Array}\n         */\n        getParents: function(n) {\n            if (!this.hasNode(n)) {\n                throw \"The given node is not part of this graph.\";\n            }\n            return n.getParents();\n        },\n\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         * @returns {Array}\n         */\n        getChildren: function(n) {\n            if (!this.hasNode(n)) {\n                throw \"The given node is not part of this graph.\";\n            }\n            return n.getChildren();\n        },\n\n        /**\n         * Adds a new link to the graph between the given nodes.\n         */\n        addLink: function(sourceOrLink, target, owner) {\n\n            if (Utils.isUndefined(sourceOrLink)) {\n                throw \"The source of the link is not defined.\";\n            }\n            if (Utils.isUndefined(target)) {\n                // can only be undefined if the first one is a Link\n                if (Utils.isDefined(sourceOrLink.type) && sourceOrLink.type === \"Link\") {\n                    this.addExistingLink(sourceOrLink);\n                    return;\n                }\n                else {\n                    throw \"The target of the link is not defined.\";\n                }\n            }\n\n            var foundSource = this.getNode(sourceOrLink);\n            if (Utils.isUndefined(foundSource)) {\n                foundSource = this.addNode(sourceOrLink);\n            }\n            var foundTarget = this.getNode(target);\n            if (Utils.isUndefined(foundTarget)) {\n                foundTarget = this.addNode(target);\n            }\n\n            var newLink = new Link(foundSource, foundTarget);\n\n            if (Utils.isDefined(owner)) {\n                newLink.owner = owner;\n            }\n\n            /*newLink.source.outgoing.push(newLink);\n             newLink.source.links.push(newLink);\n             newLink.target.incoming.push(newLink);\n             newLink.target.links.push(newLink);*/\n\n            this.links.push(newLink);\n\n            return newLink;\n        },\n\n        /**\n         * Removes all the links in this graph.\n         */\n        removeAllLinks: function() {\n            while (this.links.length > 0) {\n                var link = this.links[0];\n                this.removeLink(link);\n            }\n        },\n\n        /**\n         * Adds the given link to the current graph.\n         */\n        addExistingLink: function(link) {\n\n            if (this.hasLink(link)) {\n                return;\n            }\n            this.links.push(link);\n            if (this.hasNode(link.source.id)) {\n                // priority to the existing node with the id even if other props are different\n                var s = this.getNode(link.source.id);\n                link.changeSource(s);\n            }\n            else {\n                this.addNode(link.source);\n            }\n\n            if (this.hasNode(link.target.id)) {\n                var t = this.getNode(link.target.id);\n                link.changeTarget(t);\n            }\n            else {\n                this.addNode(link.target);\n            }\n\n            /*  if (!link.source.outgoing.contains(link)) {\n             link.source.outgoing.push(link);\n             }\n             if (!link.source.links.contains(link)) {\n             link.source.links.push(link);\n             }\n             if (!link.target.incoming.contains(link)) {\n             link.target.incoming.push(link);\n             }\n             if (!link.target.links.contains(link)) {\n             link.target.links.push(link);\n             }*/\n        },\n\n        /**\n         * Returns whether the given identifier or Link is part of this graph.\n         * @param linkOrId An identifier or a Link object.\n         * @returns {*}\n         */\n        hasLink: function(linkOrId) {\n            if (Utils.isString(linkOrId)) {\n                return Utils.any(this.links, function(link) {\n                    return link.id === linkOrId;\n                });\n            }\n            if (linkOrId.type === \"Link\") {\n                return contains(this.links, linkOrId);\n            }\n            throw \"The given object is neither an identifier nor a Link.\";\n        },\n        /**\n         * Gets the node with the specified Id or null if not part of this graph.\n         */\n        getNode: function(nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n            if (this._nodeMap.containsKey(id)) {\n                return this._nodeMap.get(id);\n            }\n        },\n\n        /**\n         * Returns whether the given node or node Id is part of this graph.\n         */\n        hasNode: function(nodeOrId) {\n            var id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n        },\n\n        _addNode: function(node) {\n            this.nodes.push(node);\n            this._nodeMap.add(node.id, node);\n        },\n\n        _removeNode: function(node) {\n            Utils.remove(this.nodes, node);\n            this._nodeMap.remove(node.id);\n        },\n\n        /**\n         * Removes the given node from this graph.\n         * The node can be specified as an object or as an identifier (string).\n         */\n        removeNode: function(nodeOrId) {\n            var n = nodeOrId;\n            if (Utils.isString(nodeOrId)) {\n                n = this.getNode(nodeOrId);\n            }\n\n            if (Utils.isDefined(n)) {\n                var links = n.links;\n                n.links = [];\n                for (var i = 0, len = links.length; i < len; i++) {\n                    var link = links[i];\n                    this.removeLink(link);\n                }\n                this._removeNode(n);\n            }\n            else {\n                throw \"The identifier should be a Node or the Id (string) of a node.\";\n            }\n        },\n\n        /**\n         * Returns whether the given nodes are connected with a least one link independently of the direction.\n         */\n        areConnected: function(n1, n2) {\n            return Utils.any(this.links, function(link) {\n                return link.source == n1 && link.target == n2 || link.source == n2 && link.target == n1;\n            });\n        },\n\n        /**\n         * Removes the given link from this graph.\n         */\n        removeLink: function(link) {\n            /*    if (!this.links.contains(link)) {\n             throw \"The given link is not part of the Graph.\";\n             }\n             */\n            Utils.remove(this.links, link);\n\n            Utils.remove(link.source.outgoing, link);\n            Utils.remove(link.source.links, link);\n            Utils.remove(link.target.incoming, link);\n            Utils.remove(link.target.links, link);\n        },\n\n        /**\n         * Adds a new node to this graph, if not already present.\n         * The node can be an existing Node or the identifier of a new node.\n         * No error is thrown if the node is already there and the existing one is returned.\n         */\n        addNode: function(nodeOrId, layoutRect, owner) {\n\n            var newNode = null;\n\n            if (!Utils.isDefined(nodeOrId)) {\n                throw \"No Node or identifier for a new Node is given.\";\n            }\n\n            if (Utils.isString(nodeOrId)) {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                newNode = new Node(nodeOrId);\n            }\n            else {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                // todo: ensure that the param is a Node?\n                newNode = nodeOrId;\n            }\n\n            if (Utils.isDefined(layoutRect)) {\n                newNode.bounds(layoutRect);\n            }\n\n            if (Utils.isDefined(owner)) {\n                newNode.owner = owner;\n            }\n            this._addNode(newNode);\n            return newNode;\n        },\n\n        /**\n         * Adds the given Node and its outgoing links.\n         */\n        addNodeAndOutgoings: function(node) {\n            if (!this.hasNode(node)) {\n                this._addNode(node);\n            }\n\n            var newLinks = node.outgoing;\n            node.outgoing = [];\n            Utils.forEach(newLinks, function(link) {\n                this.addExistingLink(link);\n            }, this);\n        },\n\n        /**\n         * Sets the 'index' property on the links and nodes of this graph.\n         */\n        setItemIndices: function() {\n            var i;\n            for (i = 0; i < this.nodes.length; ++i) {\n                this.nodes[i].index = i;\n            }\n\n            for (i = 0; i < this.links.length; ++i) {\n                this.links[i].index = i;\n            }\n        },\n\n        /**\n         * Returns a clone of this graph.\n         */\n        clone: function(saveMapping) {\n            var copy = new Graph();\n            var save = Utils.isDefined(saveMapping) && saveMapping === true;\n            if (save) {\n                copy.nodeMap = new Dictionary();\n                copy.linkMap = new Dictionary();\n            }\n            // we need a map even if the saveMapping is not set\n            var map = new Dictionary();\n            Utils.forEach(this.nodes, function(nOriginal) {\n                var nCopy = nOriginal.clone();\n                map.set(nOriginal, nCopy);\n                copy._addNode(nCopy);\n\n                if (save) {\n                    copy.nodeMap.set(nCopy, nOriginal);\n                }\n            });\n\n            Utils.forEach(this.links, function(linkOriginal) {\n                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                    var linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                    if (save) {\n                        copy.linkMap.set(linkCopy, linkOriginal);\n                    }\n                }\n            });\n\n            return copy;\n        },\n\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        linearize: function(addIds) {\n            return Graph.Utils.linearize(this, addIds);\n        },\n\n        /**\n         * Performs a depth-first traversal starting at the given node.\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        depthFirstTraversal: function(startNode, action) {\n            if (Utils.isUndefined(startNode)) {\n                throw \"You need to supply a starting node.\";\n            }\n            if (Utils.isUndefined(action)) {\n                throw \"You need to supply an action.\";\n            }\n            if (!this.hasNode(startNode)) {\n                throw \"The given start-node is not part of this graph\";\n            }\n            var foundNode = this.getNode(startNode);// case the given one is an Id\n            var visited = [];\n            this._dftIterator(foundNode, action, visited);\n        },\n\n        _dftIterator: function(node, action, visited) {\n\n            action(node);\n            visited.push(node);\n            var children = node.getChildren();\n            for (var i = 0, len = children.length; i < len; i++) {\n                var child = children[i];\n                if (contains(visited, child)) {\n                    continue;\n                }\n                this._dftIterator(child, action, visited);\n            }\n        },\n\n        /**\n         * Performs a breadth-first traversal starting at the given node.\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        breadthFirstTraversal: function(startNode, action) {\n\n            if (Utils.isUndefined(startNode)) {\n                throw \"You need to supply a starting node.\";\n            }\n            if (Utils.isUndefined(action)) {\n                throw \"You need to supply an action.\";\n            }\n\n            if (!this.hasNode(startNode)) {\n                throw \"The given start-node is not part of this graph\";\n            }\n            var foundNode = this.getNode(startNode);// case the given one is an Id\n            var queue = new Queue();\n            var visited = [];\n            queue.enqueue(foundNode);\n\n            while (queue.length > 0) {\n                var node = queue.dequeue();\n                action(node);\n                visited.push(node);\n                var children = node.getChildren();\n                for (var i = 0, len = children.length; i < len; i++) {\n                    var child = children[i];\n                    if (contains(visited, child) || contains(queue, child)) {\n                        continue;\n                    }\n                    queue.enqueue(child);\n                }\n            }\n        },\n\n        /**\n         * This is the classic Tarjan algorithm for strongly connected components.\n         * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n         * @param node The start node from which the analysis starts.\n         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n         * @param connected The current component.\n         * @param stack The bookkeeping stack of things to visit.\n         * @param index The counter of visited nodes used to assign the indices.\n         * @private\n         */\n        _stronglyConnectedComponents: function(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n\n            stack.push(node);\n\n            var children = node.getChildren(), next;\n            for (var i = 0, len = children.length; i < len; i++) {\n                next = children[i];\n                if (!indices.containsKey(next)) {\n                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                }\n                else if (contains(stack, next)) {\n                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                }\n            }\n            // If v is a root node, pop the stack and generate a strong component\n            if (lowLinks.get(node) === indices.get(node)) {\n                var component = [];\n                do {\n                    next = stack.pop();\n                    component.push(next);\n                }\n                while (next !== node);\n                if (!excludeSingleItems || (component.length > 1)) {\n                    connected.push(component);\n                }\n            }\n        },\n\n        /**\n         * Returns the cycles found in this graph.\n         * The returned arrays consist of the nodes which are strongly coupled.\n         * @param excludeSingleItems Whether isolated nodes should be excluded.\n         * @returns {Array} The array of cycles found.\n         */\n        findCycles: function(excludeSingleItems) {\n            if (Utils.isUndefined(excludeSingleItems)) {\n                excludeSingleItems = true;\n            }\n            var indices = new Dictionary();\n            var lowLinks = new Dictionary();\n            var connected = [];\n            var stack = [];\n            for (var i = 0, len = this.nodes.length; i < len; i++) {\n                var node = this.nodes[i];\n                if (indices.containsKey(node)) {\n                    continue;\n                }\n                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n            return connected;\n        },\n\n        /**\n         * Returns whether this graph is acyclic.\n         * @returns {*}\n         */\n        isAcyclic: function() {\n            return Utils.isEmpty(this.findCycles());\n        },\n\n        /**\n         * Returns whether the given graph is a subgraph of this one.\n         * @param other Another graph instance.\n         */\n        isSubGraph: function(other) {\n            var otherArray = other.linearize();\n            var thisArray = this.linearize();\n            return Utils.all(otherArray, function(s) {\n                return contains(thisArray, s);\n            });\n        },\n\n        /**\n         *  Makes an acyclic graph from the current (connected) one.\n         * * @returns {Array} The reversed links.\n         */\n        makeAcyclic: function() {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                return [];\n            }\n            // singular case of just two nodes\n            if (this.nodes.length == 2) {\n                var result = [];\n                if (this.links.length > 1) {\n                    var oneLink = this.links[0];\n                    var oneNode = oneLink.source;\n                    for (var i = 0, len = this.links.length; i < len; i++) {\n                        var link = this.links[i];\n                        if (link.source == oneNode) {\n                            continue;\n                        }\n                        var rev = link.reverse();\n                        result.push(rev);\n                    }\n                }\n                return result;\n            }\n\n            var copy = this.clone(true); // copy.nodeMap tells you the mapping\n            var N = this.nodes.length;\n\n            var intensityCatalog = new Dictionary();\n\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             * @param node\n             * @returns {number}\n             */\n            var flowIntensity = function(node) {\n                if (node.outgoing.length === 0) {\n                    return (2 - N);\n                }\n                else if (node.incoming.length === 0) {\n                    return (N - 2);\n                }\n                else {\n                    return node.outgoing.length - node.incoming.length;\n                }\n            };\n\n            /**\n             * Collects the nodes with the same intensity.\n             * @param node\n             * @param intensityCatalog\n             */\n            var catalogEqualIntensity = function(node, intensityCatalog) {\n                var intensity = flowIntensity(node, N);\n                if (!intensityCatalog.containsKey(intensity)) {\n                    intensityCatalog.set(intensity, []);\n                }\n                intensityCatalog.get(intensity).push(node);\n            };\n\n            Utils.forEach(copy.nodes, function(v) {\n                catalogEqualIntensity(v, intensityCatalog);\n            });\n\n            var sourceStack = [];\n            var targetStack = [];\n\n            while (copy.nodes.length > 0) {\n                var source, target, intensity;\n                if (intensityCatalog.containsKey(2 - N)) {\n                    var targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                    while (targets.length > 0) {\n                        target = targets.pop();\n                        for (var li = 0; li < target.links.length; li++) {\n                            var targetLink = target.links[li];\n                            source = targetLink.getComplement(target);\n                            intensity = flowIntensity(source, N);\n                            Utils.remove(intensityCatalog.get(intensity), source);\n                            source.removeLink(targetLink);\n                            catalogEqualIntensity(source, intensityCatalog);\n                        }\n                        copy._removeNode(target);\n                        targetStack.unshift(target);\n                    }\n                }\n\n                // move sources to sourceStack\n                if (intensityCatalog.containsKey(N - 2)) {\n                    var sources = intensityCatalog.get(N - 2); // nodes without incomings\n                    while (sources.length > 0) {\n                        source = sources.pop();\n                        for (var si = 0; si < source.links.length; si++) {\n                            var sourceLink = source.links[si];\n                            target = sourceLink.getComplement(source);\n                            intensity = flowIntensity(target, N);\n                            Utils.remove(intensityCatalog.get(intensity), target);\n                            target.removeLink(sourceLink);\n                            catalogEqualIntensity(target, intensityCatalog);\n                        }\n                        sourceStack.push(source);\n                        copy._removeNode(source);\n                    }\n                }\n\n                if (copy.nodes.length > 0) {\n                    for (var k = N - 3; k > 2 - N; k--) {\n                        if (intensityCatalog.containsKey(k) &&\n                            intensityCatalog.get(k).length > 0) {\n                            var maxdiff = intensityCatalog.get(k);\n                            var v = maxdiff.pop();\n                            for (var ri = 0; ri < v.links.length; ri++) {\n                                var ril = v.links[ri];\n                                var u = ril.getComplement(v);\n                                intensity = flowIntensity(u, N);\n                                Utils.remove(intensityCatalog.get(intensity), u);\n                                u.removeLink(ril);\n                                catalogEqualIntensity(u, intensityCatalog);\n                            }\n                            sourceStack.push(v);\n                            copy._removeNode(v);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            sourceStack = sourceStack.concat(targetStack);\n\n            var vertexOrder = new Dictionary();\n            for (var kk = 0; kk < this.nodes.length; kk++) {\n                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n\n            var reversedEdges = [];\n            Utils.forEach(this.links, function(link) {\n                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                    link.reverse();\n                    reversedEdges.push(link);\n                }\n            });\n            return reversedEdges;\n        }\n    });\n\n    /**\n     * A collection of predefined graphs for demo and testing purposes.\n     */\n    Graph.Predefined = {\n        /**\n         * Eight-shapes graph all connected in a cycle.\n         * @returns {*}\n         * @constructor\n         */\n        EightGraph: function() {\n            return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->4\", \"4->1\", \"3->5\", \"5->6\", \"6->7\", \"7->3\"]);\n        },\n\n        /**\n         * Creates a typical mindmap diagram.\n         * @returns {*}\n         * @constructor\n         */\n        Mindmap: function() {\n            return Graph.Utils.parse([\"0->1\", \"0->2\", \"0->3\", \"0->4\", \"0->5\", \"1->6\", \"1->7\", \"7->8\", \"2->9\", \"9->10\", \"9->11\", \"3->12\",\n                \"12->13\", \"13->14\", \"4->15\", \"4->16\", \"15->17\", \"15->18\", \"18->19\", \"18->20\", \"14->21\", \"14->22\", \"5->23\", \"23->24\", \"23->25\", \"6->26\"]);\n        },\n\n        /**\n         * Three nodes connected in a cycle.\n         * @returns {*}\n         * @constructor\n         */\n        ThreeGraph: function() {\n            return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->1\"]);\n        },\n\n        /**\n         * A tree with each node having two children.\n         * @param levels How many levels the binary tree should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        BinaryTree: function(levels) {\n            if (Utils.isUndefined(levels)) {\n                levels = 5;\n            }\n            return Graph.Utils.createBalancedTree(levels, 2);\n        },\n\n        /**\n         * A linear graph (discrete line segment).\n         * @param length How many segments (the node count is hence (length+1)).\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Linear: function(length) {\n            if (Utils.isUndefined(length)) {\n                length = 10;\n            }\n            return Graph.Utils.createBalancedTree(length, 1);\n        },\n\n        /**\n         * A standard tree-graph with the specified levels and children (siblings) count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         *  - NodeCount = (1-s^(N+1))/(1-s)]\n         *  - LinkCount = s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Tree: function(levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n        },\n\n        /**\n         * Creates a forest.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n         *  - LinkCount = t.s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @param trees The amount of trees the forest should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Forest: function(levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n        },\n\n        /**\n         * A workflow-like graph with cycles.\n         * @returns {*}\n         * @constructor\n         */\n        Workflow: function() {\n            return Graph.Utils.parse(\n                [\"0->1\", \"1->2\", \"2->3\", \"1->4\", \"4->3\", \"3->5\", \"5->6\", \"6->3\", \"6->7\", \"5->4\"]\n            );\n        },\n\n        /**\n         * A grid graph with the direction of the links avoiding cycles.\n         * Node count: (n+1).(m+1)\n         * Link count: n.(m+1) + m.(n+1)\n         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n         * @constructor\n         */\n        Grid: function(n, m) {\n            var g = new diagram.Graph();\n            if (n <= 0 && m <= 0) {\n                return g;\n            }\n\n            for (var i = 0; i < n + 1; i++) {\n                var previous = null;\n                for (var j = 0; j < m + 1; j++) {\n                    // using x-y coordinates to name the nodes\n                    var node = new Node(i.toString() + \".\" + j.toString());\n                    g.addNode(node);\n                    if (previous) {\n                        g.addLink(previous, node);\n                    }\n                    if (i > 0) {\n                        var left = g.getNode((i - 1).toString() + \".\" + j.toString());\n                        g.addLink(left, node);\n                    }\n                    previous = node;\n                }\n            }\n            return g;\n        }\n\n    };\n\n    /**\n     * Graph generation and other utilities.\n     */\n    Graph.Utils = {\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        parse: function(graphString) {\n\n            var previousLink, graph = new diagram.Graph(), parts = graphString.slice();\n            for (var i = 0, len = parts.length; i < len; i++) {\n                var part = parts[i];\n                if (Utils.isString(part)) // link spec\n                {\n                    if (part.indexOf(\"->\") < 0) {\n                        throw \"The link should be specified as 'a->b'.\";\n                    }\n                    var p = part.split(\"->\");\n                    if (p.length != 2) {\n                        throw \"The link should be specified as 'a->b'.\";\n                    }\n                    previousLink = new Link(p[0], p[1]);\n                    graph.addLink(previousLink);\n                }\n                if (Utils.isObject(part)) {\n                    if (!previousLink) {\n                        throw \"Specification found before Link definition.\";\n                    }\n                    kendo.deepExtend(previousLink, part);\n                }\n            }\n            return graph;\n        },\n\n        /**\n         * Returns a linearized representation of the given Graph.\n         * See also the Graph.Utils.parse method for the inverse operation.\n         */\n        linearize: function(graph, addIds) {\n            if (Utils.isUndefined(graph)) {\n                throw \"Expected an instance of a Graph object in slot one.\";\n            }\n            if (Utils.isUndefined(addIds)) {\n                addIds = false;\n            }\n            var lin = [];\n            for (var i = 0, len = graph.links.length; i < len; i++) {\n                var link = graph.links[i];\n                lin.push(link.source.id + \"->\" + link.target.id);\n                if (addIds) {\n                    lin.push({ id: link.id });\n                }\n            }\n            return lin;\n        },\n\n        /**\n         * The method used by the diagram creation to instantiate a shape.\n         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n         * @param p The position at which to place the shape.\n         * @param shapeDefaults Optional Shape options.\n         * @param id Optional identifier of the shape.\n         * @returns {*}\n         * @private\n         */\n        _addShape: function(kendoDiagram, p, id, shapeDefaults) {\n            if (Utils.isUndefined(p)) {\n                p = new ExtendedPoint(0, 0);\n            }\n\n            if (Utils.isUndefined(id)) {\n                id = randomId();\n            }\n\n            shapeDefaults = kendo.deepExtend({\n                width: 20,\n                height: 20,\n                id: id,\n                radius: 10,\n                fill: \"#778899\",\n                data: \"circle\",\n                undoable: false,\n                x: p.x,\n                y: p.y\n            }, shapeDefaults);\n\n            return kendoDiagram.addShape(shapeDefaults);\n        },\n        /**\n         * The method used by the diagram creation to instantiate a connection.\n         * @param diagram he Kendo diagram where the diagram will be created.\n         * @param from The source shape.\n         * @param to The target shape.\n         * @param options Optional Connection options.\n         * @returns {*}\n         * @private\n         */\n        _addConnection: function(diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n        },\n\n        /**\n         * Creates a diagram from the given Graph.\n         * @param diagram The Kendo diagram where the diagram will be created.\n         * @param graph The graph structure defining the diagram.\n         */\n        createDiagramFromGraph: function(diagram, graph, doLayout, randomSize) {\n\n            if (Utils.isUndefined(diagram)) {\n                throw \"The diagram surface is undefined.\";\n            }\n            if (Utils.isUndefined(graph)) {\n                throw \"No graph specification defined.\";\n            }\n            if (Utils.isUndefined(doLayout)) {\n                doLayout = true;\n            }\n            if (Utils.isUndefined(randomSize)) {\n                randomSize = false;\n            }\n\n            var width = diagram.element.clientWidth || 200;\n            var height = diagram.element.clientHeight || 200;\n            var map = [], node, shape;\n            for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                node = graph.nodes[i];\n                var p = node.position;\n                if (Utils.isUndefined(p)) {\n                    if (Utils.isDefined(node.x) && Utils.isDefined(node.y)) {\n                        p = new ExtendedPoint(node.x, node.y);\n                    }\n                    else {\n                        p = new ExtendedPoint(Utils.randomInteger(10, width - 20), Utils.randomInteger(10, height - 20));\n                    }\n                }\n                var opt = {};\n\n                if (node.id === \"0\") {\n                    /* kendo.deepExtend(opt,\n                     {\n                     fill: \"Orange\",\n                     data: 'circle',\n                     width: 100,\n                     height: 100,\n                     center: new Point(50, 50)\n                     });*/\n                }\n                else if (randomSize) {\n                    kendo.deepExtend(opt, {\n                        width: Math.random() * 150 + 20,\n                        height: Math.random() * 80 + 50,\n                        data: 'rectangle',\n                        fill: {\n                            color: \"#778899\"\n                        }\n                    });\n                }\n\n                shape = this._addShape(diagram, p, node.id, opt);\n                //shape.content(node.id);\n\n                var bounds = shape.bounds();\n                if (Utils.isDefined(bounds)) {\n                    node.x = bounds.x;\n                    node.y = bounds.y;\n                    node.width = bounds.width;\n                    node.height = bounds.height;\n                }\n                map[node.id] = shape;\n            }\n            for (var gli = 0; gli < graph.links.length; gli++) {\n                var link = graph.links[gli];\n                var sourceShape = map[link.source.id];\n                if (Utils.isUndefined(sourceShape)) {\n                    continue;\n                }\n                var targetShape = map[link.target.id];\n                if (Utils.isUndefined(targetShape)) {\n                    continue;\n                }\n                this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n\n            }\n            if (doLayout) {\n                var l = new diagram.SpringLayout(diagram);\n                l.layoutGraph(graph, { limitToView: false });\n                for (var shi = 0; shi < graph.nodes.length; shi++) {\n                    node = graph.nodes[shi];\n                    shape = map[node.id];\n                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                }\n            }\n        },\n\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         *  - NodeCount = (1-s^(N+1))/(1-s)]\n         *  - LinkCount = s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         */\n        createBalancedTree: function(levels, siblingsCount) {\n            if (Utils.isUndefined(levels)) {\n                levels = 3;\n            }\n            if (Utils.isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n\n            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0) {\n                return g;\n            }\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n            g.root = root;\n            lastAdded.push(root);\n            for (var i = 0; i < levels; i++) {\n                news = [];\n                for (var j = 0; j < lastAdded.length; j++) {\n                    var parent = lastAdded[j];\n                    for (var k = 0; k < siblingsCount; k++) {\n                        var item = new Node((++counter).toString());\n                        g.addLink(parent, item);\n                        news.push(item);\n                    }\n                }\n                lastAdded = news;\n            }\n            return g;\n        },\n\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n         *  - LinkCount = t.s.(1-s^N)/(1-s)\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @param treeCount The number of trees the forest should have.\n         */\n        createBalancedForest: function(levels, siblingsCount, treeCount) {\n            if (Utils.isUndefined(levels)) {\n                levels = 3;\n            }\n            if (Utils.isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            if (Utils.isUndefined(treeCount)) {\n                treeCount = 5;\n            }\n            var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                return g;\n            }\n\n            for (var t = 0; t < treeCount; t++) {\n                var root = new Node((++counter).toString());\n                g.addNode(root);\n                lastAdded = [root];\n                for (var i = 0; i < levels; i++) {\n                    news = [];\n                    for (var j = 0; j < lastAdded.length; j++) {\n                        var parent = lastAdded[j];\n                        for (var k = 0; k < siblingsCount; k++) {\n                            var item = new Node((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n            }\n            return g;\n        },\n\n        /**\n         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n         * @param nodeCount The amount of nodes the random graph should have.\n         * @param maxIncidence The maximum allowed degree of the nodes.\n         * @param isTree Whether the return graph should be a tree (default: false).\n         * @returns {diagram.Graph}\n         */\n        createRandomConnectedGraph: function(nodeCount, maxIncidence, isTree) {\n\n            /* Swa's Mathematica export of random Bernoulli graphs\n             gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n             While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n             project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n             export[g_]:=project/@ EdgeList[g]\n             g = gr[12,.1]\n             export [g]\n             */\n\n            if (Utils.isUndefined(nodeCount)) {\n                nodeCount = 40;\n            }\n            if (Utils.isUndefined(maxIncidence)) {\n                maxIncidence = 4;\n            }\n            if (Utils.isUndefined(isTree)) {\n                isTree = false;\n            }\n\n            var g = new diagram.Graph(), counter = -1;\n            if (nodeCount <= 0) {\n                return g;\n            }\n\n            var root = new Node((++counter).toString());\n            g.addNode(root);\n            if (nodeCount === 1) {\n                return g;\n            }\n            if (nodeCount > 1) {\n                // random tree\n                for (var i = 1; i < nodeCount; i++) {\n                    var poolNode = g.takeRandomNode([], maxIncidence);\n                    if (!poolNode) {\n                        //failed to find one so the graph will have less nodes than specified\n                        break;\n                    }\n                    var newNode = g.addNode(i.toString());\n                    g.addLink(poolNode, newNode);\n                }\n                if (!isTree && nodeCount > 1) {\n                    var randomAdditions = Utils.randomInteger(1, nodeCount);\n                    for (var ri = 0; ri < randomAdditions; ri++) {\n                        var n1 = g.takeRandomNode([], maxIncidence);\n                        var n2 = g.takeRandomNode([], maxIncidence);\n                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n                            g.addLink(n1, n2);\n                        }\n                    }\n                }\n                return g;\n            }\n        },\n\n        /**\n         * Generates a random diagram.\n         * @param diagram The host diagram.\n         * @param shapeCount The number of shapes the random diagram should contain.\n         * @param maxIncidence The maximum degree the shapes can have.\n         * @param isTree Whether the generated diagram should be a tree\n         * @param layoutType The optional layout type to apply after the diagram is generated.\n         */\n        randomDiagram: function(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            var g = kendo.dataviz.diagram.Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n        }\n    };\n\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n\n        Point: ExtendedPoint,\n        Intersect: Intersect,\n        Geometry: Geometry,\n        Rect: Rect,\n        Size: Size,\n        RectAlign: RectAlign,\n        Matrix: Matrix,\n        MatrixVector: MatrixVector,\n        normalVariable: normalVariable,\n        randomId: randomId,\n        Dictionary: Dictionary,\n        HashTable: HashTable,\n        Queue: Queue,\n        Set: Set,\n        Node: Node,\n        Link: Link,\n        Graph: Graph,\n        PathDefiner: PathDefiner\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    // Imports ================================================================\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Class = kendo.Class,\n        deepExtend = kendo.deepExtend,\n        Point = diagram.Point,\n        Rect = diagram.Rect,\n        Matrix = diagram.Matrix,\n        Utils = diagram.Utils,\n        isNumber = Utils.isNumber,\n        isString = Utils.isString,\n        MatrixVector = diagram.MatrixVector,\n\n        g = kendo.geometry,\n        d = kendo.drawing,\n\n        defined = d.util.defined,\n\n        inArray = $.inArray;\n\n    // Constants ==============================================================\n    var TRANSPARENT = \"transparent\",\n        Markers = {\n            none: \"none\",\n            arrowStart: \"ArrowStart\",\n            filledCircle: \"FilledCircle\",\n            arrowEnd: \"ArrowEnd\"\n        },\n        FULL_CIRCLE_ANGLE = 360,\n        START = \"start\",\n        END = \"end\",\n        WIDTH = \"width\",\n        HEIGHT = \"height\",\n        X = \"x\",\n        Y = \"y\";\n\n    diagram.Markers = Markers;\n\n    function diffNumericOptions(options, fields) {\n        var elementOptions = this.options;\n        var hasChanges = false;\n        var value, field;\n        for (var i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n            if (isNumber(value) && elementOptions[field] !== value) {\n                elementOptions[field] = value;\n                hasChanges = true;\n            }\n        }\n\n        return hasChanges;\n    }\n\n    var Scale = Class.extend({\n        init: function(x, y) {\n            this.x = x;\n            this.y = y;\n        },\n        toMatrix: function() {\n            return Matrix.scaling(this.x, this.y);\n        },\n        toString: function() {\n            return kendo.format(\"scale({0},{1})\", this.x, this.y);\n        },\n        invert: function() {\n            return new Scale(1 / this.x, 1 / this.y);\n        }\n    });\n\n    var Translation = Class.extend({\n        init: function(x, y) {\n            this.x = x;\n            this.y = y;\n        },\n        toMatrixVector: function() {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n        },\n        toMatrix: function() {\n            return Matrix.translation(this.x, this.y);\n        },\n        toString: function() {\n            return kendo.format(\"translate({0},{1})\", this.x, this.y);\n        },\n        plus: function(delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n        },\n        times: function(factor) {\n            this.x *= factor;\n            this.y *= factor;\n        },\n        length: function() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n        normalize: function() {\n            if (this.Length === 0) {\n                return;\n            }\n            this.times(1 / this.length());\n        },\n        invert: function() {\n            return new Translation(-this.x, -this.y);\n        }\n    });\n\n    var Rotation = Class.extend({\n        init: function(angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n        },\n        toString: function() {\n            if (this.x && this.y) {\n                return kendo.format(\"rotate({0},{1},{2})\", this.angle, this.x, this.y);\n            } else {\n                return kendo.format(\"rotate({0})\", this.angle);\n            }\n        },\n        toMatrix: function() {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n        },\n        center: function() {\n            return new Point(this.x, this.y);\n        },\n        invert: function() {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n        }\n    });\n\n    Rotation.ZERO = new Rotation(0);\n\n    Rotation.create = function(rotation) {\n        return new Rotation(rotation.angle, rotation.x, rotation.y);\n    };\n\n    Rotation.parse = function(str) {\n        var values = str.slice(1, str.length - 1).split(\",\"),\n            angle = values[0],\n            x = values[1],\n            y = values[2];\n        var rotation = new Rotation(angle, x, y);\n        return rotation;\n    };\n\n    var CompositeTransform = Class.extend({\n        init: function(x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n            if (scaleX !== undefined$1 && scaleY !== undefined$1) {\n                this.scale = new Scale(scaleX, scaleY);\n            }\n            if (angle !== undefined$1) {\n                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n        },\n        toString: function() {\n            var toString = function(transform) {\n                return transform ? transform.toString() : \"\";\n            };\n\n            return toString(this.translate) +\n                toString(this.rotate) +\n                toString(this.scale);\n        },\n\n        render: function(visual) {\n            visual._transform = this;\n            visual._renderTransform();\n        },\n\n        toMatrix: function() {\n            var m = Matrix.unit();\n\n            if (this.translate) {\n                m = m.times(this.translate.toMatrix());\n            }\n            if (this.rotate) {\n                m = m.times(this.rotate.toMatrix());\n            }\n            if (this.scale) {\n                m = m.times(this.scale.toMatrix());\n            }\n            return m;\n        },\n        invert: function() {\n            var rotate = this.rotate ? this.rotate.invert() : undefined$1,\n                rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(),\n                scale = this.scale ? this.scale.invert() : undefined$1,\n                scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n\n            var translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            var translate = new Translation(translatePoint.x, translatePoint.y);\n\n            var transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n\n            return transform;\n        }\n    });\n\n    var AutoSizeableMixin = {\n        _setScale: function() {\n            var options = this.options;\n            var originWidth = this._originWidth;\n            var originHeight = this._originHeight;\n            var scaleX = options.width / originWidth;\n            var scaleY = options.height / originHeight;\n\n            if (!isNumber(scaleX)) {\n                scaleX = 1;\n            }\n            if (!isNumber(scaleY)) {\n                scaleY = 1;\n            }\n\n            this._transform.scale = new Scale(scaleX, scaleY);\n        },\n\n        _setTranslate: function() {\n            var options = this.options;\n            var x = options.x || 0;\n            var y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n        },\n\n        _initSize: function() {\n            var options = this.options;\n            var transform = false;\n            if (options.autoSize !== false && (defined(options.width) || defined(options.height))) {\n                this._measure(true);\n                this._setScale();\n                transform = true;\n            }\n\n            if (defined(options.x) || defined(options.y)) {\n                this._setTranslate();\n                transform = true;\n            }\n\n            if (transform) {\n                this._renderTransform();\n            }\n        },\n\n        _updateSize: function(options) {\n            var update = false;\n\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                update = true;\n                this._measure(true);\n                this._setScale();\n            }\n\n            if (this._diffNumericOptions(options, [X, Y])) {\n                update = true;\n                this._setTranslate();\n            }\n\n            if (update) {\n                this._renderTransform();\n            }\n\n            return update;\n        }\n    };\n\n    var Element = Class.extend({\n        init: function(options) {\n            var element = this;\n            element.options = deepExtend({}, element.options, options);\n            element.id = element.options.id;\n            element._originSize = Rect.empty();\n            element._transform = new CompositeTransform();\n        },\n\n        visible: function(value) {\n            return this.drawingContainer().visible(value);\n        },\n\n        redraw: function(options) {\n            if (options && options.id) {\n                 this.id = options.id;\n            }\n        },\n\n        position: function(x, y) {\n            var options = this.options;\n            if (!defined(x)) {\n               return new Point(options.x, options.y);\n            }\n\n            if (defined(y)) {\n                options.x = x;\n                options.y = y;\n            } else if (x instanceof Point) {\n                options.x = x.x;\n                options.y = x.y;\n            }\n\n            this._transform.translate = new Translation(options.x, options.y);\n            this._renderTransform();\n        },\n\n        rotate: function(angle, center) {\n            if (defined(angle)) {\n                this._transform.rotate = new Rotation(angle, center.x, center.y);\n                this._renderTransform();\n            }\n            return this._transform.rotate || Rotation.ZERO;\n        },\n\n        drawingContainer: function() {\n            return this.drawingElement;\n        },\n\n        _renderTransform: function() {\n            var matrix = this._transform.toMatrix();\n            this.drawingContainer().transform(new g.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n        },\n\n        _hover: function() {},\n\n        _diffNumericOptions: diffNumericOptions,\n\n        _measure: function(force) {\n            var rect;\n            if (!this._measured || force) {\n                var box = this._boundingBox() || new g.Rect();\n                var startPoint = box.topLeft();\n                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                this._originSize = rect;\n                this._originWidth = rect.width;\n                this._originHeight = rect.height;\n                this._measured = true;\n            } else {\n                rect = this._originSize;\n            }\n            return rect;\n        },\n\n        _boundingBox: function() {\n            return this.drawingElement.rawBBox();\n        }\n    });\n\n    var VisualBase = Element.extend({\n        init: function(options) {\n            Element.fn.init.call(this, options);\n\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n        },\n\n        options: {\n            stroke: {\n                color: \"gray\",\n                width: 1\n            },\n            fill: {\n                color: TRANSPARENT\n            }\n        },\n\n        fill: function(color, opacity) {\n            this._fill({\n                color: getColor(color),\n                opacity: opacity\n            });\n        },\n\n        stroke: function(color, width, opacity) {\n            this._stroke({\n                color: getColor(color),\n                width: width,\n                opacity: opacity\n            });\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var stroke = options.stroke;\n                var fill = options.fill;\n                if (stroke) {\n                    this._stroke(normalizeDrawingOptions(stroke));\n                }\n                if (fill) {\n                    this._fill(normalizeDrawingOptions(fill));\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _hover: function(show) {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var hover = options.hover;\n\n            if (hover && hover.fill) {\n                var fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                drawingElement.fill(fill.color, fill.opacity);\n            }\n        },\n\n        _stroke: function(strokeOptions) {\n            var options = this.options;\n            deepExtend(options, {\n                stroke: strokeOptions\n            });\n\n            strokeOptions = options.stroke;\n\n            var stroke = null;\n            if (strokeOptions.width > 0) {\n                stroke = {\n                    color: strokeOptions.color,\n                    width: strokeOptions.width,\n                    opacity: strokeOptions.opacity,\n                    dashType: strokeOptions.dashType\n                };\n            }\n\n            this.drawingElement.options.set(\"stroke\", stroke);\n        },\n\n        _fill: function(fillOptions) {\n            var options = this.options;\n            deepExtend(options, {\n                fill: fillOptions || {}\n            });\n            var fill = options.fill;\n\n            if (fill.gradient) {\n                var gradient = fill.gradient;\n                var GradientClass = (gradient.type === \"radial\" ? d.RadialGradient : d.LinearGradient);\n                this.drawingElement.fill(new GradientClass(gradient));\n            } else {\n                this.drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n    });\n\n    var TextBlock = VisualBase.extend({\n        init: function(options) {\n            options = this._textColor(options);\n            VisualBase.fn.init.call(this, options);\n\n            this._font();\n            this._initText();\n            this._initSize();\n        },\n\n        options: {\n            fontSize: 15,\n            fontFamily: \"sans-serif\",\n            stroke: {\n                width: 0\n            },\n            fill: {\n                color: \"black\"\n            },\n            autoSize: true\n        },\n\n        _initText: function() {\n            var options = this.options;\n\n            this.drawingElement = new d.Text(defined(options.text) ? options.text : \"\", new g.Point(), {\n                font: options.font\n            });\n\n            this._fill();\n            this._stroke();\n        },\n\n        _textColor: function(options) {\n            if (options && options.color) {\n                options = deepExtend({}, options, {\n                    fill: {\n                        color: options.color\n                    }\n                });\n            }\n            return options;\n        },\n\n        _font: function() {\n            var options = this.options;\n            if (options.fontFamily && defined(options.fontSize)) {\n                var fontOptions = [];\n\n                if (options.fontStyle) {\n                    fontOptions.push(options.fontStyle);\n                }\n\n                if (options.fontWeight) {\n                    fontOptions.push(options.fontWeight);\n                }\n\n                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? \"px\" : \"\"));\n                fontOptions.push(options.fontFamily);\n\n                options.font = fontOptions.join(\" \");\n            } else {\n                delete options.font;\n            }\n        },\n\n        content: function(text) {\n            return this.drawingElement.content(text);\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var sizeChanged = false;\n                var textOptions = this.options;\n\n                options = this._textColor(options);\n\n                VisualBase.fn.redraw.call(this, options);\n\n                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                    deepExtend(textOptions, {\n                        fontFamily: options.fontFamily,\n                        fontSize: options.fontSize,\n                        fontStyle: options.fontStyle,\n                        fontWeight: options.fontWeight\n                    });\n                    this._font();\n                    this.drawingElement.options.set(\"font\", textOptions.font);\n                    sizeChanged = true;\n                }\n\n                if (options.text) {\n                    this.content(options.text);\n                    sizeChanged = true;\n                }\n\n                if (!this._updateSize(options) && sizeChanged) {\n                    this._initSize();\n                }\n            }\n        }\n    });\n\n    deepExtend(TextBlock.fn, AutoSizeableMixin);\n\n    var Rectangle = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this._initPath();\n            this._setPosition();\n        },\n\n        _setPosition: function() {\n            var options = this.options;\n            var x = options.x;\n            var y = options.y;\n            if (defined(x) || defined(y)) {\n                this.position(x || 0, y || 0);\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                VisualBase.fn.redraw.call(this, options);\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    this._drawPath();\n                }\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    this._setPosition();\n                }\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n                stroke: options.stroke,\n                closed: true\n            });\n\n            this._fill();\n            this._drawPath();\n        },\n\n        _drawPath: function() {\n            var drawingElement = this.drawingElement;\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var width = sizeOptions.width;\n            var height = sizeOptions.height;\n\n            drawingElement.segments.elements([\n                createSegment(0, 0),\n                createSegment(width, 0),\n                createSegment(width, height),\n                createSegment(0, height)\n            ]);\n        }\n    });\n\n    var MarkerBase = VisualBase.extend({\n        init: function(options) {\n           VisualBase.fn.init.call(this, options);\n           var anchor = this.options.anchor;\n           this.anchor = new g.Point(anchor.x, anchor.y);\n           this.createElement();\n        },\n\n        options: {\n           stroke: {\n                color: TRANSPARENT,\n                width: 0\n           },\n           fill: {\n                color: \"black\"\n           }\n        },\n\n        _transformToPath: function(point, path) {\n            var transform = path.transform();\n            if (point && transform) {\n                point = point.transformCopy(transform);\n            }\n            return point;\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (options.position) {\n                    this.options.position = options.position;\n                }\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        }\n    });\n\n    var CircleMarker = MarkerBase.extend({\n        options: {\n            radius: 4,\n            anchor: {\n                x: 0,\n                y: 0\n            }\n        },\n\n        createElement: function() {\n            var options = this.options;\n            this.drawingElement = new d.Circle(new g.Circle(this.anchor, options.radius), {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        },\n\n        positionMarker: function(path) {\n            var options = this.options;\n            var position = options.position;\n            var segments = path.segments;\n            var targetSegment;\n            var point;\n\n            if (position == START) {\n                targetSegment = segments[0];\n            } else {\n                targetSegment = segments[segments.length - 1];\n            }\n            if (targetSegment) {\n                point = this._transformToPath(targetSegment.anchor(), path);\n                this.drawingElement.transform(g.transform().translate(point.x, point.y));\n            }\n        }\n    });\n\n    var ArrowMarker = MarkerBase.extend({\n        options: {\n            path: \"M 0 0 L 10 5 L 0 10 L 3 5 z\" ,\n            anchor: {\n                x: 10,\n                y: 5\n            }\n        },\n\n        createElement: function() {\n            var options = this.options;\n            this.drawingElement = d.Path.parse(options.path, {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        },\n\n        positionMarker: function(path) {\n            var points = this._linePoints(path);\n            var start = points.start;\n            var end = points.end;\n            var transform = g.transform();\n            if (start) {\n                transform.rotate(lineAngle(start, end), end);\n            }\n\n            if (end) {\n                var anchor = this.anchor;\n                var translate = end.clone().translate(-anchor.x, -anchor.y);\n                transform.translate(translate.x, translate.y);\n            }\n            this.drawingElement.transform(transform);\n        },\n\n        _linePoints: function(path) {\n            var options = this.options;\n            var segments = path.segments;\n            var startPoint, endPoint, targetSegment;\n            if (options.position == START) {\n                targetSegment = segments[0];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlOut();\n                    var nextSegment = segments[1];\n                    if (!startPoint && nextSegment) {\n                        startPoint = nextSegment.anchor();\n                    }\n                }\n            } else {\n                targetSegment = segments[segments.length - 1];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlIn();\n                    var prevSegment = segments[segments.length - 2];\n                    if (!startPoint && prevSegment) {\n                        startPoint = prevSegment.anchor();\n                    }\n                }\n            }\n            if (endPoint) {\n                return {\n                    start: this._transformToPath(startPoint, path),\n                    end: this._transformToPath(endPoint, path)\n                };\n            }\n        }\n    });\n\n    var MarkerPathMixin = {\n        _getPath: function(position) {\n            var path = this.drawingElement;\n            if (path instanceof d.MultiPath) {\n                if (position == START) {\n                    path = path.paths[0];\n                } else {\n                    path = path.paths[path.paths.length - 1];\n                }\n            }\n            if (path && path.segments.length) {\n                return path;\n            }\n        },\n\n        _normalizeMarkerOptions: function(options) {\n            var startCap = options.startCap;\n            var endCap = options.endCap;\n\n            if (isString(startCap)) {\n                options.startCap = {\n                    type: startCap\n                };\n            }\n\n            if (isString(endCap)) {\n                options.endCap = {\n                    type: endCap\n                };\n            }\n        },\n\n        _removeMarker: function(position) {\n            var marker = this._markers[position];\n            if (marker) {\n                this.drawingContainer().remove(marker.drawingElement);\n                delete this._markers[position];\n            }\n        },\n\n        _createMarkers: function() {\n            var options = this.options;\n            this._normalizeMarkerOptions(options);\n\n            this._markers = {};\n            this._markers[START] = this._createMarker(options.startCap, START);\n            this._markers[END] = this._createMarker(options.endCap, END);\n        },\n\n        _createMarker: function(options, position) {\n            var type = (options || {}).type;\n            var path = this._getPath(position);\n            var markerType, marker;\n            if (!path) {\n                this._removeMarker(position);\n                return;\n            }\n\n            if (type == Markers.filledCircle) {\n                markerType = CircleMarker;\n            } else if (type == Markers.arrowStart || type == Markers.arrowEnd) {\n                markerType = ArrowMarker;\n            } else {\n                this._removeMarker(position);\n            }\n            if (markerType) {\n                marker = new markerType(deepExtend({}, options, {\n                    position: position\n                }));\n                marker.positionMarker(path);\n                this.drawingContainer().append(marker.drawingElement);\n\n                return marker;\n            }\n        },\n\n        _positionMarker: function(position) {\n            var marker = this._markers[position];\n\n            if (marker) {\n                var path = this._getPath(position);\n                if (path) {\n                    marker.positionMarker(path);\n                } else {\n                    this._removeMarker(position);\n                }\n            }\n        },\n\n        _capMap: {\n            start: \"startCap\",\n            end: \"endCap\"\n        },\n\n        _redrawMarker: function(pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n\n            var pathOptions = this.options;\n            var cap = this._capMap[position];\n            var pathCapType = (pathOptions[cap] || {}).type;\n            var optionsCap = options[cap];\n            var created = false;\n            if (optionsCap) {\n                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                if (optionsCap.type && pathCapType != optionsCap.type) {\n                    this._removeMarker(position);\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                } else if (this._markers[position]) {\n                   this._markers[position].redraw(optionsCap);\n                }\n            } else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n            }\n            return created;\n        },\n\n        _redrawMarkers: function(pathChange, options) {\n            if (!this._redrawMarker(pathChange, START, options) && pathChange) {\n                this._positionMarker(START);\n            }\n            if (!this._redrawMarker(pathChange, END, options) && pathChange) {\n                this._positionMarker(END);\n            }\n        }\n    };\n\n    var Path = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._createElements();\n            this._initSize();\n        },\n\n        options: {\n            autoSize: true\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        data: function(value) {\n            var options = this.options;\n            if (value) {\n                if (options.data != value) {\n                   options.data = value;\n                   this._setData(value);\n                   this._initSize();\n                   this._redrawMarkers(true, {});\n                }\n            } else {\n                return options.data;\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                VisualBase.fn.redraw.call(this, options);\n\n                var pathOptions = this.options;\n                var data = options.data;\n\n                if (defined(data) && pathOptions.data != data) {\n                    pathOptions.data = data;\n                    this._setData(data);\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._updateSize(options);\n                    this._redrawMarkers(false, options);\n                }\n            }\n        },\n\n        _createElements: function() {\n            var options = this.options;\n\n            this.drawingElement = d.Path.parse(options.data || \"\", {\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this.container.append(this.drawingElement);\n            this._createMarkers();\n        },\n\n        _setData: function(data) {\n            var drawingElement = this.drawingElement;\n            var multipath = d.Path.parse(data || \"\");\n            var paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n        }\n    });\n\n    deepExtend(Path.fn, AutoSizeableMixin);\n    deepExtend(Path.fn, MarkerPathMixin);\n\n    var Line = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._initPath();\n            this._createMarkers();\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        redraw: function(options) {\n            if (options) {\n                options = options || {};\n                var from = options.from;\n                var to = options.to;\n                if (from) {\n                    this.options.from = from;\n                }\n\n                if (to) {\n                    this.options.to = to;\n                }\n\n                if (from || to) {\n                    this._drawPath();\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._redrawMarkers(false, options);\n                }\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            var drawingElement = this.drawingElement = new d.Path({\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this._drawPath();\n            this.container.append(drawingElement);\n        },\n\n        _drawPath: function() {\n            var options = this.options;\n            var drawingElement = this.drawingElement;\n            var from = options.from || new Point();\n            var to = options.to || new Point();\n\n            drawingElement.segments.elements([\n                createSegment(from.x, from.y),\n                createSegment(to.x, to.y)\n            ]);\n        }\n    });\n\n    deepExtend(Line.fn, MarkerPathMixin);\n\n    var Polyline = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this.container = new d.Group();\n            this._initPath();\n            this._createMarkers();\n        },\n\n        drawingContainer: function() {\n            return this.container;\n        },\n\n        points: function(points) {\n            var options = this.options;\n            if (points) {\n                options.points = points;\n                this._updatePath();\n            } else {\n                return options.points;\n            }\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var points = options.points;\n                VisualBase.fn.redraw.call(this, options);\n\n                if (points && this._pointsDiffer(points)) {\n                    this.points(points);\n                    this._redrawMarkers(true, options);\n                } else {\n                    this._redrawMarkers(false, options);\n                }\n            }\n        },\n\n        _initPath: function() {\n            var options = this.options;\n            this.drawingElement = new d.Path({\n                stroke: options.stroke\n            });\n\n            this._fill();\n            this.container.append(this.drawingElement);\n\n            if (options.points) {\n                this._updatePath();\n            }\n        },\n\n        _pointsDiffer: function(points) {\n            var currentPoints = this.options.points;\n            var differ = currentPoints.length !== points.length;\n            if (!differ) {\n                for (var i = 0; i < points.length; i++) {\n                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                        differ = true;\n                        break;\n                    }\n                }\n            }\n\n            return differ;\n        },\n\n        _updatePath: function() {\n            var drawingElement = this.drawingElement;\n            var options = this.options;\n            var points = options.points;\n            var segments = [];\n            var point;\n            for (var i = 0; i < points.length; i++) {\n                point = points[i];\n                segments.push(createSegment(point.x, point.y));\n            }\n\n            drawingElement.segments.elements(segments);\n        },\n\n        options: {\n            points: []\n        }\n    });\n\n    deepExtend(Polyline.fn, MarkerPathMixin);\n\n    var Image = Element.extend({\n        init: function(options) {\n            Element.fn.init.call(this, options);\n\n            this._initImage();\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (options.source) {\n                    this.drawingElement.src(options.source);\n                }\n\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.drawingElement.rect(this._rect());\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _initImage: function() {\n            var options = this.options;\n            var rect = this._rect();\n\n            this.drawingElement = new d.Image(options.source, rect, {});\n        },\n\n        _rect: function() {\n            var sizeOptions = sizeOptionsOrDefault(this.options);\n            var origin = new g.Point(sizeOptions.x, sizeOptions.y);\n            var size = new g.Size(sizeOptions.width, sizeOptions.height);\n\n            return new g.Rect(origin, size);\n        }\n    });\n\n    var Group = Element.extend({\n        init: function(options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Group();\n            this._initSize();\n        },\n\n        options: {\n            autoSize: false\n        },\n\n        append: function(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n        },\n\n        remove: function(visual) {\n            if (this._remove(visual)) {\n                this._childrenChange = true;\n            }\n        },\n\n        _remove: function(visual) {\n            var index = inArray(visual, this.children);\n            if (index >= 0) {\n                this.drawingElement.removeAt(index);\n                this.children.splice(index, 1);\n                return true;\n            }\n        },\n\n        clear: function() {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n        },\n\n        toFront: function(visuals) {\n            var visual;\n\n            for (var i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                if (this._remove(visual)) {\n                    this.append(visual);\n                }\n            }\n        },\n        //TO DO: add drawing group support for moving and inserting children\n        toBack: function(visuals) {\n            this._reorderChildren(visuals, 0);\n        },\n\n        toIndex: function(visuals, indices) {\n            this._reorderChildren(visuals, indices);\n        },\n\n        _reorderChildren: function(visuals, indices) {\n            var group = this.drawingElement;\n            var drawingChildren = group.children.slice(0);\n            var children = this.children;\n            var fixedPosition = isNumber(indices);\n            var i, index, toIndex, drawingElement, visual;\n\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                drawingElement = visual.drawingContainer();\n\n                index = inArray(visual, children);\n                if (index >= 0) {\n                    drawingChildren.splice(index, 1);\n                    children.splice(index, 1);\n\n                    toIndex = fixedPosition ? indices : indices[i];\n\n                    drawingChildren.splice(toIndex, 0, drawingElement);\n                    children.splice(toIndex, 0, visual);\n                }\n            }\n            group.clear();\n            group.append.apply(group, drawingChildren);\n        },\n\n        redraw: function(options) {\n            if (options) {\n                if (this._childrenChange) {\n                    this._childrenChange = false;\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                } else {\n                    this._updateSize(options);\n                }\n\n                Element.fn.redraw.call(this, options);\n            }\n        },\n\n        _boundingBox: function() {\n            var children = this.children;\n            var boundingBox;\n            var visual, childBoundingBox;\n            for (var i = 0; i < children.length; i++) {\n                visual = children[i];\n                if (visual.visible() && visual._includeInBBox !== false) {\n                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                    if (childBoundingBox) {\n                        if (boundingBox) {\n                            boundingBox = g.Rect.union(boundingBox, childBoundingBox);\n                        } else {\n                            boundingBox = childBoundingBox;\n                        }\n                    }\n                }\n            }\n\n            return boundingBox;\n        }\n    });\n\n    deepExtend(Group.fn, AutoSizeableMixin);\n\n    var Layout = Group.extend({\n        init: function(rect, options) {\n            this.children = [];\n            Element.fn.init.call(this, options);\n            this.drawingElement = new d.Layout(toDrawingRect(rect), options);\n            this._initSize();\n        },\n\n        rect: function(rect) {\n            if (rect) {\n                this.drawingElement.rect(toDrawingRect(rect));\n            } else {\n                var drawingRect = this.drawingElement.rect();\n                if (drawingRect) {\n                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                }\n            }\n        },\n\n        reflow: function() {\n            this.drawingElement.reflow();\n        },\n\n        redraw: function(options) {\n            kendo.deepExtend(this.drawingElement.options, options);\n            Group.fn.redraw.call(this, options);\n        }\n    });\n\n    var Circle = VisualBase.extend({\n        init: function(options) {\n            VisualBase.fn.init.call(this, options);\n            this._initCircle();\n            this._initSize();\n        },\n\n        redraw: function(options) {\n            if (options) {\n                var circleOptions = this.options;\n\n                if (options.center) {\n                    deepExtend(circleOptions, {\n                        center: options.center\n                    });\n                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n                }\n\n                if (this._diffNumericOptions(options, [\"radius\"])) {\n                    this._circle.setRadius(circleOptions.radius);\n                }\n\n                this._updateSize(options);\n\n                VisualBase.fn.redraw.call(this, options);\n            }\n        },\n\n        _initCircle: function() {\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var radius = options.radius;\n            if (!defined(radius)) {\n                if (!defined(width)) {\n                    width = height;\n                }\n                if (!defined(height)) {\n                    height = width;\n                }\n                options.radius = radius = Math.min(width, height) / 2;\n            }\n\n            var center = options.center || { x: radius, y: radius };\n            this._center = new g.Point(center.x, center.y);\n            this._circle = new g.Circle(this._center, radius);\n            this.drawingElement = new d.Circle(this._circle, {\n                stroke: options.stroke\n            });\n\n            this._fill();\n        }\n    });\n    deepExtend(Circle.fn, AutoSizeableMixin);\n\n    var Canvas = Class.extend({\n        init: function(element, options) {\n            options = options || {};\n            this.element = element;\n            this.surface = d.Surface.create(element, options);\n            if (kendo.isFunction(this.surface.translate)) {\n                this.translate = this._translate;\n            }\n\n            this.drawingElement = new d.Group();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n        },\n\n        bounds: function() {\n            var box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n        },\n\n        size: function(size) {\n            var viewBox = this._viewBox;\n            if (defined(size)) {\n                viewBox.width = size.width;\n                viewBox.height = size.height;\n                this.surface.setSize(size);\n            }\n            return {\n                width: viewBox.width,\n                height: viewBox.height\n            };\n        },\n\n        _translate: function(x, y) {\n            var viewBox = this._viewBox;\n            if (defined(x) && defined(y)) {\n                viewBox.x = x;\n                viewBox.y = y;\n                this.surface.translate({ x: x, y: y });\n            }\n            return {\n                x: viewBox.x,\n                y: viewBox.y\n            };\n        },\n\n        draw: function() {\n            this.surface.draw(this.drawingElement);\n        },\n\n        append: function(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n        },\n\n        remove: function(visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n        },\n\n        insertBefore: function() {\n\n        },\n\n        clear: function() {\n            this.drawingElement.clear();\n        },\n\n        destroy: function(clearHtml) {\n            this.surface.destroy();\n            if (clearHtml) {\n                $(this.element).remove();\n            }\n        }\n    });\n\n    // Helper functions ===========================================\n\n    function sizeOptionsOrDefault(options) {\n        return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n        };\n    }\n\n    function normalizeDrawingOptions(options) {\n        if (options) {\n            var drawingOptions = options;\n\n            if (isString(drawingOptions)) {\n                drawingOptions = {\n                    color: drawingOptions\n                };\n            }\n\n            if (drawingOptions.color) {\n                drawingOptions.color = getColor(drawingOptions.color);\n            }\n            return drawingOptions;\n        }\n    }\n\n    function getColor(value) {\n        var color;\n        if (value != TRANSPARENT) {\n            color = new d.Color(value).toHex();\n        } else {\n            color = value;\n        }\n        return color;\n    }\n\n    function lineAngle(p1, p2) {\n        var xDiff = p2.x - p1.x;\n        var yDiff = p2.y - p1.y;\n        var angle = d.util.deg(Math.atan2(yDiff, xDiff));\n        return angle;\n    }\n\n    function createSegment(x, y) {\n        return new g.Segment(new g.Point(x, y));\n    }\n\n    function toDrawingRect(rect) {\n        if (rect) {\n            return new g.Rect([rect.x, rect.y], [rect.width, rect.height]);\n        }\n    }\n\n    // Exports ================================================================\n    kendo.deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n        diffNumericOptions: diffNumericOptions,\n        Element: Element,\n        Scale: Scale,\n        Translation: Translation,\n        Rotation: Rotation,\n        Circle: Circle,\n        Group: Group,\n        Rectangle: Rectangle,\n        Canvas: Canvas,\n        Path: Path,\n        Layout: Layout,\n        Line: Line,\n        MarkerBase: MarkerBase,\n        ArrowMarker: ArrowMarker,\n        CircleMarker: CircleMarker,\n        Polyline: Polyline,\n        CompositeTransform: CompositeTransform,\n        TextBlock: TextBlock,\n        Image: Image,\n        VisualBase: VisualBase\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            dataviz = kendo.dataviz,\n            diagram = dataviz.diagram,\n            Class = kendo.Class,\n            Group = diagram.Group,\n            Rect = diagram.Rect,\n            Rectangle = diagram.Rectangle,\n            Utils = diagram.Utils,\n            isUndefined = Utils.isUndefined,\n            Point = diagram.Point,\n            Circle = diagram.Circle,\n            Ticker = diagram.Ticker,\n            deepExtend = kendo.deepExtend,\n            Movable = kendo.ui.Movable,\n            util = kendo.drawing.util,\n            defined = util.defined,\n            inArray = $.inArray;\n\n        // Constants ==============================================================\n        var Cursors = {\n                arrow: \"default\",\n                grip: \"pointer\",\n                cross: \"pointer\",\n                add: \"pointer\",\n                move: \"move\",\n                select: \"pointer\",\n                south: \"s-resize\",\n                east: \"e-resize\",\n                west: \"w-resize\",\n                north: \"n-resize\",\n                rowresize: \"row-resize\",\n                colresize: \"col-resize\"\n            },\n            HIT_TEST_DISTANCE = 10,\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            DEFAULT_SNAP_SIZE = 10,\n            DEFAULT_SNAP_ANGLE = 10,\n            DRAG_START = \"dragStart\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            ITEMROTATE = \"itemRotate\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            MIN_SNAP_SIZE = 5,\n            MIN_SNAP_ANGLE = 5,\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            SCROLL_MIN = -20000,\n            SCROLL_MAX = 20000,\n            FRICTION = 0.90,\n            FRICTION_MOBILE = 0.93,\n            VELOCITY_MULTIPLIER = 5,\n            TRANSPARENT = \"transparent\",\n            PAN = \"pan\",\n            ROTATED = \"rotated\",\n            SOURCE = \"source\",\n            TARGET = \"target\",\n            HANDLE_NAMES = {\n                \"-1\": SOURCE,\n                \"1\": TARGET\n            };\n\n        diagram.Cursors = Cursors;\n\n        var PositionAdapter = kendo.Class.extend({\n            init: function(layoutState) {\n                this.layoutState = layoutState;\n                this.diagram = layoutState.diagram;\n            },\n            initState: function() {\n                this.froms = [];\n                this.tos = [];\n                this.subjects = [];\n                function pusher(id, bounds) {\n                    var shape = this.diagram.getShapeById(id);\n                    if (shape) {\n                        this.subjects.push(shape);\n                        this.froms.push(shape.bounds().topLeft());\n                        this.tos.push(bounds.topLeft());\n                    }\n                }\n\n                this.layoutState.nodeMap.forEach(pusher, this);\n            },\n            update: function(tick) {\n                if (this.subjects.length <= 0) {\n                    return;\n                }\n                for (var i = 0; i < this.subjects.length; i++) {\n                    //todo: define a Lerp function instead\n                    this.subjects[i].position(\n                        new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick)\n                    );\n                }\n            }\n        });\n\n        var LayoutUndoUnit = Class.extend({\n            init: function(initialState, finalState, animate) {\n                if (isUndefined(animate)) {\n                    this.animate = false;\n                }\n                else {\n                    this.animate = animate;\n                }\n                this._initialState = initialState;\n                this._finalState = finalState;\n                this.title = \"Diagram layout\";\n            },\n            undo: function() {\n                this.setState(this._initialState);\n            },\n            redo: function() {\n                this.setState(this._finalState);\n            },\n            setState: function(state) {\n                var diagram = state.diagram;\n                if (this.animate) {\n                    state.linkMap.forEach(\n                        function(id, points) {\n                            var conn = diagram.getShapeById(id);\n                            conn.visible(false);\n                            if (conn) {\n                                conn.points(points);\n                            }\n                        }\n                    );\n                    var ticker = new Ticker();\n                    ticker.addAdapter(new PositionAdapter(state));\n                    ticker.onComplete(function() {\n                        state.linkMap.forEach(\n                            function(id) {\n                                var conn = diagram.getShapeById(id);\n                                conn.visible(true);\n                            }\n                        );\n                    });\n                    ticker.play();\n                }\n                else {\n                    state.nodeMap.forEach(function(id, bounds) {\n                        var shape = diagram.getShapeById(id);\n                        if (shape) {\n                            shape.position(bounds.topLeft());\n                        }\n                    });\n                    state.linkMap.forEach(\n                        function(id, points) {\n                            var conn = diagram.getShapeById(id);\n                            if (conn) {\n                                conn.points(points);\n                            }\n                        }\n                    );\n                }\n            }\n        });\n\n        var CompositeUnit = Class.extend({\n            init: function(unit) {\n                this.units = [];\n                this.title = \"Composite unit\";\n                if (unit !== undefined$1) {\n                    this.units.push(unit);\n                }\n            },\n            add: function(undoUnit) {\n                this.units.push(undoUnit);\n            },\n            undo: function() {\n                for (var i = 0; i < this.units.length; i++) {\n                    this.units[i].undo();\n                }\n            },\n            redo: function() {\n                for (var i = 0; i < this.units.length; i++) {\n                    this.units[i].redo();\n                }\n            }\n        });\n\n        var ConnectionEditUnit = Class.extend({\n            init: function(item, redoSource, redoTarget) {\n                this.item = item;\n                this._redoSource = redoSource;\n                this._redoTarget = redoTarget;\n                if (defined(redoSource)) {\n                    this._undoSource = item.source();\n                }\n\n                if (defined(redoTarget)) {\n                    this._undoTarget = item.target();\n                }\n                this.title = \"Connection Editing\";\n            },\n            undo: function() {\n                if (this._undoSource !== undefined$1) {\n                    this.item._updateConnector(this._undoSource, \"source\");\n                }\n\n                if (this._undoTarget !== undefined$1) {\n                    this.item._updateConnector(this._undoTarget, \"target\");\n                }\n\n                this.item.updateModel();\n            },\n            redo: function() {\n                if (this._redoSource !== undefined$1) {\n                    this.item._updateConnector(this._redoSource, \"source\");\n                }\n\n                if (this._redoTarget !== undefined$1) {\n                    this.item._updateConnector(this._redoTarget, \"target\");\n                }\n\n                this.item.updateModel();\n            }\n        });\n\n        var ConnectionEditUndoUnit = Class.extend({\n            init: function(item, undoSource, undoTarget) {\n                this.item = item;\n                this._undoSource = undoSource;\n                this._undoTarget = undoTarget;\n                this._redoSource = item.source();\n                this._redoTarget = item.target();\n                this.title = \"Connection Editing\";\n            },\n            undo: function() {\n                this.item._updateConnector(this._undoSource, \"source\");\n                this.item._updateConnector(this._undoTarget, \"target\");\n                this.item.updateModel();\n            },\n            redo: function() {\n                this.item._updateConnector(this._redoSource, \"source\");\n                this.item._updateConnector(this._redoTarget, \"target\");\n                this.item.updateModel();\n            }\n        });\n\n        var DeleteConnectionUnit = Class.extend({\n            init: function(connection) {\n                this.connection = connection;\n                this.diagram = connection.diagram;\n                this.targetConnector = connection.targetConnector;\n                this.title = \"Delete connection\";\n            },\n            undo: function() {\n                this.diagram._addConnection(this.connection, false);\n            },\n            redo: function() {\n                this.diagram.remove(this.connection, false);\n            }\n        });\n\n        var DeleteShapeUnit = Class.extend({\n            init: function(shape) {\n                this.shape = shape;\n                this.diagram = shape.diagram;\n                this.title = \"Deletion\";\n            },\n            undo: function() {\n                this.diagram._addShape(this.shape, false);\n                this.shape.select(false);\n            },\n            redo: function() {\n                this.shape.select(false);\n                this.diagram.remove(this.shape, false);\n            }\n        });\n        /**\n         * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n         * @type {*}\n         */\n        var TransformUnit = Class.extend({\n            init: function(shapes, undoStates, adorner) {\n                this.shapes = shapes;\n                this.undoStates = undoStates;\n                this.title = \"Transformation\";\n                this.redoStates = [];\n                this.adorner = adorner;\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.redoStates.push(shape.bounds());\n                }\n            },\n            undo: function() {\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    shape.bounds(this.undoStates[i]);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner.refreshBounds();\n                    this.adorner.refresh();\n                }\n            },\n            redo: function() {\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    shape.bounds(this.redoStates[i]);\n                    // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                    }\n                    shape.updateModel();\n                }\n\n                if (this.adorner) {\n                    this.adorner.refreshBounds();\n                    this.adorner.refresh();\n                }\n            }\n        });\n\n        var AddConnectionUnit = Class.extend({\n            init: function(connection, diagram) {\n                this.connection = connection;\n                this.diagram = diagram;\n                this.title = \"New connection\";\n            },\n\n            undo: function() {\n                this.diagram.remove(this.connection, false);\n            },\n\n            redo: function() {\n                this.diagram._addConnection(this.connection, false);\n            }\n        });\n\n        var AddShapeUnit = Class.extend({\n            init: function(shape, diagram) {\n                this.shape = shape;\n                this.diagram = diagram;\n                this.title = \"New shape\";\n            },\n\n            undo: function() {\n                this.diagram.deselect();\n                this.diagram.remove(this.shape, false);\n            },\n\n            redo: function() {\n                this.diagram._addShape(this.shape, false);\n            }\n        });\n\n        var PanUndoUnit = Class.extend({\n            init: function(initialPosition, finalPosition, diagram) {\n                this.initial = initialPosition;\n                this.finalPos = finalPosition;\n                this.diagram = diagram;\n                this.title = \"Pan Unit\";\n            },\n            undo: function() {\n                this.diagram.pan(this.initial);\n            },\n            redo: function() {\n                this.diagram.pan(this.finalPos);\n            }\n        });\n\n        var RotateUnit = Class.extend({\n            init: function(adorner, shapes, undoRotates) {\n                this.shapes = shapes;\n                this.undoRotates = undoRotates;\n                this.title = \"Rotation\";\n                this.redoRotates = [];\n                this.redoAngle = adorner._angle;\n                this.adorner = adorner;\n                this.center = adorner._innerBounds.center();\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.redoRotates.push(shape.rotate().angle);\n                }\n            },\n            undo: function() {\n                var i, shape;\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    shape.rotate(this.undoRotates[i], this.center, false);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner._initialize();\n                    this.adorner.refresh();\n                }\n            },\n            redo: function() {\n                var i, shape;\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    shape.rotate(this.redoRotates[i], this.center, false);\n                    if (shape.hasOwnProperty(\"layout\")) {\n                        shape.layout(shape);\n                    }\n                    shape.updateModel();\n                }\n                if (this.adorner) {\n                    this.adorner._initialize();\n                    this.adorner.refresh();\n                }\n            }\n        });\n\n        var ToFrontUnit = Class.extend({\n            init: function(diagram, items, initialIndices) {\n                this.diagram = diagram;\n                this.indices = initialIndices;\n                this.items = items;\n                this.title = \"Rotate Unit\";\n            },\n            undo: function() {\n                this.diagram._toIndex(this.items, this.indices);\n            },\n            redo: function() {\n                this.diagram.toFront(this.items, false);\n            }\n        });\n\n        var ToBackUnit = Class.extend({\n            init: function(diagram, items, initialIndices) {\n                this.diagram = diagram;\n                this.indices = initialIndices;\n                this.items = items;\n                this.title = \"Rotate Unit\";\n            },\n            undo: function() {\n                this.diagram._toIndex(this.items, this.indices);\n            },\n            redo: function() {\n                this.diagram.toBack(this.items, false);\n            }\n        });\n\n        /**\n         * Undo-redo service.\n         */\n        var UndoRedoService = kendo.Observable.extend({\n            init: function(options) {\n                kendo.Observable.fn.init.call(this, options);\n                this.bind(this.events, options);\n                this.stack = [];\n                this.index = 0;\n                this.capacity = 100;\n            },\n\n            events: [\"undone\", \"redone\"],\n\n            /**\n             * Starts the collection of units. Add those with\n             * the addCompositeItem method and call commit. Or cancel to forget about it.\n             */\n            begin: function() {\n                this.composite = new CompositeUnit();\n            },\n\n            /**\n             * Cancels the collection process of unit started with 'begin'.\n             */\n            cancel: function() {\n                this.composite = undefined$1;\n            },\n\n            /**\n             * Commits a batch of units.\n             */\n            commit: function(execute) {\n                if (this.composite.units.length > 0) {\n                    this._restart(this.composite, execute);\n                }\n                this.composite = undefined$1;\n            },\n\n            /**\n             * Adds a unit as part of the begin-commit batch.\n             * @param undoUnit\n             */\n            addCompositeItem: function(undoUnit) {\n                if (this.composite) {\n                    this.composite.add(undoUnit);\n                } else {\n                    this.add(undoUnit);\n                }\n            },\n\n            /**\n             * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n             * @param undoUnit The unit to be added.\n             * @param execute If false, the unit will be added but not executed.\n             */\n            add: function(undoUnit, execute) {\n                this._restart(undoUnit, execute);\n            },\n\n            /**\n             * Returns the number of undoable unit in the stack.\n             * @returns {Number}\n             */\n\n            pop: function() {\n                if (this.index > 0) {\n                    this.stack.pop();\n                    this.index--;\n                }\n            },\n\n            count: function() {\n                return this.stack.length;\n            },\n\n            /**\n             * Rollback of the unit on top of the stack.\n             */\n            undo: function() {\n                if (this.index > 0) {\n                    this.index--;\n                    this.stack[this.index].undo();\n                    this.trigger(\"undone\");\n                }\n            },\n\n            /**\n             * Redo of the last undone action.\n             */\n            redo: function() {\n                if (this.stack.length > 0 && this.index < this.stack.length) {\n                    this.stack[this.index].redo();\n                    this.index++;\n                    this.trigger(\"redone\");\n                }\n            },\n\n            _restart: function(composite, execute) {\n                // throw away anything beyond this point if this is a new branch\n                this.stack.splice(this.index, this.stack.length - this.index);\n                this.stack.push(composite);\n                if (execute !== false) {\n                    this.redo();\n                } else {\n                    this.index++;\n                }\n                // check the capacity\n                if (this.stack.length > this.capacity) {\n                    this.stack.splice(0, this.stack.length - this.capacity);\n                    this.index = this.capacity; //points to the end of the stack\n                }\n            },\n\n            /**\n             * Clears the stack.\n             */\n            clear: function() {\n                this.stack = [];\n                this.index = 0;\n            }\n        });\n\n// Tools =========================================\n\n        var EmptyTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            start: function() {\n            },\n            move: function() {\n            },\n            end: function() {\n            },\n            tryActivate: function() {\n                return false;\n            },\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ScrollerTool = EmptyTool.extend({\n            init: function(toolService) {\n                var tool = this;\n                var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n                EmptyTool.fn.init.call(tool, toolService);\n\n                var diagram = tool.toolService.diagram,\n                    canvas = diagram.canvas;\n\n                var scroller = diagram.scroller = tool.scroller = $(diagram.scrollable).kendoMobileScroller({\n                    friction: friction,\n                    velocityMultiplier: VELOCITY_MULTIPLIER,\n                    mousewheelScrolling: false,\n                    zoom: false,\n                    scroll: tool._move.bind(tool)\n                }).data(\"kendoMobileScroller\");\n\n                if (canvas.translate) {\n                    tool.movableCanvas = new Movable(canvas.element);\n                }\n\n                var virtualScroll = function(dimension, min, max) {\n                    dimension.makeVirtual();\n                    dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n                };\n\n                virtualScroll(scroller.dimensions.x);\n                virtualScroll(scroller.dimensions.y);\n                scroller.disable();\n            },\n\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService;\n                var options = toolService.diagram.options.pannable;\n                var enabled = meta.ctrlKey;\n\n                if (defined(options.key)) {\n                    if (!options.key || options.key == \"none\") {\n                        enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                    } else {\n                        enabled = meta[options.key + \"Key\"];\n                    }\n                }\n\n                return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n            },\n\n            start: function() {\n                this.scroller.enable();\n            },\n            move: function() {\n            },//the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n            _move: function(args) {\n                var tool = this,\n                    diagram = tool.toolService.diagram,\n                    canvas = diagram.canvas,\n                    scrollPos = new Point(args.scrollLeft, args.scrollTop);\n\n                if (canvas.translate) {\n                    diagram._storePan(scrollPos.times(-1));\n                    tool.movableCanvas.moveTo(scrollPos);\n                    canvas.translate(scrollPos.x, scrollPos.y);\n                } else {\n                    scrollPos = scrollPos.plus(diagram._pan.times(-1));\n                }\n\n                diagram.trigger(PAN, { pan: scrollPos });\n            },\n            end: function() {\n                this.scroller.disable();\n            },\n            getCursor: function() {\n                return Cursors.move;\n            }\n        });\n\n        /**\n         * The tool handling the transformations via the adorner.\n         * @type {*}\n         */\n        var PointerTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            tryActivate: function() {\n                return true; // the pointer tool is last and handles all others requests.\n            },\n            start: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    hoveredItem = toolService.hoveredItem;\n\n                if (hoveredItem) {\n                    toolService.selectSingle(hoveredItem, meta);\n                    if (hoveredItem.adorner) { //connection\n                        this.adorner = hoveredItem.adorner;\n                        this.handle = this.adorner._hitTest(p);\n                    }\n                }\n\n                if (!this.handle) {\n                    this.handle = diagram._resizingAdorner._hitTest(p);\n                    if (this.handle) {\n                        this.adorner = diagram._resizingAdorner;\n                    }\n                }\n\n                if (this.adorner) {\n                    if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [] })) {\n                        this.adorner.start(p);\n                    } else {\n                        toolService.startPoint = p;\n                        toolService.end(p);\n                    }\n                }\n            },\n\n            move: function(p) {\n                if (this.adorner) {\n                    this.adorner.move(this.handle, p);\n                    if (this.adorner.isDragHandle(this.handle)) {\n                        this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [] });\n                    }\n                }\n            },\n\n            end: function() {\n                var diagram = this.toolService.diagram,\n                    adorner = this.adorner,\n                    unit;\n\n                if (adorner) {\n                    if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [] })) {\n                        unit = adorner.stop();\n                        if (unit) {\n                            diagram.undoRedoService.add(unit, false);\n                        }\n                    } else {\n                        adorner.cancel();\n                    }\n                }\n\n                this.adorner = undefined$1;\n                this.handle = undefined$1;\n            },\n            getCursor: function(p) {\n                return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n            }\n        });\n\n        var SelectionTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n            },\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService;\n                var selectable = toolService.diagram.options.selectable;\n                var enabled = selectable && selectable.multiple !== false;\n\n                if (enabled) {\n                    if (selectable.key && selectable.key != \"none\") {\n                        enabled = meta[selectable.key + \"Key\"];\n                    } else {\n                        enabled = noMeta(meta);\n                    }\n                }\n\n                return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n            },\n            start: function(p) {\n                var diagram = this.toolService.diagram;\n                diagram.deselect();\n                diagram.selector.start(p);\n            },\n            move: function(p) {\n                var diagram = this.toolService.diagram;\n                diagram.selector.move(p);\n            },\n            end: function(p, meta) {\n                var diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n                var rect = diagram.selector.bounds();\n                if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                    diagram.deselect();\n                }\n                if (!rect.isEmpty()) {\n                    diagram.selectArea(rect);\n                }\n                diagram.selector.end();\n            },\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ConnectionTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n                this.type = \"ConnectionTool\";\n            },\n            tryActivate: function() {\n                return this.toolService._hoveredConnector;\n            },\n            start: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    connector = toolService._hoveredConnector,\n                    connection = diagram._createConnection({}, connector._c, p);\n\n                if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET }) && diagram._addConnection(connection)) {\n                    toolService._connectionManipulation(connection, connector._c.shape, true);\n                    toolService._removeHover();\n                    toolService.selectSingle(toolService.activeConnection, meta);\n                    if (meta.type == \"touchmove\") {\n                        diagram._cachedTouchTarget = connector.visual;\n                    }\n                } else {\n                    connection.source(null);\n                    toolService.end(p);\n                }\n            },\n\n            move: function(p) {\n                var toolService = this.toolService;\n                var connection = toolService.activeConnection;\n\n                connection.target(p);\n                toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET });\n                return true;\n            },\n\n            end: function(p) {\n                var toolService = this.toolService,\n                    d = toolService.diagram,\n                    connection = toolService.activeConnection,\n                    hoveredItem = toolService.hoveredItem,\n                    connector = toolService._hoveredConnector,\n                    target,\n                    cachedTouchTarget = d._cachedTouchTarget;\n\n                if (!connection) {\n                    return;\n                }\n\n                if (connector && connector._c != connection.sourceConnector) {\n                    target = connector._c;\n                } else if (hoveredItem && hoveredItem instanceof diagram.Shape) {\n                    target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(p);\n                } else {\n                    target = p;\n                }\n\n                connection.target(target);\n\n                if (!d.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET })) {\n                    connection.updateModel();\n                    d._syncConnectionChanges();\n                } else {\n                    d.remove(connection, false);\n                    d.undoRedoService.pop();\n                }\n                toolService._connectionManipulation();\n\n                if (cachedTouchTarget) {\n                    d._connectorsAdorner.visual.remove(cachedTouchTarget);\n                    d._cachedTouchTarget = null;\n                }\n            },\n\n            getCursor: function() {\n                return Cursors.arrow;\n            }\n        });\n\n        var ConnectionEditTool = Class.extend({\n            init: function(toolService) {\n                this.toolService = toolService;\n                this.type = \"ConnectionTool\";\n            },\n\n            tryActivate: function(p, meta) {\n                var toolService = this.toolService,\n                    diagram = toolService.diagram,\n                    selectable = diagram.options.selectable,\n                    item = toolService.hoveredItem,\n                    isActive = selectable !== false &&\n                               item && item.path && !(item.isSelected && meta.ctrlKey);\n\n                if (isActive) {\n                    this._c = item;\n                }\n\n                return isActive;\n            },\n\n            start: function(p, meta) {\n                var toolService = this.toolService;\n                var connection = this._c;\n\n                toolService.selectSingle(connection, meta);\n\n                var adorner = connection.adorner;\n\n                var handle, name;\n                if (adorner) {\n                    handle = adorner._hitTest(p);\n                    name = HANDLE_NAMES[handle];\n                }\n\n                if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name })) {\n                    this.handle = handle;\n                    this.handleName = name;\n                    adorner.start(p);\n                } else {\n                    toolService.startPoint = p;\n                    toolService.end(p);\n                }\n            },\n\n            move: function(p) {\n                var adorner = this._c.adorner;\n                if (canDrag(this._c) && adorner) {\n                    adorner.move(this.handle, p);\n                    this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName });\n\n                    return true;\n                }\n            },\n\n            end: function(p) {\n                var connection = this._c;\n                var adorner = connection.adorner;\n                var toolService = this.toolService;\n                var diagram = toolService.diagram;\n\n                if (adorner) {\n                    if (canDrag(connection)) {\n                        var unit = adorner.stop(p);\n                        if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName })) {\n                            diagram.undoRedoService.add(unit, false);\n                            connection.updateModel();\n                            diagram._syncConnectionChanges();\n                        } else {\n                            unit.undo();\n                        }\n                    }\n                }\n            },\n\n            getCursor: function() {\n                return Cursors.move;\n            }\n        });\n\n        function testKey(key, str) {\n            return str.charCodeAt(0) == key || str.toUpperCase().charCodeAt(0) == key;\n        }\n\n        /**\n         * The service managing the tools.\n         * @type {*}\n         */\n        var ToolService = Class.extend({\n            init: function(diagram) {\n                this.diagram = diagram;\n                this.tools = [\n                    new ScrollerTool(this),\n                    new ConnectionEditTool(this),\n                    new ConnectionTool(this),\n                    new SelectionTool(this),\n                    new PointerTool(this)\n                ]; // the order matters.\n\n                this.activeTool = undefined$1;\n            },\n\n            start: function(p, meta) {\n                meta = deepExtend({}, meta);\n                if (this.activeTool) {\n                    this.activeTool.end(p, meta);\n                }\n                this._updateHoveredItem(p);\n                this._activateTool(p, meta);\n                this.activeTool.start(p, meta);\n                this._updateCursor(p);\n                this.diagram.focus();\n                this.diagram.canvas.surface.suspendTracking();\n                this.startPoint = p;\n                return true;\n            },\n\n            move: function(p, meta) {\n                meta = deepExtend({}, meta);\n                var updateHovered = true;\n                if (this.activeTool) {\n                    updateHovered = this.activeTool.move(p, meta);\n                }\n                if (updateHovered) {\n                    this._updateHoveredItem(p);\n                }\n                this._updateCursor(p);\n                return true;\n            },\n\n            end: function(p, meta) {\n                meta = deepExtend({}, meta);\n                if (this.activeTool) {\n                    this.activeTool.end(p, meta);\n                }\n                this.diagram.canvas.surface.resumeTracking();\n                this.activeTool = undefined$1;\n                this._updateCursor(p);\n                return true;\n            },\n\n            keyDown: function(key, meta) {\n                var diagram = this.diagram;\n                meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n                if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) {// ctrl or option\n                    if (testKey(key, \"a\")) {// A: select all\n                        diagram.selectAll();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"z\")) {// Z: undo\n                        diagram.undo();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"y\")) {// y: redo\n                        diagram.redo();\n                        diagram._destroyToolBar();\n                        return true;\n                    } else if (testKey(key, \"c\")) {\n                        diagram.copy();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"x\")) {\n                        diagram.cut();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"v\")) {\n                        diagram.paste();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"l\")) {\n                        diagram.layout();\n                        diagram._destroyToolBar();\n                    } else if (testKey(key, \"d\")) {\n                        diagram._destroyToolBar();\n                        diagram.copy();\n                        diagram.paste();\n                    }\n                } else if (key === 46 || key === 8) {// del: deletion\n                    var toRemove = this.diagram._triggerRemove(diagram.select());\n                    if (toRemove.length) {\n                        this.diagram.remove(toRemove, true);\n                        this.diagram._syncChanges();\n                        this.diagram._destroyToolBar();\n                    }\n\n                    return true;\n                } else if (key === 27) {// ESC: stop any action\n                    this._discardNewConnection();\n                    diagram.deselect();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n\n            },\n            wheel: function(p, meta) {\n                var diagram = this.diagram,\n                    delta = meta.delta,\n                    z = diagram.zoom(),\n                    options = diagram.options,\n                    zoomRate = options.zoomRate,\n                    zoomOptions = { point: p, meta: meta, zoom: z };\n\n                if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                    return;\n                }\n\n                if (delta < 0) {\n                    z += zoomRate;\n                } else {\n                    z -= zoomRate;\n                }\n\n                z = kendo.drawing.util.round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n                zoomOptions.zoom = z;\n\n                diagram.zoom(z, zoomOptions);\n                diagram.trigger(ZOOM_END, zoomOptions);\n\n                return true;\n            },\n            setTool: function(tool, index) {\n                tool.toolService = this;\n                this.tools[index] = tool;\n            },\n\n            selectSingle: function(item, meta) {\n                var diagram = this.diagram;\n                var selectable = diagram.options.selectable;\n                if (selectable && !item.isSelected && item.options.selectable !== false) {\n                    var addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                    diagram.select(item, { addToSelection: addToSelection });\n                }\n            },\n\n            _discardNewConnection: function() {\n                if (this.newConnection) {\n                    this.diagram.remove(this.newConnection);\n                    this.newConnection = undefined$1;\n                }\n            },\n            _activateTool: function(p, meta) {\n                for (var i = 0; i < this.tools.length; i++) {\n                    var tool = this.tools[i];\n                    if (tool.tryActivate(p, meta)) {\n                        this.activeTool = tool;\n                        break; // activating the first available tool in the loop.\n                    }\n                }\n            },\n            _updateCursor: function(p) {\n                var element = this.diagram.element;\n                var cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n\n                element.css({ cursor: cursor });\n            },\n            _connectionManipulation: function(connection, disabledShape, isNew) {\n                this.activeConnection = connection;\n                this.disabledShape = disabledShape;\n                if (isNew) {\n                    this.newConnection = this.activeConnection;\n                } else {\n                    this.newConnection = undefined$1;\n                }\n            },\n            _updateHoveredItem: function(p) {\n                var hit = this._hitTest(p);\n                var diagram = this.diagram;\n\n                if (hit != this.hoveredItem && (!this.disabledShape || hit != this.disabledShape)) {\n                    if (this.hoveredItem) {\n                        diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem });\n                        this.hoveredItem._hover(false);\n                    }\n\n                    if (hit && hit.options.enable) {\n                        diagram.trigger(MOUSE_ENTER, { item: hit });\n\n                        this.hoveredItem = hit; // Shape, connection or connector\n                        this.hoveredItem._hover(true);\n                    } else {\n                        this.hoveredItem = undefined$1;\n                    }\n                }\n            },\n            _removeHover: function() {\n                if (this.hoveredItem) {\n                    this.hoveredItem._hover(false);\n                    this.hoveredItem = undefined$1;\n                }\n            },\n            _hitTest: function(point) {\n                var hit, d = this.diagram, item, i;\n\n                // connectors\n                if (this._hoveredConnector) {\n                    this._hoveredConnector._hover(false);\n                    this._hoveredConnector = undefined$1;\n                }\n                if (d._connectorsAdorner._visible) {\n                    hit = d._connectorsAdorner._hitTest(point);\n                    if (hit) {\n                        return hit;\n                    }\n                }\n\n                hit = this.diagram._resizingAdorner._hitTest(point);\n                if (hit) {\n                    this.hoveredAdorner = d._resizingAdorner;\n                    if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                        return;\n                    }\n                    hit = undefined$1;\n                } else {\n                    this.hoveredAdorner = undefined$1;\n                }\n\n                if (!this.activeTool || this.activeTool.type !== \"ConnectionTool\") {\n                    var selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                    // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                    for (i = 0; i < d._selectedItems.length; i++) {\n                        item = d._selectedItems[i];\n                        if (item instanceof diagram.Connection) {\n                            selectedConnections.push(item);\n                        }\n                    }\n                    hit = this._hitTestItems(selectedConnections, point);\n                }\n\n                return hit || this._hitTestElements(point);\n            },\n\n            _hitTestElements: function(point) {\n                var diagram = this.diagram;\n                var shapeHit = this._hitTestItems(diagram.shapes, point);\n                var connectionHit = this._hitTestItems(diagram.connections, point);\n                var hit;\n\n                if ((!this.activeTool || this.activeTool.type != \"ConnectionTool\") && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                    var mainLayer = diagram.mainLayer;\n                    var shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                    var connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                    hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n                }\n                return hit || shapeHit || connectionHit;\n            },\n\n            _hitTestItems: function(array, point) {\n                var i, item, hit;\n                for (i = array.length - 1; i >= 0; i--) {\n                    item = array[i];\n                    hit = item._hitTest(point);\n                    if (hit) {\n                        return hit;\n                    }\n                }\n            }\n        });\n\n// Routing =========================================\n\n        /**\n         * Base class for connection routers.\n         */\n        var ConnectionRouterBase = kendo.Class.extend({\n            init: function() {\n            }\n            /*route: function (connection) {\n             },\n             hitTest: function (p) {\n\n             },\n             getBounds: function () {\n\n             }*/\n        });\n\n        /**\n         * Base class for polyline and cascading routing.\n         */\n        var LinearConnectionRouter = ConnectionRouterBase.extend({\n            init: function(connection) {\n                var that = this;\n                ConnectionRouterBase.fn.init.call(that);\n                this.connection = connection;\n            },\n            /**\n             * Hit testing for polyline paths.\n             */\n            hitTest: function(p) {\n                var rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n                if (!rec.contains(p)) {\n                    return false;\n                }\n                return diagram.Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n            },\n\n            /**\n             * Bounds of a polyline.\n             * @returns {kendo.dataviz.diagram.Rect}\n             */\n            getBounds: function() {\n                var points = this.connection.allPoints(),\n                    s = points[0],\n                    e = points[points.length - 1],\n                    right = Math.max(s.x, e.x),\n                    left = Math.min(s.x, e.x),\n                    top = Math.min(s.y, e.y),\n                    bottom = Math.max(s.y, e.y);\n\n                for (var i = 1; i < points.length - 1; ++i) {\n                    right = Math.max(right, points[i].x);\n                    left = Math.min(left, points[i].x);\n                    top = Math.min(top, points[i].y);\n                    bottom = Math.max(bottom, points[i].y);\n                }\n\n                return new Rect(left, top, right - left, bottom - top);\n            }\n        });\n\n        /**\n         * A simple poly-linear routing which does not alter the intermediate points.\n         * Does hold the underlying hit, bounds....logic.\n         * @type {*|Object|void|extend|Zepto.extend|b.extend}\n         */\n        var PolylineRouter = LinearConnectionRouter.extend({\n            init: function(connection) {\n                var that = this;\n                LinearConnectionRouter.fn.init.call(that);\n                this.connection = connection;\n            },\n            route: function() {\n                // just keep the points as is\n            }\n        });\n\n        var CascadingRouter = LinearConnectionRouter.extend({\n            SAME_SIDE_DISTANCE_RATIO: 5,\n\n            init: function(connection) {\n                var that = this;\n                LinearConnectionRouter.fn.init.call(that);\n                this.connection = connection;\n            },\n\n            routePoints: function(start, end, sourceConnector, targetConnector) {\n                var result;\n\n                if (sourceConnector && targetConnector) {\n                    result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n                } else {\n                    result = this._floatingPoints(start, end, sourceConnector);\n                }\n                return result;\n            },\n\n            route: function() {\n                var sourceConnector = this.connection._resolvedSourceConnector;\n                var targetConnector = this.connection._resolvedTargetConnector;\n                var start = this.connection.sourcePoint();\n                var end = this.connection.targetPoint();\n                var points = this.routePoints(start, end, sourceConnector, targetConnector);\n                this.connection.points(points);\n            },\n\n            _connectorSides: [{\n                name: \"Top\",\n                axis: \"y\",\n                boundsPoint: \"topLeft\",\n                secondarySign: 1\n            }, {\n                name: \"Left\",\n                axis: \"x\",\n                boundsPoint: \"topLeft\",\n                secondarySign: 1\n            }, {\n                name: \"Bottom\",\n                axis: \"y\",\n                boundsPoint: \"bottomRight\",\n                secondarySign: -1\n            }, {\n                name: \"Right\",\n                axis: \"x\",\n                boundsPoint: \"bottomRight\",\n                secondarySign: -1\n            }],\n\n            _connectorSide: function(connector, targetPoint) {\n                var position = connector.position();\n                var shapeBounds = connector.shape.bounds(ROTATED);\n                var bounds = {\n                    topLeft: shapeBounds.topLeft(),\n                    bottomRight: shapeBounds.bottomRight()\n                };\n                var sides = this._connectorSides;\n                var min = util.MAX_NUM;\n                var sideDistance;\n                var minSide;\n                var axis;\n                var side;\n                for (var idx = 0; idx < sides.length; idx++) {\n                    side = sides[idx];\n                    axis = side.axis;\n                    sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                    if (sideDistance < min) {\n                        min = sideDistance;\n                        minSide = side;\n                    } else if (sideDistance === min &&\n                        (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                        minSide = side;\n                    }\n                }\n                return minSide.name;\n            },\n\n            _sameSideDistance: function(connector) {\n                var bounds = connector.shape.bounds(ROTATED);\n                return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n            },\n\n            _connectorPoints: function(start, end, sourceConnector, targetConnector) {\n                var sourceConnectorSide = this._connectorSide(sourceConnector, end);\n                var targetConnectorSide = this._connectorSide(targetConnector, start);\n                var deltaX = end.x - start.x;\n                var deltaY = end.y - start.y;\n                var sameSideDistance = this._sameSideDistance(sourceConnector);\n                var result = [];\n                var pointX, pointY;\n\n                if (sourceConnectorSide === TOP || sourceConnectorSide == BOTTOM) {\n                    if (targetConnectorSide == TOP || targetConnectorSide == BOTTOM) {\n                        if (sourceConnectorSide == targetConnectorSide) {\n                            if (sourceConnectorSide == TOP) {\n                                pointY = Math.min(start.y, end.y) - sameSideDistance;\n                            } else {\n                                pointY = Math.max(start.y, end.y) + sameSideDistance;\n                            }\n                            result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                        } else {\n                            result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                        }\n                    } else {\n                        result = [new Point(start.x, end.y)];\n                    }\n                } else {\n                    if (targetConnectorSide == LEFT || targetConnectorSide == RIGHT) {\n                        if (sourceConnectorSide == targetConnectorSide) {\n                            if (sourceConnectorSide == LEFT) {\n                                pointX = Math.min(start.x, end.x) - sameSideDistance;\n                            } else {\n                                pointX = Math.max(start.x, end.x) + sameSideDistance;\n                            }\n                            result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                        } else {\n                            result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                        }\n                    } else {\n                        result = [new Point(end.x, start.y)];\n                    }\n                }\n                return result;\n            },\n\n            _floatingPoints: function(start, end, sourceConnector) {\n                var sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n                var cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n                var points = [start, start, end, end];\n                var deltaX = end.x - start.x;\n                var deltaY = end.y - start.y;\n                var length = points.length;\n                var shiftX;\n                var shiftY;\n\n                // note that this is more generic than needed for only two intermediate points.\n                for (var idx = 1; idx < length - 1; ++idx) {\n                    if (cascadeStartHorizontal) {\n                        if (idx % 2 !== 0) {\n                            shiftX = deltaX / (length / 2);\n                            shiftY = 0;\n                        }\n                        else {\n                            shiftX = 0;\n                            shiftY = deltaY / ((length - 1) / 2);\n                        }\n                    }\n                    else {\n                        if (idx % 2 !== 0) {\n                            shiftX = 0;\n                            shiftY = deltaY / (length / 2);\n                        }\n                        else {\n                            shiftX = deltaX / ((length - 1) / 2);\n                            shiftY = 0;\n                        }\n                    }\n                    points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n                }\n                // need to fix the wrong 1.5 factor of the last intermediate point\n                idx--;\n                if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                    points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n                } else {\n                    points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n                }\n\n                return [points[1], points[2]];\n            },\n\n            _startHorizontal: function(start, end, sourceSide) {\n                var horizontal;\n                if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                    horizontal = true;\n                } else {\n                    horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n                }\n\n                return horizontal;\n            }\n        });\n\n// Adorners =========================================\n\n        var AdornerBase = Class.extend({\n            init: function(diagram, options) {\n                var that = this;\n                that.diagram = diagram;\n                that.options = deepExtend({}, that.options, options);\n                that.visual = new Group();\n                that.diagram._adorners.push(that);\n            },\n            refresh: function() {\n\n            }\n        });\n\n        var ConnectionEditAdorner = AdornerBase.extend({\n            init: function(connection, options) {\n                var that = this, diagram;\n                that.connection = connection;\n                diagram = that.connection.diagram;\n                that._ts = diagram.toolService;\n                AdornerBase.fn.init.call(that, diagram, options);\n                var sp = that.connection.sourcePoint();\n                var tp = that.connection.targetPoint();\n                that.spVisual = new Circle(deepExtend(that.options.handles, { center: sp }));\n                that.epVisual = new Circle(deepExtend(that.options.handles, { center: tp }));\n                that.visual.append(that.spVisual);\n                that.visual.append(that.epVisual);\n            },\n\n            options: {\n                handles: {}\n            },\n\n            _getCursor: function() {\n                return Cursors.move;\n            },\n\n            start: function(p) {\n                this.handle = this._hitTest(p);\n                this.startPoint = p;\n                this._initialSource = this.connection.source();\n                this._initialTarget = this.connection.target();\n                switch (this.handle) {\n                    case -1:\n                        if (this.connection.targetConnector) {\n                            this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                        }\n                        break;\n                    case 1:\n                        if (this.connection.sourceConnector) {\n                            this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                        }\n                        break;\n                }\n            },\n\n            move: function(handle, p) {\n                switch (handle) {\n                    case -1:\n                        this.connection.source(p);\n                        break;\n                    case 1:\n                        this.connection.target(p);\n                        break;\n                    default:\n                        var delta = p.minus(this.startPoint);\n                        this.startPoint = p;\n                        if (!this.connection.sourceConnector) {\n                            this.connection.source(this.connection.sourcePoint().plus(delta));\n                        }\n                        if (!this.connection.targetConnector) {\n                            this.connection.target(this.connection.targetPoint().plus(delta));\n                        }\n                        break;\n                }\n                this.refresh();\n                return true;\n            },\n\n            stop: function(p) {\n                var ts = this.diagram.toolService, item = ts.hoveredItem, target;\n                if (ts._hoveredConnector) {\n                    target = ts._hoveredConnector._c;\n                } else if (item && item instanceof diagram.Shape) {\n                    target = item.getConnector(AUTO) || item.getConnector(p);\n                } else {\n                    target = p;\n                }\n\n                if (this.handle === -1) {\n                    this.connection.source(target);\n                } else if (this.handle === 1) {\n                    this.connection.target(target);\n                }\n\n                this.handle = undefined$1;\n                this._ts._connectionManipulation();\n                return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n            },\n\n            _hitTest: function(point) {\n                var sourcePoint = this.connection.sourcePoint();\n                var targetPoint = this.connection.targetPoint();\n                var radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n                var radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n                var sourcePointDistance = sourcePoint.distanceTo(point);\n                var targetPointDistance = targetPoint.distanceTo(point);\n                var sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n                var targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n                var handle = 0;\n\n                if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                    handle = -1;\n                } else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                    handle = 1;\n                }\n\n                return handle;\n            },\n\n            refresh: function() {\n                this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n                this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n            }\n        });\n\n        var ConnectorsAdorner = AdornerBase.extend({\n            init: function(diagram, options) {\n                var that = this;\n                AdornerBase.fn.init.call(that, diagram, options);\n                that._refreshHandler = function(e) {\n                    if (e.item == that.shape) {\n                        that.refresh();\n                    }\n                };\n            },\n\n            show: function(shape) {\n                var that = this, len, i, ctr;\n                that._visible = true;\n                that.shape = shape;\n                that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                len = shape.connectors.length;\n                that.connectors = [];\n                that._clearVisual();\n                for (i = 0; i < len; i++) {\n                    ctr = new ConnectorVisual(shape.connectors[i]);\n                    that.connectors.push(ctr);\n                    that.visual.append(ctr.visual);\n                }\n                that.visual.visible(true);\n                that.refresh();\n            },\n\n            _clearVisual: function() {\n                var that = this;\n                if (that.diagram._cachedTouchTarget) {\n                    that._keepCachedTouchTarget();\n                } else {\n                    that.visual.clear();\n                }\n            },\n\n            _keepCachedTouchTarget: function() {\n                var that = this,\n                    visualChildren = that.visual.children;\n                var childrenCount = visualChildren.length;\n                var index = inArray(that.diagram._cachedTouchTarget, visualChildren);\n                for (var i = childrenCount - 1; i >= 0; i--) {\n                    if (i == index) {\n                        continue;\n                    }\n                    that.visual.remove(visualChildren[i]);\n                }\n            },\n\n            destroy: function() {\n                var that = this;\n                that.diagram.unbind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                that.shape = undefined$1;\n                that._visible = undefined$1;\n                that.visual.visible(false);\n            },\n\n            _hitTest: function(p) {\n                var ctr, i;\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    if (ctr._hitTest(p)) {\n                        ctr._hover(true);\n                        this.diagram.toolService._hoveredConnector = ctr;\n                        break;\n                    }\n                }\n            },\n\n            refresh: function() {\n                if (this.shape) {\n                    var bounds = this.shape.bounds();\n                        bounds = this.diagram.modelToLayer(bounds);\n                    this.visual.position(bounds.topLeft());\n                    $.each(this.connectors, function() {\n                        this.refresh();\n                    });\n                }\n            }\n        });\n\n        function hitToOppositeSide(hit, bounds) {\n            var result;\n\n            if (hit.x == -1 && hit.y == -1) {\n                result = bounds.bottomRight();\n            } else if (hit.x == 1 && hit.y == 1) {\n                result = bounds.topLeft();\n            } else if (hit.x == -1 && hit.y == 1) {\n                result = bounds.topRight();\n            } else if (hit.x == 1 && hit.y == -1) {\n                result = bounds.bottomLeft();\n            } else if (hit.x === 0 && hit.y == -1) {\n                result = bounds.bottom();\n            } else if (hit.x === 0 && hit.y == 1) {\n                result = bounds.top();\n            } else if (hit.x == 1 && hit.y === 0) {\n                result = bounds.left();\n            } else if (hit.x == -1 && hit.y === 0) {\n                result = bounds.right();\n            }\n\n            return result;\n        }\n\n        var ResizingAdorner = AdornerBase.extend({\n            init: function(diagram, options) {\n                var that = this;\n                AdornerBase.fn.init.call(that, diagram, options);\n                that._manipulating = false;\n                that.map = [];\n                that.shapes = [];\n\n                that._initSelection();\n                that._createHandles();\n                that.redraw();\n                that.diagram.bind(\"select\", function(e) {\n                    that._initialize(e.selected);\n                });\n\n                that._refreshHandler = function() {\n                    if (!that._internalChange) {\n                        that.refreshBounds();\n                        that.refresh();\n                    }\n                };\n\n                that._rotatedHandler = function() {\n                    if (that.shapes.length == 1) {\n                        that._angle = that.shapes[0].rotate().angle;\n                    }\n                    that._refreshHandler();\n                };\n\n                that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler).bind(ITEMROTATE, that._rotatedHandler);\n                that.refreshBounds();\n                that.refresh();\n            },\n\n            options: {\n                handles: {\n                    fill: {\n                        color: \"#fff\"\n                    },\n                    stroke: {\n                        color: \"#282828\"\n                    },\n                    height: 7,\n                    width: 7,\n                    hover: {\n                        fill: {\n                            color: \"#282828\"\n                        },\n                        stroke: {\n                            color: \"#282828\"\n                        }\n                    }\n                },\n                selectable: {\n                    stroke: {\n                        color: \"#778899\",\n                        width: 1,\n                        dashType: \"dash\"\n                    },\n                    fill: {\n                        color: TRANSPARENT\n                    }\n                },\n                offset: 10\n            },\n\n            _initSelection: function() {\n                var that = this;\n                var diagram = that.diagram;\n                var selectable = diagram.options.selectable;\n                var options = deepExtend({}, that.options.selectable, selectable);\n                that.rect = new Rectangle(options);\n                that.visual.append(that.rect);\n            },\n\n            _resizable: function() {\n                return this.options.editable && this.options.editable.resize !== false;\n            },\n\n            _handleOptions: function() {\n                return (this.options.editable.resize || {}).handles || this.options.handles;\n            },\n\n            _createHandles: function() {\n                var handles, item, y, x;\n\n                if (this._resizable()) {\n                    handles = this._handleOptions();\n                    for (x = -1; x <= 1; x++) {\n                        for (y = -1; y <= 1; y++) {\n                            if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                                item = new Rectangle(handles);\n                                item.drawingElement._hover = this._hover.bind(this);\n                                this.map.push({ x: x, y: y, visual: item });\n                                this.visual.append(item);\n                            }\n                        }\n                    }\n                }\n            },\n\n            bounds: function(value) {\n                if (value) {\n                    this._innerBounds = value.clone();\n                    this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n                } else {\n                    return this._bounds;\n                }\n            },\n\n            _hitTest: function(p) {\n                var tp = this.diagram.modelToLayer(p),\n                    i, hit, handleBounds, handlesCount = this.map.length, handle;\n\n                if (this._angle) {\n                    tp = tp.clone().rotate(this._angle, this._bounds.center());\n                }\n\n                if (this._resizable()) {\n                    for (i = 0; i < handlesCount; i++) {\n                        handle = this.map[i];\n                        hit = new Point(handle.x, handle.y);\n                        handleBounds = this._getHandleBounds(hit); //local coordinates\n                        handleBounds.offset(this._bounds.x, this._bounds.y);\n                        if (handleBounds.contains(tp)) {\n                            return hit;\n                        }\n                    }\n                }\n\n                if (this._bounds.contains(tp)) {\n                    return new Point(0, 0);\n                }\n            },\n\n            _getHandleBounds: function(p) {\n                if (this._resizable()) {\n                    var handles = this._handleOptions(),\n                        w = handles.width,\n                        h = handles.height,\n                        r = new Rect(0, 0, w, h);\n\n                    if (p.x < 0) {\n                        r.x = - w / 2;\n                    } else if (p.x === 0) {\n                        r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                    } else if (p.x > 0) {\n                        r.x = this._bounds.width + 1.0 - w / 2;\n                    } if (p.y < 0) {\n                        r.y = - h / 2;\n                    } else if (p.y === 0) {\n                        r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                    } else if (p.y > 0) {\n                        r.y = this._bounds.height + 1.0 - h / 2;\n                    }\n\n                    return r;\n                }\n            },\n\n            _getCursor: function(point) {\n                var hit = this._hitTest(point);\n                if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                    var angle = this._angle;\n                    if (angle) {\n                        hit.rotate(angle, new Point(0, 0));\n                        hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                    }\n\n                    if (hit.x == -1 && hit.y == -1) {\n                        return \"nw-resize\";\n                    }\n                    if (hit.x == 1 && hit.y == 1) {\n                        return \"se-resize\";\n                    }\n                    if (hit.x == -1 && hit.y == 1) {\n                        return \"sw-resize\";\n                    }\n                    if (hit.x == 1 && hit.y == -1) {\n                        return \"ne-resize\";\n                    }\n                    if (hit.x === 0 && hit.y == -1) {\n                        return \"n-resize\";\n                    }\n                    if (hit.x === 0 && hit.y == 1) {\n                        return \"s-resize\";\n                    }\n                    if (hit.x == 1 && hit.y === 0) {\n                        return \"e-resize\";\n                    }\n                    if (hit.x == -1 && hit.y === 0) {\n                        return \"w-resize\";\n                    }\n                }\n                return this._manipulating ? Cursors.move : Cursors.select;\n            },\n\n            _initialize: function() {\n                var that = this, i, item,\n                    items = that.diagram.select();\n\n                that.shapes = [];\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof diagram.Shape) {\n                        that.shapes.push(item);\n                        item._rotationOffset = new Point();\n                    }\n                }\n\n                that._angle = that.shapes.length == 1 ? that.shapes[0].rotate().angle : 0;\n                that._startAngle = that._angle;\n                that._rotates();\n                that._positions();\n                that.refreshBounds();\n                that.refresh();\n                that.redraw();\n            },\n\n            _rotates: function() {\n                var that = this, i, shape;\n                that.initialRotates = [];\n                for (i = 0; i < that.shapes.length; i++) {\n                    shape = that.shapes[i];\n                    that.initialRotates.push(shape.rotate().angle);\n                }\n            },\n\n            _positions: function() {\n                var that = this, i, shape;\n                that.initialStates = [];\n                for (i = 0; i < that.shapes.length; i++) {\n                    shape = that.shapes[i];\n                    that.initialStates.push(shape.bounds());\n                }\n            },\n\n            _hover: function(value, element) {\n                if (this._resizable()) {\n                    var handleOptions = this._handleOptions(),\n                        hover = handleOptions.hover,\n                        stroke = handleOptions.stroke,\n                        fill = handleOptions.fill;\n\n                    if (value && Utils.isDefined(hover.stroke)) {\n                        stroke = deepExtend({}, stroke, hover.stroke);\n                    }\n\n                    if (value && Utils.isDefined(hover.fill)) {\n                        fill = hover.fill;\n                    }\n                    element.stroke(stroke.color, stroke.width, stroke.opacity);\n                    element.fill(fill.color, fill.opacity);\n                }\n            },\n\n            start: function(p) {\n                this._sp = p;\n                this._cp = p;\n                this._lp = p;\n                this._manipulating = true;\n                this._internalChange = true;\n                this.shapeStates = [];\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    this.shapeStates.push(shape.bounds());\n                }\n            },\n\n            redraw: function() {\n                var i, handle,\n                    visibleHandles = this._resizable();\n\n                for (i = 0; i < this.map.length; i++) {\n                    handle = this.map[i];\n                    handle.visual.visible(visibleHandles);\n                }\n            },\n\n            angle: function(value) {\n                if (defined(value)) {\n                    this._angle = value;\n                }\n\n                return this._angle;\n            },\n\n            rotate: function() {\n                var center = this._innerBounds.center();\n                var currentAngle = this.angle();\n                this._internalChange = true;\n                for (var i = 0; i < this.shapes.length; i++) {\n                    var shape = this.shapes[i];\n                    currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                    shape.rotate(currentAngle, center);\n                }\n                this.refresh();\n            },\n\n            move: function(handle, p) {\n                var delta, dragging,\n                    dtl = new Point(),\n                    dbr = new Point(),\n                    bounds, center, shape,\n                    i, angle, newBounds,\n                    changed = 0, staticPoint,\n                    scaleX, scaleY;\n\n                if (handle.y === -2 && handle.x === -1) {\n                    center = this._innerBounds.center();\n                    this._angle = this._truncateAngle(Utils.findAngle(center, p));\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                        shape.rotate(angle, center);\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape);\n                        }\n                        this._rotating = true;\n                    }\n                    this.refresh();\n                } else {\n                    if (this.shouldSnap()) {\n                        var thr = this._truncateDistance(p.minus(this._lp));\n                        // threshold\n                        if (thr.x === 0 && thr.y === 0) {\n                            this._cp = p;\n                            return;\n                        }\n                        delta = thr;\n                        this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                    } else {\n                        delta = p.minus(this._cp);\n                    }\n\n                    if (this.isDragHandle(handle)) {\n                        dbr = dtl = delta; // dragging\n                        dragging = true;\n                    } else {\n                        if (this._angle) { // adjust the delta so that resizers resize in the correct direction after rotation.\n                            delta.rotate(this._angle, new Point(0, 0));\n                        }\n                        if (handle.x == -1) {\n                            dtl.x = delta.x;\n                        } else if (handle.x == 1) {\n                            dbr.x = delta.x;\n                        }\n                        if (handle.y == -1) {\n                            dtl.y = delta.y;\n                        } else if (handle.y == 1) {\n                            dbr.y = delta.y;\n                        }\n                    }\n\n                    if (!dragging) {\n                        staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                        scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                        scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                    }\n\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        bounds = shape.bounds();\n                        if (dragging) {\n                            if (!canDrag(shape)) {\n                                continue;\n                            }\n                            newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                        } else {\n                            newBounds = bounds.clone();\n                            newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                            var newCenter = newBounds.center(); // fixes the new rotation center.\n                            newCenter.rotate(-this._angle, bounds.center());\n                            newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                        }\n                        if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                            var oldBounds = bounds;\n                            shape.bounds(newBounds);\n                            if (shape.hasOwnProperty(\"layout\")) {\n                                shape.layout(shape, oldBounds, newBounds);\n                            }\n                            if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                                shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                            }\n                            changed += 1;\n                        }\n                    }\n\n                    if (changed) {\n                        if (changed == i) {\n                            newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                            this.bounds(newBounds);\n                        } else {\n                            this.refreshBounds();\n                        }\n                        this.refresh();\n                    }\n\n                    this._positions();\n                }\n\n                this._cp = p;\n            },\n\n            isDragHandle: function(handle) {\n                return handle.x === 0 && handle.y === 0;\n            },\n\n            cancel: function() {\n                var shapes = this.shapes;\n                var states = this.shapeStates;\n                for (var idx = 0; idx < shapes.length; idx++) {\n                    shapes[idx].bounds(states[idx]);\n                }\n                this.refreshBounds();\n                this.refresh();\n                this._manipulating = undefined$1;\n                this._internalChange = undefined$1;\n                this._rotating = undefined$1;\n            },\n\n            _truncatePositionToGuides: function(bounds) {\n                if (this.diagram.ruler) {\n                    return this.diagram.ruler.truncatePositionToGuides(bounds);\n                }\n                return bounds;\n            },\n\n            _truncateSizeToGuides: function(bounds) {\n                if (this.diagram.ruler) {\n                    return this.diagram.ruler.truncateSizeToGuides(bounds);\n                }\n                return bounds;\n            },\n\n            _truncateAngle: function(a) {\n                var snap = this.snapOptions();\n                var snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n                return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n            },\n\n            _truncateDistance: function(d) {\n                if (d instanceof diagram.Point) {\n                    return new diagram.Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n                } else {\n                    var snap = this.snapOptions() || {};\n                    var snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                    return snap ? Math.floor(d / snapSize) * snapSize : d;\n                }\n            },\n\n            snapOptions: function() {\n                var editable = this.diagram.options.editable;\n                var snap = ((editable || {}).drag || {}).snap || {};\n                return snap;\n            },\n\n            shouldSnap: function() {\n                var editable = this.diagram.options.editable;\n                var drag = (editable || {}).drag;\n                var snap = (drag || {}).snap;\n                return editable !== false && drag !== false && snap !== false;\n            },\n\n            _displaceBounds: function(bounds, dtl, dbr, dragging) {\n                var tl = bounds.topLeft().plus(dtl),\n                    br = bounds.bottomRight().plus(dbr),\n                    newBounds = Rect.fromPoints(tl, br),\n                    newCenter;\n                if (!dragging) {\n                    newCenter = newBounds.center();\n                    newCenter.rotate(bounds.center(), -this._angle);\n                    newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                }\n                return newBounds;\n            },\n\n            stop: function() {\n                var unit, i, shape;\n                if (this._cp != this._sp) {\n                    if (this._rotating) {\n                        unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                        this._rotating = false;\n                    } else if (this._diffStates()) {\n                        if (this.diagram.ruler) {\n                            for (i = 0; i < this.shapes.length; i++) {\n                                shape = this.shapes[i];\n                                var bounds = shape.bounds();\n                                bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                                shape.bounds(bounds);\n                                this.refreshBounds();\n                                this.refresh();\n                            }\n                        }\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            shape.updateModel();\n                        }\n                        unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                        this.diagram._syncShapeChanges();\n                    }\n                }\n\n                this._manipulating = undefined$1;\n                this._internalChange = undefined$1;\n                this._rotating = undefined$1;\n                return unit;\n            },\n\n            _diffStates: function() {\n                var shapes = this.shapes;\n                var states = this.shapeStates;\n                for (var idx = 0; idx < shapes.length; idx++) {\n                    if (!shapes[idx].bounds().equals(states[idx])) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n\n            refreshBounds: function() {\n                var bounds = this.shapes.length == 1 ?\n                    this.shapes[0].bounds().clone() :\n                    this.diagram.boundingBox(this.shapes, true);\n\n                this.bounds(bounds);\n            },\n\n            refresh: function() {\n                var that = this, b, bounds;\n                if (this.shapes.length > 0) {\n                    bounds = this.bounds();\n                    this.visual.visible(true);\n                    this.visual.position(bounds.topLeft());\n                    $.each(this.map, function() {\n                        b = that._getHandleBounds(new Point(this.x, this.y));\n                        this.visual.position(b.topLeft());\n                    });\n                    this.visual.position(bounds.topLeft());\n\n                    var center = new Point(bounds.width / 2, bounds.height / 2);\n                    this.visual.rotate(this._angle, center);\n                    this.rect.redraw({ width: bounds.width, height: bounds.height });\n                    if (this.rotationThumb) {\n                        var thumb = this.options.editable.rotate.thumb;\n                        this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                        this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                    }\n                } else {\n                    this.visual.visible(false);\n                }\n            }\n        });\n\n        var Selector = Class.extend({\n            init: function(diagram) {\n                var selectable = diagram.options.selectable;\n                this.options = deepExtend({}, this.options, selectable);\n\n                this.visual = new Rectangle(this.options);\n                this.diagram = diagram;\n            },\n            options: {\n                stroke: {\n                    color: \"#778899\",\n                    width: 1,\n                    dashType: \"dash\"\n                },\n                fill: {\n                    color: TRANSPARENT\n                }\n            },\n            start: function(p) {\n                this._sp = this._ep = p;\n                this.refresh();\n                this.diagram._adorn(this, true);\n            },\n            end: function() {\n                this._sp = this._ep = undefined$1;\n                this.diagram._adorn(this, false);\n            },\n            bounds: function(value) {\n                if (value) {\n                    this._bounds = value;\n                }\n                return this._bounds;\n            },\n            move: function(p) {\n                this._ep = p;\n                this.refresh();\n            },\n            refresh: function() {\n                if (this._sp) {\n                    var visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                    this.bounds(Rect.fromPoints(this._sp, this._ep));\n                    this.visual.position(visualBounds.topLeft());\n                    this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n                }\n            }\n        });\n\n        var ConnectorVisual = Class.extend({\n            init: function(connector) {\n                this.options = deepExtend({}, connector.options);\n                this._c = connector;\n                this.visual = new Circle(this.options);\n                this.refresh();\n            },\n            _hover: function(value) {\n                var options = this.options,\n                    hover = options.hover,\n                    stroke = options.stroke,\n                    fill = options.fill;\n\n                if (value && Utils.isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n\n                if (value && Utils.isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n\n                this.visual.redraw({\n                    stroke: stroke,\n                    fill: fill\n                });\n            },\n            refresh: function() {\n                var p = this._c.shape.diagram.modelToView(this._c.position()),\n                    relative = p.minus(this._c.shape.bounds(\"transformed\").topLeft()),\n                    value = new Rect(p.x, p.y, 0, 0);\n                value.inflate(this.options.width / 2, this.options.height / 2);\n                this._visualBounds = value;\n                this.visual.redraw({ center: new Point(relative.x, relative.y) });\n            },\n            _hitTest: function(p) {\n                var tp = this._c.shape.diagram.modelToView(p);\n                return this._visualBounds.contains(tp);\n            }\n        });\n\n        function canDrag(element) {\n            var editable = element.options.editable;\n            return editable && editable.drag !== false;\n        }\n\n        function hitTestShapeConnectors(shape, point) {\n            var connector, position, rect;\n            for (var idx = 0; idx < shape.connectors.length; idx++) {\n                connector = shape.connectors[idx];\n                position = connector.position();\n                rect = new Rect(position.x, position.y);\n                rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n                if (rect.contains(point)) {\n                    return connector;\n                }\n            }\n        }\n\n        function noMeta(meta) {\n            return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n        }\n\n        deepExtend(diagram, {\n            CompositeUnit: CompositeUnit,\n            TransformUnit: TransformUnit,\n            PanUndoUnit: PanUndoUnit,\n            AddShapeUnit: AddShapeUnit,\n            AddConnectionUnit: AddConnectionUnit,\n            DeleteShapeUnit: DeleteShapeUnit,\n            DeleteConnectionUnit: DeleteConnectionUnit,\n            ConnectionEditAdorner: ConnectionEditAdorner,\n            ConnectionTool: ConnectionTool,\n            ConnectorVisual: ConnectorVisual,\n            UndoRedoService: UndoRedoService,\n            ResizingAdorner: ResizingAdorner,\n            Selector: Selector,\n            ToolService: ToolService,\n            ConnectorsAdorner: ConnectorsAdorner,\n            LayoutUndoUnit: LayoutUndoUnit,\n            ConnectionEditUnit: ConnectionEditUnit,\n            ToFrontUnit: ToFrontUnit,\n            ToBackUnit: ToBackUnit,\n            ConnectionRouterBase: ConnectionRouterBase,\n            PolylineRouter: PolylineRouter,\n            CascadingRouter: CascadingRouter,\n            SelectionTool: SelectionTool,\n            ScrollerTool: ScrollerTool,\n            PointerTool: PointerTool,\n            ConnectionEditTool: ConnectionEditTool,\n            RotateUnit: RotateUnit\n        });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Graph = diagram.Graph,\n        Node = diagram.Node,\n        Link = diagram.Link,\n        deepExtend = kendo.deepExtend,\n        Size = diagram.Size,\n        Rect = diagram.Rect,\n        Dictionary = diagram.Dictionary,\n        Set = diagram.Set,\n        HyperTree = diagram.Graph,\n        Utils = diagram.Utils,\n        Point = diagram.Point,\n        EPSILON = 1e-06,\n        DEG_TO_RAD = Math.PI / 180,\n        contains = Utils.contains,\n        grep = $.grep;\n\n    /**\n     * Base class for layout algorithms.\n     * @type {*}\n     */\n    var LayoutBase = kendo.Class.extend({\n        defaultOptions: {\n            type: \"Tree\",\n            subtype: \"Down\",\n            roots: null,\n            animate: false,\n            //-------------------------------------------------------------------\n            /**\n             * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n             */\n            limitToView: false,\n            /**\n             * Force-directed option: the amount of friction applied to the motion of the nodes.\n             */\n            friction: 0.9,\n            /**\n             * Force-directed option: the optimal distance between nodes (minimum energy).\n             */\n            nodeDistance: 50,\n            /**\n             * Force-directed option: the number of time things are being calculated.\n             */\n            iterations: 300,\n            //-------------------------------------------------------------------\n            /**\n             * Tree option: the separation in one direction (depends on the subtype what direction this is).\n             */\n            horizontalSeparation: 90,\n            /**\n             * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n             */\n            verticalSeparation: 50,\n\n            //-------------------------------------------------------------------\n            /**\n             * Tip-over tree option: children-to-parent vertical distance.\n             */\n            underneathVerticalTopOffset: 15,\n            /**\n             * Tip-over tree option: children-to-parent horizontal distance.\n             */\n            underneathHorizontalOffset: 15,\n            /**\n             * Tip-over tree option: leaf-to-next-branch vertical distance.\n             */\n            underneathVerticalSeparation: 15,\n            //-------------------------------------------------------------------\n            /**\n             * Settings object to organize the different components of the diagram in a grid layout structure\n             */\n            grid: {\n                /**\n                 * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n                 */\n                width: 1500,\n                /**\n                 * The left offset of the grid.\n                 */\n                offsetX: 50,\n                /**\n                 * The top offset of the grid.\n                 */\n                offsetY: 50,\n                /**\n                 * The horizontal padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingX: 20,\n                /**\n                 * The vertical padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingY: 20\n            },\n\n            //-------------------------------------------------------------------\n            /**\n             * Layered option: the separation height/width between the layers.\n             */\n            layerSeparation: 50,\n            /**\n             * Layered option: how many rounds of shifting and fine-tuning.\n             */\n            layeredIterations: 2,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            startRadialAngle: 0,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            endRadialAngle: 360,\n            /**\n             * Tree-radial option: the separation between levels.\n             */\n            radialSeparation: 150,\n            /**\n             * Tree-radial option: the separation between the root and the first level.\n             */\n            radialFirstLevelSeparation: 200,\n            /**\n             * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n             */\n            keepComponentsInOneRadialLayout: false,\n            //-------------------------------------------------------------------\n\n            // TODO: ensure to change this to false when containers are around\n            ignoreContainers: true,\n            layoutContainerChildren: false,\n            ignoreInvisible: true,\n            animateTransitions: false\n        },\n        init: function() {\n        },\n\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         * @param components\n         */\n        gridLayoutComponents: function(components) {\n            if (!components) {\n                throw \"No components supplied.\";\n            }\n\n            // calculate and cache the bounds of the components\n            Utils.forEach(components, function(c) {\n                c.calcBounds();\n            });\n\n            // order by decreasing width\n            components.sort(function(a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n\n            var maxWidth = this.options.grid.width,\n                offsetX = this.options.grid.componentSpacingX,\n                offsetY = this.options.grid.componentSpacingY,\n                height = 0,\n                startX = this.options.grid.offsetX,\n                startY = this.options.grid.offsetY,\n                x = startX,\n                y = startY,\n                i,\n                resultLinkSet = [],\n                resultNodeSet = [];\n\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                var component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                var boundingRect = component.bounds;\n                var currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                var currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        },\n\n        moveToOffset: function(component, p) {\n            var i, j,\n                bounds = component.bounds,\n                deltax = p.x - bounds.x,\n                deltay = p.y - bounds.y;\n\n            for (i = 0; i < component.nodes.length; i++) {\n                var node = component.nodes[i];\n                var nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltax;\n                nodeBounds.y += deltay;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                var link = component.links[i];\n                if (link.points) {\n                    var newpoints = [];\n                    var points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        var pt = points[j];\n                        pt.x += deltax;\n                        pt.y += deltay;\n                        newpoints.push(pt);\n                    }\n                    link.points = newpoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltax, deltay);\n        },\n\n        transferOptions: function(options) {\n\n            // Size options lead to stackoverflow and need special handling\n\n            this.options = kendo.deepExtend({}, this.defaultOptions);\n            if (Utils.isUndefined(options)) {\n                return;\n            }\n\n            this.options = kendo.deepExtend(this.options, options || {});\n        }\n    });\n\n    /**\n     * The data bucket a hypertree holds in its nodes.     *\n     * @type {*}\n     */\n    /* var ContainerGraph = kendo.Class.extend({\n     init: function (diagram) {\n     this.diagram = diagram;\n     this.graph = new Graph(diagram);\n     this.container = null;\n     this.containerNode = null;\n     }\n\n     });*/\n\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     * @type {*}\n     */\n    var DiagramToHyperTreeAdapter = kendo.Class.extend({\n        init: function(diagram) {\n\n            /**\n             * The mapping to/from the original nodes.\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n\n            /**\n             * The nodes being mapped.\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n\n            /**\n             * The connections being mapped.\n             * @type {Dictionary}\n             */\n            this.edges = [];\n\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalNodes = [];\n\n            /**\n             * The resulting set of Links when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalLinks = [];\n\n            /**\n             * The items being omitted because of multigraph edges.\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             * @type {null}\n             */\n            this.finalGraph = null;\n\n            this.diagram = diagram;\n        },\n\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         *    since there is no node mapped for the container.\n         *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         * @param options\n         */\n        convert: function(options) {\n\n            if (Utils.isUndefined(this.diagram)) {\n                throw \"No diagram to convert.\";\n            }\n\n            this.options = kendo.deepExtend({\n                    ignoreInvisible: true,\n                    ignoreContainers: true,\n                    layoutContainerChildren: false\n                },\n                options || {}\n            );\n\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function(n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function(l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        },\n\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection: function(connection) {\n            return this.edgeMap.get(connection.id);\n        },\n\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         * @param shape\n         * @returns {*}\n         */\n        mapShape: function(shape) {\n            return this.nodeMap.get(shape.id);\n        },\n\n        /**\n         * Gets the edge, if any, between the given nodes.\n         * @param a\n         * @param b\n         */\n        getEdge: function(a, b) {\n            return Utils.first(a.links, function(link) {\n                return link.getComplement(a) === b;\n            });\n        },\n\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear: function() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new HyperTree() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        },\n\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot: function(containerGraph) {\n            var list = [];\n            var s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        },\n\n        firstNonIgnorableContainer: function(shape) {\n\n            if (shape.isContainer && !this._isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        },\n        isContainerConnection: function(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        },\n\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf: function(scope, a) {\n            if (!scope.isContainer) {\n                throw \"Expecting a container.\";\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            var containers = [];\n            for (var i = 0, len = scope.children.length; i < len; i++) {\n                var c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n\n            return containers.length > 0;\n        },\n        isIgnorableItem: function(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        },\n\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         * necessarily a container in the parent hierarchy of the shape.\n         * @param shape\n         */\n        isShapeMapped: function(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        },\n\n        leastCommonAncestor: function(a, b) {\n            if (!a) {\n                throw \"Parameter should not be null.\";\n            }\n            if (!b) {\n                throw \"Parameter should not be null.\";\n            }\n\n            if (!this.hyperTree) {\n                throw \"No hypertree available.\";\n            }\n            var al = this.listToRoot(a);\n            var bl = this.listToRoot(b);\n            var found = null;\n            if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n                return this.hyperTree.root.data;\n            }\n            var xa = al[0];\n            var xb = bl[0];\n            var i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root.data;\n            }\n            else {\n                return grep(this.hyperTree.nodes, function(n) {\n                    return n.data.container === found;\n                });\n            }\n        },\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop: function(item) {\n            return !item.parentContainer;\n        },\n\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible: function(shape) {\n\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        },\n\n        _isCollapsed: function(shape) {\n\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        },\n\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         * @private\n         */\n        _renormalizeShapes: function() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    var shape = this.diagram.shapes[i];\n\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    var node = new Node(shape.id, shape);\n                    node.isVirtual = false;\n\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw \"Containers are not supported yet, but stay tuned.\";\n            }\n        },\n\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         * @private\n         */\n        _renormalizeConnections: function() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n                var conn = this.diagram.connections[i];\n\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                var sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n\n                var sourceNode = this.mapShape(source);\n                var sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (sourceNode === null || sinkNode === null) {\n                    throw \"A shape was not mapped to a node.\";\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw \"Containers are not supported yet, but stay tuned.\";\n                }\n            }\n        },\n\n        areConnectedAlready: function(n, m) {\n            return Utils.any(this.edges, function(l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n\n        /**\n         * Depth-first traversal of the given container.\n         * @param container\n         * @param action\n         * @param includeStart\n         * @private\n         */\n        /* _visitContainer: function (container, action, includeStart) {\n\n         *//*if (container == null) throw new ArgumentNullException(\"container\");\n         if (action == null) throw new ArgumentNullException(\"action\");\n         if (includeStart) action(container);\n         if (container.children.isEmpty()) return;\n         foreach(\n         var item\n         in\n         container.children.OfType < IShape > ()\n         )\n         {\n         var childContainer = item\n         as\n         IContainerShape;\n         if (childContainer != null) this.VisitContainer(childContainer, action);\n         else action(item);\n         }*//*\n         }*/\n\n\n    });\n\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     * @type {*}\n     */\n    var SpringLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutGraph: function(graph, options) {\n\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            var initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n\n            var guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n\n            for (var step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations ));\n            }\n        },\n\n        /**\n         * Single iteration of the simulation.\n         */\n        tick: function() {\n            var i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                var node = this.graph.nodes[i];\n                var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        },\n\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         * @param node A Node.\n         * @private\n         */\n        _shake: function(node) {\n            // just a simple polar neighborhood\n            var rho = Math.random() * this.options.nodeDistance / 4;\n            var alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        },\n\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce: function(d, n, m) {\n            var force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                var deltax = n.x - m.x;\n                var deltay = n.y - m.y;\n\n                var wn = n.width / 2;\n                var hn = n.height / 2;\n                var wm = m.width / 2;\n                var hm = m.height / 2;\n\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        },\n\n        /**\n         * The typical Hooke force law F=kr^2\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce: function(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        },\n\n        _repulsion: function(n) {\n            n.dx = 0;\n            n.dy = 0;\n            Utils.forEach(this.graph.nodes, function(m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                var vx = n.x - m.x;\n                var vy = n.y - m.y;\n                var distance = Math.sqrt(vx * vx + vy * vy);\n                var r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        },\n        _attraction: function(link) {\n            var t = link.target;\n            var s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n\n            var vx = s.x - t.x;\n            var vy = s.y - t.y;\n            var distance = Math.sqrt(vx * vx + vy * vy);\n\n            var a = this._InverseSquareForce(distance, s, t) * 5;\n            var dx = (vx / distance) * a;\n            var dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        },\n\n        /**\n         * Calculates the expected bounds after layout.\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds: function() {\n\n            var size, N = this.graph.nodes.length, /*golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return size;\n            }\n            size = Utils.fold(this.graph.nodes, function(s, node) {\n                var area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            var av = size / N;\n            var squareSize = av * Math.ceil(Math.sqrt(N));\n            var width = squareSize * Math.sqrt(ratio);\n            var height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n\n    });\n\n    var TreeLayoutProcessor = kendo.Class.extend({\n\n        init: function(options) {\n            this.center = null;\n            this.options = options;\n        },\n        layout: function(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n\n            if (!contains(this.graph.nodes, root)) {\n                throw \"The given root is not in the graph.\";\n            }\n\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n\n            // transfer the rects\n            /*nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n\n            this.layoutSwitch();\n\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        },\n\n        layoutLeft: function(left) {\n            this.setChildrenDirection(this.center, \"Left\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = \"Left\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                var p = new Point(x - node.Size.width, y);\n\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutRight: function(right) {\n            this.setChildrenDirection(this.center, \"Right\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = \"Right\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutUp: function(up) {\n            this.setChildrenDirection(this.center, \"Up\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = \"Up\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutDown: function(down) {\n            var node, i;\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutRadialTree: function() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, \"Radial\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.previousRoot = null;\n            var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw \"Final angle should not be less than the start angle.\";\n            }\n\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        },\n\n        tipOverTree: function(down, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n            var w = 0, y, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n\n            /*//let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        },\n        calculateAngularWidth: function(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n\n            var aw = 0, w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (var i = 0, len = n.children.length; i < len; i++) {\n                    var child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n\n            n.sectorAngle = aw;\n            return aw;\n        },\n        sortChildren: function(n) {\n            var basevalue = 0, i;\n\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw \"Node is not part of a tree.\";\n            }\n            var p = n.parents[0];\n            if (p) {\n                var pl = new Point(p.x, p.y);\n                var nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n\n            var count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n\n            var angle = [];\n            var idx = [];\n\n            for (i = 0; i < count; ++i) {\n                var c = n.children[i];\n                var l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n\n            Utils.bisort(angle, idx);\n            var col = []; // list of nodes\n            var children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n\n            return col;\n        },\n\n        normalizeAngle: function(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        },\n        radialLayout: function(node, radius, startAngle, endAngle) {\n            var deltaTheta = endAngle - startAngle;\n            var deltaThetaHalf = deltaTheta / 2.0;\n            var parentSector = node.sectorAngle;\n            var fraction = 0;\n            var sorted = this.sortChildren(node);\n            for (var i = 0, len = sorted.length; i < len; i++) {\n                var childNode = sorted[i];\n                var cp = childNode;\n                var childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode,\n                        radius + this.options.radialSeparation,\n                        startAngle + (fraction * deltaTheta),\n                        startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        },\n        setPolarLocation: function(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        },\n\n        /**\n         * Sets the children direction recursively.\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection: function(node, direction, includeStart) {\n            var rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, function(n) {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        },\n\n        /**\n         * Sets the children layout recursively.\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout: function(node, layout, includeStart, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            var rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(\n                    node, function(s) {\n                        if (s.level >= startFromLevel + 1) {\n                            s.childrenLayout = layout;\n                        }\n                    }\n                );\n            }\n            else {\n                this.graph.depthFirstTraversal(node, function(s) {\n                    s.childrenLayout = layout;\n                });\n\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        },\n\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure: function(node, givenSize) {\n            var w = 0, h = 0, s;\n            var result = new Size(0, 0);\n            if (!node) {\n                throw \"\";\n            }\n            var b = node.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw \"Node not in a spanning tree.\";\n            }\n\n            var parent = node.parents[0];\n            if (node.treeDirection === \"Undefined\") {\n                node.treeDirection = parent.treeDirection;\n            }\n\n            if (Utils.isEmpty(node.children)) {\n                result = new Size(\n                    Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth,\n                    Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case \"Radial\":\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                                break;\n\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                        }\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n            else {\n                var i, childNode;\n                switch (node.treeDirection) {\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                        }\n\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n\n                                w -= this.options.horizontalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        },\n        arrange: function(n, p) {\n            var i, pp, child, node, childrenwidth, b = n.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (Utils.isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                var x, y;\n                var selfLocation;\n                switch (n.treeDirection) {\n                    case \"Left\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Right\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Up\":\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n\n                    case \"Down\":\n\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n                        break;\n\n                    case \"None\":\n                        break;\n\n                    default:\n                        throw \"Unsupported TreeDirection\";\n                }\n            }\n        },\n        layoutSwitch: function() {\n            if (!this.center) {\n                return;\n            }\n\n            if (Utils.isEmpty(this.center.children)) {\n                return;\n            }\n\n            var type = this.options.subtype;\n            if (Utils.isUndefined(type)) {\n                type = \"Down\";\n            }\n            var single, male, female, leftcount;\n            var children = this.center.children;\n            switch (type.toLowerCase()) {\n                case \"radial\":\n                case \"radialtree\":\n                    this.layoutRadialTree();\n                    break;\n\n                case \"mindmaphorizontal\":\n                case \"mindmap\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n\n                case \"mindmapvertical\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n\n                case \"right\":\n                    this.layoutRight(this.center.children);\n                    break;\n\n                case \"left\":\n                    this.layoutLeft(this.center.children);\n                    break;\n\n                case \"up\":\n                case \"bottom\":\n                    this.layoutUp(this.center.children);\n                    break;\n\n                case \"down\":\n                case \"top\":\n                    this.layoutDown(this.center.children);\n                    break;\n\n                case \"tipover\":\n                case \"tipovertree\":\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw \"The tip-over level should be a positive integer.\";\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n\n                case \"undefined\":\n                case \"none\":\n                    break;\n            }\n        }\n    });\n\n    /**\n     * The various tree layout algorithms.\n     * @type {*}\n     */\n    var TreeLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            // transform the diagram into a Graph\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n\n            /**\n             * The Graph reduction from the given diagram.\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n\n            var finalNodeSet = this.layoutComponents();\n\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutComponents: function() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n\n            // split into connected components\n            var components = this.graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n\n            var layout = new TreeLayoutProcessor(this.options);\n            var trees = [];\n            // find a spanning tree for each component\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n\n                var treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw \"Failed to find a spanning tree for the component.\";\n                }\n                var root = treeGraph.root;\n                var tree = treeGraph.tree;\n                layout.layout(tree, root);\n\n                trees.push(tree);\n            }\n\n            return this.gridLayoutComponents(trees);\n\n        },\n\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree: function(graph) {\n            var root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                    var node = graph.nodes[i];\n                    for (var j = 0; j < this.options.roots.length; j++) {\n                        var givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw \"Unable to find a root for the tree.\";\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        },\n\n        getTreeForRoot: function(graph, root) {\n\n            var tree = graph.getSpanningTree(root);\n            if (Utils.isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root\n            };\n        }\n\n    });\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     * @type {*}\n     */\n    var LayeredLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n\n        },\n\n        /**\n         * Initializes the runtime data properties of the layout.\n         * @private\n         */\n        _initRuntimeProperties: function() {\n            for (var k = 0; k < this.graph.nodes.length; k++) {\n                var node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n\n                node.isVirtual = false;\n\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n\n                node.gridPosition = 0;\n            }\n        },\n        _prepare: function(graph) {\n            var current = [], i, l, link;\n\n            // defines a mapping of a node to the layer index\n            var layerMap = new Dictionary();\n            var layerCount = 0;\n            var targetLayer, next, target;\n\n            Utils.forEach(graph.nodes, function(node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    } else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n\n            var sortedNodes = layerMap.keys();\n\n            sortedNodes.sort(function(o1, o2) {\n                var o1layer = layerMap.get(o1);\n                var o2layer = layerMap.get(o2);\n                return Utils.sign(o2layer - o1layer);\n            });\n\n            for (var n = 0; n < sortedNodes.length; ++n) {\n                var node = sortedNodes[n];\n                var minLayer = Number.MAX_VALUE;\n\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n\n            this.layers = [];\n            var layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n\n            layerMap.forEach(function(node, layer) {\n                node.layer = layer;\n                this.layers[layer].push(node);\n            }, this);\n\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        },\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph: function(graph, options) {\n            if (Utils.isUndefined(graph)) {\n                throw \"No graph given or graph analysis of the diagram failed.\";\n            }\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n\n            // ensures no cycles present for this layout\n            var reversedEdges = graph.makeAcyclic();\n\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n\n            this._prepare(graph, options);\n\n            this._dummify();\n\n            this._optimizeCrossings();\n\n            this._swapPairs();\n\n            this.arrangeNodes();\n\n            this._moveThingsAround();\n\n            this._dedummify();\n\n            // re-reverse the links which were switched earlier\n            Utils.forEach(reversedEdges, function(e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        },\n\n        setMinDist: function(m, n, minDist) {\n            var l = m.layer;\n            var i = m.layerIndex;\n            this.minDistances[l][i] = minDist;\n        },\n\n        getMinDist: function(m, n) {\n            var dist = 0,\n                i1 = m.layerIndex,\n                i2 = n.layerIndex,\n                l = m.layer,\n                min = Math.min(i1, i2),\n                max = Math.max(i1, i2);\n            // use Sum()?\n            for (var k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        },\n\n        placeLeftToRight: function(leftClasses) {\n            var leftPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        },\n\n        placeRightToLeft: function(rightClasses) {\n            var rightPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        },\n\n        _getLeftWing: function() {\n            var leftWing = { value: null };\n            var result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        },\n\n        _getRightWing: function() {\n            var rightWing = { value: null };\n            var result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        },\n\n        computeClasses: function(wingPair, d) {\n            var currentWing = 0,\n                wing = wingPair.value = new Dictionary();\n\n            for (var l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n\n                var layer = this.layers[l];\n                for (var n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    var node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            var ndsinl = this._nodesInLink(node);\n                            for (var kk = 0; kk < ndsinl.length; kk++) {\n                                var vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n\n            var wings = [];\n            for (var i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function(node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n\n            return wings;\n        },\n        _isVerticalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n        },\n\n        _isHorizontalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n        },\n        _isIncreasingLayout: function() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n        },\n        _moveThingsAround: function() {\n            var i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer);\n            }\n\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                this.downNodes.set(node, []);\n                this.upNodes.set(node, []);\n            }, this);\n            Utils.forEach(this.graph.links, function(link) {\n                var origin = link.source;\n                var dest = link.target;\n                var down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    var currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n\n                    var currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n\n                        var downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            var pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            var i1 = currDown.layerIndex;\n                            var i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n\n\n            var leftClasses = this._getLeftWing();\n            var rightClasses = this._getRightWing();\n\n\n            var leftPos = this.placeLeftToRight(leftClasses);\n            var rightPos = this.placeRightToLeft(rightClasses);\n            var x = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n            });\n\n\n            var order = new Dictionary();\n            var placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                var sequenceStart = -1, sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            var directions = [1, -1];\n            Utils.forEach(directions, function(d) {\n                var start = d === 1 ? 0 : this.layers.length - 1;\n                for (var l = start; l >= 0 && l < this.layers.length; l += d) {\n                    var layer = this.layers[l];\n                    var virtualStartIndex = this._firstVirtualNode(layer);\n                    var virtualStart = null;\n                    var sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n\n                    while (virtualStart) {\n                        var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            var virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(l, d, order, placed);\n                }\n            }, this);\n\n\n            var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            var reachedFinalLayerIndex = function(k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            var layerIncrement = this._isIncreasingLayout() ? +1 : -1, offset = 0;\n\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer, ctx) {\n                var height = Number.MIN_VALUE;\n                for (var n = 0; n < layer.length; ++n) {\n                    var node = layer[n];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node.height);\n                    }\n                    else {\n                        height = Math.max(height, node.width);\n                    }\n                }\n                return height;\n            }\n\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                var height = maximumHeight(layer, this);\n\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n\n                offset += this.options.layerSeparation + height;\n            }\n        },\n\n        adjustDirections: function(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n\n            var prevBridge = null, prevBridgeTarget = null;\n            var layer = this.layers[l + d];\n            for (var n = 0; n < layer.length; ++n) {\n                var nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            var p = placed.get(prevBridgeTarget);\n                            var clayer = this.layers[l];\n                            var i1 = prevBridgeTarget.layerIndex;\n                            var i2 = nextBridgeTarget.layerIndex;\n                            for (var i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                var j1 = prevBridge.layerIndex;\n                                var j2 = nextBridge.layerIndex;\n                                for (var j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        },\n\n        getNeighborOnLayer: function(node, l) {\n            var neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        },\n\n        _sequencer: function(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n\n            if (sequence.length > 1) {\n                var r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        },\n\n        _sequenceSingle: function(x, virtualStart, virtualEnd, dir, node) {\n            var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n\n            var n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        },\n\n        combineSequences: function(x, virtualStart, virtualEnd, dir, sequence) {\n            var r = sequence.length, t = this.intDiv(r, 2);\n\n            // collect left changes\n            var leftHeap = [], i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer);\n\n            // collect right changes\n            var rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer);\n\n            var leftRes = 0, rightRes = 0;\n            var m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        },\n\n        placeLeft: function(node, leftPos, leftClass) {\n            var pos = Number.NEGATIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                leftPos.set(v, pos);\n            });\n        },\n\n        placeRight: function(node, rightPos, rightClass) {\n            var pos = Number.POSITIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                rightPos.set(v, pos);\n            });\n        },\n\n        leftSibling: function(node) {\n            var layer = this.layers[node.layer],\n                layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        },\n\n        rightSibling: function(node) {\n            var layer = this.layers[node.layer];\n            var layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n\n        },\n\n        _getComposite: function(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        },\n\n        arrangeNodes: function() {\n            var i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n\n            var maxLayoutIterations = 2;\n            for (var it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n\n            // Offset the whole structure so that there are no gridPositions < 0\n            var gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // list containing the nodes in the considered layer sorted by priority\n            var sorted = [];\n            for (var n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function(n1, n2) {\n                var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n\n            // each node strives for its barycenter; high priority nodes start first\n            Utils.forEach(sorted, function(node) {\n                var nodeGridPos = node.gridPosition;\n                var nodeBaryCenter = this.calcBaryCenter(node);\n                var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        },\n\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            var rightNode = layer[index + 1];\n            var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            var leftNode = layer[index - 1];\n            var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        mapVirtualNode: function(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        },\n\n        _nodesInLink: function(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        },\n\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify: function() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n\n            var layer, pos, newNode, node, r, newLink, i, l, links = this.graph.links.slice(0);\n            var layers = this.layers;\n\n            var addLinkBetweenLayers = function(upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n\n            for (l = 0; l < links.length; l++) {\n                var link = links[l];\n                var o = link.source;\n                var d = link.target;\n\n                var oLayer = o.layer;\n                var dLayer = d.layer;\n                var oPos = o.gridPosition;\n                var dPos = d.gridPosition;\n\n                var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n\n                var p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                } else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        pos &= pos; // truncates to int\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                } else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        },\n\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify: function() {\n            var dedum = true;\n            while (dedum) {\n                dedum = false;\n\n                for (var l = 0; l < this.graph.links.length; l++) {\n                    var link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n\n                    var points = [];\n\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n\n                    // _dedummify the link\n                    var temp = link;\n                    var depthOfDumminess = link.depthOfDumminess;\n                    for (var d = 0; d < depthOfDumminess; d++) {\n                        var node = temp.source;\n                        var prevLink = node.incoming[0];\n\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n\n                        temp = prevLink;\n                    }\n\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n\n                    dedum = true;\n                    break;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings: function() {\n            var moves = -1, i;\n            var maxIterations = 3;\n            var iter = 0;\n\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                moves = 0;\n\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        },\n\n        calcUpData: function(layer) {\n            if (layer === 0) {\n                return;\n            }\n\n            var considered = this.layers[layer], i, l, link;\n            var upLayer = new Set();\n            var temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        },\n\n        calcDownData: function(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n\n            var considered = this.layers[layer], i , l, link;\n            var downLayer = new Set();\n            var temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // remember what it was\n            var presorted = considered.slice(0);\n\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n\n            var that = this;\n            // sort nodes within this layer according to the barycenters\n            considered.sort(function(n1, n2) {\n                var n1BaryCenter = that.calcBaryCenter(n1),\n                    n2BaryCenter = that.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return that.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return that.compareByIndex(n1, n2);\n            });\n\n            // count relocations\n            var i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                var inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    var node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n\n            return moves;\n        },\n\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs: function() {\n            var maxIterations = this.options.layeredIterations;\n            var iter = 0;\n\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                var downwards = (iter % 4 <= 1);\n                var secondPass = (iter % 4 === 1);\n\n                for (var l = (downwards ? 0 : this.layers.length - 1);\n                     downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    var layer = this.layers[l];\n                    var hasSwapped = false;\n\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    var calcCrossings = true;\n                    var memCrossings = 0;\n\n                    for (var n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        var up = 0;\n                        var down = 0;\n                        var crossBefore = 0;\n\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n\n                        // Swap nodes\n                        var node1 = layer[n];\n                        var node2 = layer[n + 1];\n\n                        var node1GridPos = node1.gridPosition;\n                        var node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        var crossAfter = up + down;\n\n                        var revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers: function(ulayer, dlayer) {\n            var links = this.layers[ulayer].linksTo[dlayer];\n            var link1, link2, n11, n12, n21, n22, l1, l2;\n            var crossings = 0;\n            var length = links.length;\n\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n\n                    link2 = links[l2];\n\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n\n                    var n11gp = n11.gridPosition;\n                    var n12gp = n12.gridPosition;\n                    var n21gp = n21.gridPosition;\n                    var n22gp = n22.gridPosition;\n\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n\n            return crossings;\n        },\n\n        calcBaryCenter: function(node) {\n            var upstreamLinkCount = node.upstreamLinkCount;\n            var downstreamLinkCount = node.downstreamLinkCount;\n            var uBaryCenter = node.uBaryCenter;\n            var dBaryCenter = node.dBaryCenter;\n\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n\n            return 0;\n        },\n\n        _gridPositionComparer: function(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        },\n\n        _positionAscendingComparer: function(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        },\n\n        _positionDescendingComparer: function(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        },\n\n        _firstVirtualNode: function(layer) {\n            for (var c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        },\n\n        compareByIndex: function(o1, o2) {\n            var i1 = o1.index;\n            var i2 = o2.index;\n\n            if (i1 < i2) {\n                return 1;\n            }\n\n            if (i1 > i2) {\n                return -1;\n            }\n\n            return 0;\n        },\n\n        intDiv: function(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        },\n\n        nextVirtualNode: function(layer, node) {\n            var nodeIndex = node.layerIndex;\n            for (var i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n\n    });\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     * @type {*}\n     */\n    var LayoutState = kendo.Class.extend({\n        init: function(diagram, graphOrNodes) {\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram given\";\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        },\n\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         * @param diagramOrGraphOrNodes\n         */\n        capture: function(diagramOrGraphOrNodes) {\n            var node,\n                nodes,\n                shape,\n                i,\n                conn,\n                link,\n                links;\n\n            if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                var shapes = this.diagram.shapes;\n                var connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    });\n\n    deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n        SpringLayout: SpringLayout,\n        TreeLayout: TreeLayout,\n        GraphAdapter: DiagramToHyperTreeAdapter,\n        LayeredLayout: LayeredLayout,\n        LayoutBase: LayoutBase,\n        LayoutState: LayoutState\n    });\n})(window.kendo.jQuery);\n\n(function($, undefined$1) {\n        // Imports ================================================================\n        var dataviz = kendo.dataviz,\n            draw = kendo.drawing,\n            geom = kendo.geometry,\n            diagram = dataviz.diagram,\n            Widget = kendo.ui.Widget,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            outerWidth = kendo._outerWidth,\n            outerHeight = kendo._outerHeight,\n            extend = $.extend,\n            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n            Canvas = diagram.Canvas,\n            Group = diagram.Group,\n            Rectangle = diagram.Rectangle,\n            Circle = diagram.Circle,\n            CompositeTransform = diagram.CompositeTransform,\n            Rect = diagram.Rect,\n            Path = diagram.Path,\n            DeleteShapeUnit = diagram.DeleteShapeUnit,\n            DeleteConnectionUnit = diagram.DeleteConnectionUnit,\n            TextBlock = diagram.TextBlock,\n            Image = diagram.Image,\n            Point = diagram.Point,\n            Intersect = diagram.Intersect,\n            ConnectionEditAdorner = diagram.ConnectionEditAdorner,\n            UndoRedoService = diagram.UndoRedoService,\n            ToolService = diagram.ToolService,\n            Selector = diagram.Selector,\n            ResizingAdorner = diagram.ResizingAdorner,\n            ConnectorsAdorner = diagram.ConnectorsAdorner,\n            Cursors = diagram.Cursors,\n            Utils = diagram.Utils,\n            Observable = kendo.Observable,\n            ToBackUnit = diagram.ToBackUnit,\n            ToFrontUnit = diagram.ToFrontUnit,\n            PolylineRouter = diagram.PolylineRouter,\n            CascadingRouter = diagram.CascadingRouter,\n            isUndefined = Utils.isUndefined,\n            isDefined = Utils.isDefined,\n            defined = draw.util.defined,\n            isArray = Array.isArray,\n            isFunction = kendo.isFunction,\n            isString = Utils.isString,\n            isPlainObject = $.isPlainObject,\n\n            math = Math;\n\n        // Constants ==============================================================\n        var NS = \".kendoDiagram\",\n            CASCADING = \"cascading\",\n            ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n            CHANGE = \"change\",\n            CLICK = \"click\",\n            DRAG = \"drag\",\n            DRAG_END = \"dragEnd\",\n            DRAG_START = \"dragStart\",\n            MOUSE_ENTER = \"mouseEnter\",\n            MOUSE_LEAVE = \"mouseLeave\",\n            ERROR = \"error\",\n            AUTO = \"Auto\",\n            TOP = \"Top\",\n            RIGHT = \"Right\",\n            LEFT = \"Left\",\n            BOTTOM = \"Bottom\",\n            MAXINT = 9007199254740992,\n            SELECT = \"select\",\n            ITEMROTATE = \"itemRotate\",\n            PAN = \"pan\",\n            ZOOM_START = \"zoomStart\",\n            ZOOM_END = \"zoomEnd\",\n            NONE = \"none\",\n            DEFAULT_CANVAS_WIDTH = 600,\n            DEFAULT_CANVAS_HEIGHT = 600,\n            DEFAULT_SHAPE_TYPE = \"rectangle\",\n            DEFAULT_SHAPE_WIDTH = 100,\n            DEFAULT_SHAPE_HEIGHT = 100,\n            DEFAULT_SHAPE_MINWIDTH = 20,\n            DEFAULT_SHAPE_MINHEIGHT = 20,\n            DEFAULT_SHAPE_POSITION = 0,\n            DEFAULT_CONNECTION_BACKGROUND = \"Yellow\",\n            MAX_VALUE = Number.MAX_VALUE,\n            MIN_VALUE = -Number.MAX_VALUE,\n            ABSOLUTE = \"absolute\",\n            TRANSFORMED = \"transformed\",\n            ROTATED = \"rotated\",\n            TRANSPARENT = \"transparent\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            X = \"x\",\n            Y = \"y\",\n            MOUSEWHEEL_NS = \"DOMMouseScroll\" + NS + \" mousewheel\" + NS,\n            MOBILE_ZOOM_RATE = 0.05,\n            MOBILE_PAN_DISTANCE = 5,\n            BUTTON_TEMPLATE = ({ className, icon, themeColor, text }) =>\n                kendo.html.renderButton(`<button class=\"${className}\" href=\"#\">${text}</button>`, {\n                    icon: icon,\n                    themeColor\n                }),\n            CONNECTION_CONTENT_OFFSET = 5;\n\n        diagram.DefaultConnectors = [{\n            name: TOP\n        }, {\n            name: BOTTOM\n        }, {\n            name: LEFT\n        }, {\n            name: RIGHT\n        }, {\n            name: AUTO,\n            position: function(shape) {\n                return shape.getPosition(\"center\");\n            }\n        }];\n\n        var defaultButtons = {\n            cancel: {\n                text: \"Cancel\",\n                icon: \"cancel-outline\",\n                className: \"k-diagram-cancel\",\n            },\n            update: {\n                text: \"Save\",\n                imageClass: \"save\",\n                className: \"k-diagram-update\",\n                icon: \"save\",\n                themeColor: \"primary\"\n            }\n        };\n\n        diagram.shapeDefaults = function(extra) {\n            var defaults = {\n                type: DEFAULT_SHAPE_TYPE,\n                path: \"\",\n                autoSize: true,\n                visual: null,\n                x: DEFAULT_SHAPE_POSITION,\n                y: DEFAULT_SHAPE_POSITION,\n                minWidth: DEFAULT_SHAPE_MINWIDTH,\n                minHeight: DEFAULT_SHAPE_MINHEIGHT,\n                width: DEFAULT_SHAPE_WIDTH,\n                height: DEFAULT_SHAPE_HEIGHT,\n                hover: {},\n                editable: {\n                    connect: true,\n                    tools: []\n                },\n                connectors: diagram.DefaultConnectors,\n                rotation: {\n                    angle: 0\n                }\n            };\n\n            Utils.simpleExtend(defaults, extra);\n\n            return defaults;\n        };\n\n        function mwDelta(e) {\n            var origEvent = e.originalEvent,\n                delta = 0;\n\n            if (origEvent.wheelDelta) {\n                delta = -origEvent.wheelDelta / 40;\n                delta = delta > 0 ? math.ceil(delta) : math.floor(delta);\n            } else if (origEvent.detail) {\n                delta = origEvent.detail;\n            }\n\n            return delta;\n        }\n\n        function isAutoConnector(connector) {\n            return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n        }\n\n        function closestConnector(point, connectors) {\n            var minimumDistance = MAXINT, resCtr, connector;\n            for (var i = 0; i < connectors.length; i++) {\n                connector = connectors[i];\n                if (!isAutoConnector(connector)) {\n                    var dist = point.distanceTo(connector.position());\n                    if (dist < minimumDistance) {\n                        minimumDistance = dist;\n                        resCtr = connector;\n                    }\n                }\n            }\n            return resCtr;\n        }\n\n        function indicesOfItems(group, visuals) {\n            var i, indices = [], visual;\n            var children = group.drawingContainer().children;\n            var length = children.length;\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                for (var j = 0; j < length; j++) {\n                    if (children[j] == visual.drawingContainer()) {\n                        indices.push(j);\n                        break;\n                    }\n                }\n            }\n            return indices;\n        }\n\n        var DiagramElement = Observable.extend({\n            init: function(options) {\n                var that = this;\n                that.dataItem = (options || {}).dataItem;\n                Observable.fn.init.call(that);\n                that.options = deepExtend({ id: diagram.randomId() }, that.options, options);\n                that.isSelected = false;\n                that.visual = new Group({\n                    id: that.options.id,\n                    autoSize: that.options.autoSize\n                });\n                that.id = that.options.id;\n                that._template();\n            },\n\n            options: {\n                hover: {},\n                cursor: Cursors.grip,\n                content: {\n                    align: \"center middle\"\n                },\n                selectable: true,\n                serializable: true,\n                enable: true\n            },\n\n            _getCursor: function(point) {\n                if (this.adorner) {\n                    return this.adorner._getCursor(point);\n                }\n                return this.options.cursor;\n            },\n\n            visible: function(value) {\n                if (isUndefined(value)) {\n                    return this.visual.visible();\n                } else {\n                    this.visual.visible(value);\n                }\n            },\n\n            bounds: function() {\n            },\n\n            refresh: function() {\n                this.visual.redraw();\n            },\n\n            position: function(point) {\n                this.options.x = point.x;\n                this.options.y = point.y;\n                this.visual.position(point);\n            },\n\n            toString: function() {\n                return this.options.id;\n            },\n\n            serialize: function() {\n                // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n                var json = deepExtend({}, { options: this.options });\n                if (this.dataItem) {\n                    json.dataItem = this.dataItem.toString();\n                }\n                return json;\n            },\n\n            _content: function(content) {\n                if (content !== undefined$1) {\n                    var options = this.options;\n\n                    if (diagram.Utils.isString(content)) {\n                        options.content.text = content;\n                    } else {\n                        deepExtend(options.content, content);\n                    }\n\n                    var contentOptions = options.content;\n                    var contentVisual = this._contentVisual;\n\n                    if (!contentVisual) {\n                        this._createContentVisual(contentOptions);\n                    } else {\n                        this._updateContentVisual(contentOptions);\n                    }\n                }\n\n                return this.options.content.text;\n            },\n\n            _createContentVisual: function(options) {\n                if (options.text) {\n                    this._contentVisual = new TextBlock(options);\n                    this._contentVisual._includeInBBox = false;\n                    this.visual.append(this._contentVisual);\n                }\n            },\n\n            _updateContentVisual: function(options) {\n                this._contentVisual.redraw(options);\n            },\n\n            _hitTest: function(point) {\n                var bounds = this.bounds();\n                return this.visible() && bounds.contains(point) && this.options.enable;\n            },\n\n            _template: function() {\n                var that = this;\n                if (that.options.content.template) {\n                    var data = that.dataItem || {},\n                        elementTemplate = kendo.template(that.options.content.template, {\n                            paramName: \"dataItem\"\n                        });\n\n                    that.options.content.text = elementTemplate(data);\n                }\n            },\n\n            _canSelect: function() {\n                return this.options.selectable !== false;\n            },\n\n            toJSON: function() {\n                return {\n                    id: this.options.id\n                };\n            }\n        });\n\n        var Connector = Class.extend({\n            init: function(shape, options) {\n                this.options = deepExtend({}, this.options, options);\n                this.connections = [];\n                this.shape = shape;\n            },\n            options: {\n                width: 7,\n                height: 7,\n                fill: {\n                    color: DEFAULT_CONNECTION_BACKGROUND\n                },\n                hover: {}\n            },\n            position: function() {\n                if (this.options.position) {\n                    return this.options.position(this.shape);\n                } else {\n                    return this.shape.getPosition(this.options.name);\n                }\n            },\n            toJSON: function() {\n                return {\n                    shapeId: this.shape.toString(),\n                    connector: this.options.name\n                };\n            }\n        });\n\n        Connector.parse = function(diagram, str) {\n            var tempStr = str.split(\":\"),\n                id = tempStr[0],\n                name = tempStr[1] || AUTO;\n\n            for (var i = 0; i < diagram.shapes.length; i++) {\n                var shape = diagram.shapes[i];\n                if (shape.options.id == id) {\n                    return shape.getConnector(name.trim());\n                }\n            }\n        };\n\n        var Shape = DiagramElement.extend({\n            init: function(options, diagram) {\n                var that = this;\n                DiagramElement.fn.init.call(that, options);\n                this.diagram = diagram;\n                this.updateOptionsFromModel();\n                options = that.options;\n                that.connectors = [];\n                that.type = options.type;\n                that.createShapeVisual();\n                that.updateBounds();\n                that.content(that.content());\n\n                that._createConnectors();\n            },\n\n            options: diagram.shapeDefaults(),\n\n            _setOptionsFromModel: function(model) {\n                var modelOptions = filterShapeDataItem(model || this.dataItem);\n                this.options = deepExtend({}, this.options, modelOptions);\n\n                this.redrawVisual();\n            },\n\n            updateOptionsFromModel: function(model, field) {\n                if (this.diagram && this.diagram._isEditable) {\n                    var modelOptions = filterShapeDataItem(model || this.dataItem);\n\n                    if (model && field) {\n                        if (!dataviz.inArray(field, [\"x\", \"y\", \"width\", \"height\"])) {\n                            if (this.options.visual) {\n                                this._redrawVisual();\n                            } else if (modelOptions.type) {\n                                this.options = deepExtend({}, this.options, modelOptions);\n                                this._redrawVisual();\n                            }\n\n                            if (this.options.content) {\n                                this._template();\n                                this.content(this.options.content);\n                            }\n                        } else {\n                            var bounds = this.bounds();\n                            bounds[field] = model[field];\n                            this.bounds(bounds);\n                        }\n                    } else {\n                        this.options = deepExtend({}, this.options, modelOptions);\n                    }\n                }\n            },\n\n            _redrawVisual: function() {\n                this.visual.clear();\n                this._contentVisual = null;\n                this.options.dataItem = this.dataItem;\n                this.createShapeVisual();\n                this.updateBounds();\n            },\n\n            redrawVisual: function() {\n                this._redrawVisual();\n                if (this.options.content) {\n                    this._template();\n                    this.content(this.options.content);\n                }\n            },\n\n            updateModel: function(syncChanges) {\n                var diagram = this.diagram;\n                if (diagram && diagram._isEditable) {\n                    var bounds = this._bounds;\n                    var model = this.dataItem;\n\n                    if (model) {\n                        diagram._suspendModelRefresh();\n                        if (defined(model.x) && bounds.x !== model.x) {\n                            model.set(\"x\", bounds.x);\n                        }\n\n                        if (defined(model.y) && bounds.y !== model.y) {\n                            model.set(\"y\", bounds.y);\n                        }\n\n                        if (defined(model.width) && bounds.width !== model.width) {\n                            model.set(\"width\", bounds.width);\n                        }\n\n                        if (defined(model.height) && bounds.height !== model.height) {\n                            model.set(\"height\", bounds.height);\n                        }\n\n                        this.dataItem = model;\n                        diagram._resumeModelRefresh();\n\n                        if (syncChanges) {\n                            diagram._syncShapeChanges();\n                        }\n                    }\n                }\n            },\n\n            updateBounds: function() {\n                var bounds = this.visual._measure(true);\n                var options = this.options;\n                this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n                this._rotate();\n                this._alignContent();\n            },\n\n            content: function(content) {\n                var result = this._content(content);\n\n                this._alignContent();\n\n                return result;\n            },\n\n            _alignContent: function() {\n                var contentOptions = this.options.content || {};\n                var contentVisual = this._contentVisual;\n                if (contentVisual && contentOptions.align) {\n                    var containerRect = this.visual._measure();\n                    var aligner = new diagram.RectAlign(containerRect);\n                    var contentBounds = contentVisual.drawingElement.bbox(null);\n\n                    var contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                    var alignedBounds = aligner.align(contentRect, contentOptions.align);\n\n                    contentVisual.position(alignedBounds.topLeft());\n                }\n            },\n\n            _createConnectors: function() {\n                var options = this.options,\n                    length = options.connectors.length,\n                    connectorDefaults = options.connectorDefaults,\n                    connector, i;\n\n                for (i = 0; i < length; i++) {\n                    connector = new Connector(\n                        this, deepExtend({},\n                            connectorDefaults,\n                            options.connectors[i]\n                        )\n                    );\n                    this.connectors.push(connector);\n                }\n            },\n\n            bounds: function(value) {\n                var bounds;\n\n                if (value) {\n                    if (isString(value)) {\n                        switch (value) {\n                            case TRANSFORMED :\n                                bounds = this._transformedBounds();\n                                break;\n                            case ABSOLUTE :\n                                bounds = this._transformedBounds();\n                                var pan = this.diagram._pan;\n                                bounds.x += pan.x;\n                                bounds.y += pan.y;\n                                break;\n                            case ROTATED :\n                                bounds = this._rotatedBounds();\n                                break;\n                            default:\n                                bounds = this._bounds;\n                        }\n                    } else {\n                        this._setBounds(value);\n                        this._triggerBoundsChange();\n                        if (!(this.diagram && this.diagram._layouting)) {\n                            this.refreshConnections();\n                        }\n                    }\n                } else {\n                    bounds = this._bounds;\n                }\n\n                return bounds;\n            },\n\n            _setBounds: function(rect) {\n                var options = this.options;\n                var topLeft = rect.topLeft();\n                var x = options.x = topLeft.x;\n                var y = options.y = topLeft.y;\n                var width = options.width = math.max(rect.width, options.minWidth);\n                var height = options.height = math.max(rect.height, options.minHeight);\n\n                this._bounds = new Rect(x, y, width, height);\n\n                this.visual.redraw({\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            },\n\n            position: function(point) {\n                if (point) {\n                    this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n                } else {\n                    return this._bounds.topLeft();\n                }\n            },\n            /**\n             * Returns a clone of this shape.\n             * @returns {Shape}\n             */\n            clone: function() {\n                var json = this.serialize();\n\n                json.options.id = diagram.randomId();\n\n                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                    json.options.dataItem = cloneDataItem(this.dataItem);\n                }\n\n                return new Shape(json.options);\n            },\n\n            select: function(value) {\n                var diagram = this.diagram, selected, deselected;\n                if (isUndefined(value)) {\n                    value = true;\n                }\n\n                if (this._canSelect()) {\n                    if (this.isSelected != value) {\n                        selected = [];\n                        deselected = [];\n                        this.isSelected = value;\n                        if (this.isSelected) {\n                            diagram._selectedItems.push(this);\n                            selected.push(this);\n                        } else {\n                            Utils.remove(diagram._selectedItems, this);\n                            deselected.push(this);\n                        }\n\n                        if (!diagram._internalSelection) {\n                            diagram._selectionChanged(selected, deselected);\n                        }\n\n                        return true;\n                    }\n                }\n            },\n\n            rotate: function(angle, center, undoable) { // we assume the center is always the center of the shape.\n                var rotate = this.visual.rotate();\n                if (angle !== undefined$1) {\n                    if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                        this.diagram.undoRedoService.add(\n                            new diagram.RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                    }\n\n                    var b = this.bounds(),\n                        sc = new Point(b.width / 2, b.height / 2),\n                        deltaAngle,\n                        newPosition;\n\n                    if (center) {\n                        deltaAngle = angle - rotate.angle;\n                        newPosition = b.center().rotate(deltaAngle, center).minus(sc);\n                        this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                        this.position(newPosition);\n                    }\n\n                    this.visual.rotate(angle, sc);\n                    this.options.rotation.angle = angle;\n\n                    if (this.diagram && this.diagram._connectorsAdorner) {\n                        this.diagram._connectorsAdorner.refresh();\n                    }\n\n                    this.refreshConnections();\n\n                    if (this.diagram) {\n                        this.diagram.trigger(ITEMROTATE, { item: this });\n                    }\n                }\n\n                return rotate;\n            },\n\n            connections: function(type) { // in, out, undefined = both\n                var result = [], i, j, con, cons, ctr;\n\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    cons = ctr.connections;\n                    for (j = 0, cons; j < cons.length; j++) {\n                        con = cons[j];\n                        if (type == \"out\") {\n                            var source = con.source();\n                            if (source.shape && source.shape == this) {\n                                result.push(con);\n                            }\n                        } else if (type == \"in\") {\n                            var target = con.target();\n                            if (target.shape && target.shape == this) {\n                                result.push(con);\n                            }\n                        } else {\n                            result.push(con);\n                        }\n                    }\n                }\n\n                return result;\n            },\n\n            refreshConnections: function() {\n                $.each(this.connections(), function() {\n                    this.refresh();\n                });\n            },\n            /**\n             * Gets a connector of this shape either by the connector's supposed name or\n             * via a Point in which case the closest connector will be returned.\n             * @param nameOrPoint The name of a Connector or a Point.\n             * @returns {Connector}\n             */\n            getConnector: function(nameOrPoint) {\n                var i, ctr;\n                if (isString(nameOrPoint)) {\n                    nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                    for (i = 0; i < this.connectors.length; i++) {\n                        ctr = this.connectors[i];\n                        if (ctr.options.name.toLocaleLowerCase() == nameOrPoint) {\n                            return ctr;\n                        }\n                    }\n                } else if (nameOrPoint instanceof Point) {\n                    return closestConnector(nameOrPoint, this.connectors);\n                } else {\n                    return this.connectors.length ? this.connectors[0] : null;\n                }\n            },\n\n            getPosition: function(side) {\n                var b = this.bounds(),\n                    fnName = side.charAt(0).toLowerCase() + side.slice(1);\n\n                if (isFunction(b[fnName])) {\n                    return this._transformPoint(b[fnName]());\n                }\n\n                return b.center();\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var shapeOptions = this.options;\n                    var boundsChange;\n\n                    this.shapeVisual.redraw(this._visualOptions(options));\n\n                    if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                        this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                        boundsChange = true;\n                    }\n\n                    if (options.connectors) {\n                        shapeOptions.connectors = options.connectors;\n                        this._updateConnectors();\n                    }\n\n                    shapeOptions = deepExtend(shapeOptions, options);\n\n                    if (options.rotation || boundsChange) {\n                        this._rotate();\n                    }\n\n                    if (shapeOptions.content) {\n                        this.content(shapeOptions.content);\n                    }\n                }\n            },\n\n            _updateConnectors: function() {\n                var connections = this.connections();\n                this.connectors = [];\n                this._createConnectors();\n                var connection;\n                var source;\n                var target;\n\n                for (var idx = 0; idx < connections.length; idx++) {\n                    connection = connections[idx];\n                    source = connection.source();\n                    target = connection.target();\n                    if (source.shape && source.shape === this) {\n                        connection.source(this.getConnector(source.options.name) || null);\n                    } else if (target.shape && target.shape === this) {\n                        connection.target(this.getConnector(target.options.name) || null);\n                    }\n                    connection.updateModel();\n                }\n            },\n\n            _diffNumericOptions: diagram.diffNumericOptions,\n\n            _visualOptions: function(options) {\n                return {\n                    data: options.path,\n                    source: options.source,\n                    hover: options.hover,\n                    fill: options.fill,\n                    stroke: options.stroke\n                };\n            },\n\n            _triggerBoundsChange: function() {\n                if (this.diagram) {\n                    this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n                }\n            },\n\n            _transformPoint: function(point) {\n                var rotate = this.rotate(),\n                    bounds = this.bounds(),\n                    tl = bounds.topLeft();\n\n                if (rotate.angle) {\n                    point.rotate(rotate.angle, rotate.center().plus(tl));\n                }\n\n                return point;\n            },\n\n            _transformedBounds: function() {\n                var bounds = this.bounds(),\n                    tl = bounds.topLeft(),\n                    br = bounds.bottomRight();\n\n                return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n            },\n\n            _rotatedBounds: function() {\n                var bounds = this.bounds().rotatedBounds(this.rotate().angle),\n                    tl = bounds.topLeft(),\n                    br = bounds.bottomRight();\n\n                return Rect.fromPoints(tl, br);\n            },\n\n            _rotate: function() {\n                var rotation = this.options.rotation;\n\n                if (rotation && rotation.angle) {\n                    this.rotate(rotation.angle);\n                }\n\n                this._rotationOffset = new Point();\n            },\n\n            _hover: function(value) {\n                var options = this.options,\n                    hover = options.hover,\n                    stroke = options.stroke,\n                    fill = options.fill;\n\n                if (value && isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n\n                if (value && isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n\n                this.shapeVisual.redraw({\n                    stroke: stroke,\n                    fill: fill\n                });\n\n                if (options.editable && options.editable.connect) {\n                    this.diagram._showConnectors(this, value);\n                }\n            },\n\n            _hitTest: function(value) {\n                if (this.visible()) {\n                    var bounds = this.bounds(), rotatedPoint,\n                        angle = this.rotate().angle;\n\n                    if (value.isEmpty && !value.isEmpty()) { // rect selection\n                        return Intersect.rects(value, bounds, angle ? angle : 0);\n                    } else { // point\n                        rotatedPoint = value.clone().rotate(angle, bounds.center()); // cloning is important because rotate modifies the point inline.\n                        if (bounds.contains(rotatedPoint)) {\n                            return this;\n                        }\n                    }\n                }\n            },\n\n            toJSON: function() {\n                return {\n                    shapeId: this.options.id\n                };\n            },\n\n            createShapeVisual: function() {\n                var options = this.options;\n                var visualOptions = this._visualOptions(options);\n                var visualTemplate = options.visual;\n                var type = (options.type + \"\").toLocaleLowerCase();\n                var shapeVisual;\n\n                visualOptions.width = options.width;\n                visualOptions.height = options.height;\n\n                if (isFunction(visualTemplate)) { // custom template\n                    shapeVisual = visualTemplate.call(this, options);\n                } else if (visualOptions.data) {\n                    shapeVisual = new Path(visualOptions);\n                    translateToOrigin(shapeVisual);\n                } else if (type == \"rectangle\") {\n                    shapeVisual = new Rectangle(visualOptions);\n                } else if (type == \"circle\") {\n                    shapeVisual = new Circle(visualOptions);\n                } else if (type == \"text\") {\n                    shapeVisual = new TextBlock(visualOptions);\n                } else if (type == \"image\") {\n                    shapeVisual = new Image(visualOptions);\n                } else {\n                    shapeVisual = new Path(visualOptions);\n                }\n\n                this.shapeVisual = shapeVisual;\n                this.visual.append(this.shapeVisual);\n            }\n        });\n\n        /**\n         * The visual link between two Shapes through the intermediate of Connectors.\n         */\n        var Connection = DiagramElement.extend({\n            init: function(from, to, options) {\n                var that = this;\n                DiagramElement.fn.init.call(that, options);\n                this.updateOptionsFromModel();\n                this._initRouter();\n                that.path = new diagram.Polyline(that.options);\n                that.path.fill(TRANSPARENT);\n                that.visual.append(that.path);\n                that._sourcePoint = that._targetPoint = new Point();\n                that._setSource(from);\n                that._setTarget(to);\n                that.content(that.options.content);\n                that.definers = [];\n                if (defined(options) && options.points) {\n                    that.points(options.points);\n                }\n            },\n\n            options: {\n                hover: {\n                    stroke: {}\n                },\n                startCap: NONE,\n                endCap: NONE,\n                points: [],\n                selectable: true,\n                fromConnector: AUTO,\n                toConnector: AUTO\n            },\n\n            _setOptionsFromModel: function(model) {\n                this.updateOptionsFromModel(model || this.dataItem);\n            },\n\n            updateOptionsFromModel: function(model) {\n                if (this.diagram && this.diagram._isEditable) {\n                    var dataMap = this.diagram._dataMap;\n                    var options = filterConnectionDataItem(model || this.dataItem);\n\n                    if (model) {\n                        if (defined(options.from)) {\n                            var from = dataMap[options.from];\n                            if (from && defined(options.fromConnector)) {\n                               from = from.getConnector(options.fromConnector);\n                            }\n                            this.source(from);\n                        } else if (defined(options.fromX) && defined(options.fromY)) {\n                            this.source(new Point(options.fromX, options.fromY));\n                        }\n\n                        if (defined(options.to)) {\n                            var to = dataMap[options.to];\n                            if (to && defined(options.toConnector)) {\n                                to = to.getConnector(options.toConnector);\n                            }\n                            this.target(to);\n                        } else if (defined(options.toX) && defined(options.toY)) {\n                            this.target(new Point(options.toX, options.toY));\n                        }\n\n                        if (defined(options.type) && this.type() !== options.type) {\n                            this.points([]);\n                            this.type(options.type);\n                        }\n\n                        this.dataItem = model;\n\n                        this._template();\n                        this.redraw(this.options);\n                    } else {\n                        this.options = deepExtend({}, options, this.options);\n                    }\n                }\n            },\n\n            updateModel: function(syncChanges) {\n                if (this.diagram && this.diagram._isEditable) {\n                    if (this.diagram.connectionsDataSource) {\n                        var model = this.diagram.connectionsDataSource.getByUid(this.dataItem.uid);\n\n                        if (model) {\n                            this.diagram._suspendModelRefresh();\n                            if (defined(this.options.fromX) && this.options.fromX !== null) {\n                                clearField(\"from\", model);\n                                clearField(\"fromConnector\", model);\n                                model.set(\"fromX\", this.options.fromX);\n                                model.set(\"fromY\", this.options.fromY);\n                            } else {\n                                model.set(\"from\", this.options.from);\n                                if (defined(model.fromConnector)) {\n                                    model.set(\"fromConnector\", this.sourceConnector ? this.sourceConnector.options.name : null);\n                                }\n                                clearField(\"fromX\", model);\n                                clearField(\"fromY\", model);\n                            }\n\n                            if (defined(this.options.toX) && this.options.toX !== null) {\n                                clearField(\"to\", model);\n                                clearField(\"toConnector\", model);\n                                model.set(\"toX\", this.options.toX);\n                                model.set(\"toY\", this.options.toY);\n                            } else {\n                                model.set(\"to\", this.options.to);\n                                if (defined(model.toConnector)) {\n                                    model.set(\"toConnector\", this.targetConnector ? this.targetConnector.options.name : null);\n                                }\n                                clearField(\"toX\", model);\n                                clearField(\"toY\", model);\n                            }\n\n                            if (defined(this.options.type) && defined(model.type)) {\n                                model.set(\"type\", this.options.type);\n                            }\n\n                            this.dataItem = model;\n                            this.diagram._resumeModelRefresh();\n\n                            if (syncChanges) {\n                                this.diagram._syncConnectionChanges();\n                            }\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Gets the Point where the source of the connection resides.\n             * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n             * If the endpoint is floating the location of the endpoint is returned.\n             */\n            sourcePoint: function() {\n                return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n            },\n\n            _setSource: function(source) {\n                var shapeSource = source instanceof Shape;\n                var defaultConnector = this.options.fromConnector || AUTO;\n                var dataItem;\n                if (shapeSource && !source.getConnector(defaultConnector)) {\n                    return;\n                }\n\n                if (source !== undefined$1) {\n                    this.from = source;\n                }\n\n                this._removeFromSourceConnector();\n\n                if (source === null) { // detach\n                    if (this.sourceConnector) {\n                        this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                        this._clearSourceConnector();\n                        this._setFromOptions(null, this._sourcePoint);\n                    }\n                } else if (source instanceof Connector) {\n                    dataItem = source.shape.dataItem;\n                    if (dataItem) {\n                        this._setFromOptions(dataItem.id);\n                    }\n                    this.sourceConnector = source;\n                    this.sourceConnector.connections.push(this);\n                } else if (source instanceof Point) {\n                    this._setFromOptions(null, source);\n                    this._sourcePoint = source;\n                    if (this.sourceConnector) {\n                        this._clearSourceConnector();\n                    }\n\n                } else if (shapeSource) {\n                    dataItem = source.dataItem;\n                    if (dataItem) {\n                        this._setFromOptions(dataItem.id);\n                    }\n\n                    this.sourceConnector = source.getConnector(defaultConnector);\n                    this.sourceConnector.connections.push(this);\n                }\n            },\n\n            source: function(source, undoable) {\n                if (isDefined(source)) {\n                    if (undoable && this.diagram) {\n                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, source));\n                    }\n                    this._setSource(source);\n                    this.refresh();\n                }\n                return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n            },\n\n            _setFromOptions: function(from, fromPoint) {\n                this.options.from = from;\n                if (fromPoint) {\n                    this.options.fromX = fromPoint.x;\n                    this.options.fromY = fromPoint.y;\n                } else {\n                    this.options.fromX = null;\n                    this.options.fromY = null;\n                }\n            },\n\n            /**\n             * Gets or sets the PathDefiner of the sourcePoint.\n             * The left part of this definer is always null since it defines the source tangent.\n             * @param value\n             * @returns {*}\n             */\n            sourceDefiner: function(value) {\n                if (value) {\n                    if (value instanceof diagram.PathDefiner) {\n                        value.left = null;\n                        this._sourceDefiner = value;\n                        this.source(value.point); // refresh implicit here\n                    } else {\n                        throw \"The sourceDefiner needs to be a PathDefiner.\";\n                    }\n                } else {\n                    if (!this._sourceDefiner) {\n                        this._sourceDefiner = new diagram.PathDefiner(this.sourcePoint(), null, null);\n                    }\n                    return this._sourceDefiner;\n                }\n            },\n\n            /**\n             * Gets  the Point where the target of the connection resides.\n             */\n            targetPoint: function() {\n                return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n            },\n\n            _setTarget: function(target) {\n                var shapeTarget = target instanceof Shape;\n                var defaultConnector = this.options.toConnector || AUTO;\n                var dataItem;\n\n                if (shapeTarget && !target.getConnector(defaultConnector)) {\n                    return;\n                }\n\n                if (target !== undefined$1) {\n                    this.to = target;\n                }\n\n                this._removeFromTargetConnector();\n\n                if (target === null) { // detach\n                    if (this.targetConnector) {\n                        this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                        this._clearTargetConnector();\n                        this._setToOptions(null, this._targetPoint);\n                    }\n                } else if (target instanceof Connector) {\n                    dataItem = target.shape.dataItem;\n                    if (dataItem) {\n                        this._setToOptions(dataItem.id);\n                    }\n                    this.targetConnector = target;\n                    this.targetConnector.connections.push(this);\n                } else if (target instanceof Point) {\n                    this._setToOptions(null, target);\n                    this._targetPoint = target;\n                    if (this.targetConnector) {\n                        this._clearTargetConnector();\n                    }\n                } else if (shapeTarget) {\n                    dataItem = target.dataItem;\n                    if (dataItem) {\n                        this._setToOptions(dataItem.id);\n                    }\n                    this.targetConnector = target.getConnector(defaultConnector);\n                    this.targetConnector.connections.push(this);\n                }\n            },\n\n            target: function(target, undoable) {\n                if (isDefined(target)) {\n                    if (undoable && this.diagram) {\n                        this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, undefined$1, target));\n                    }\n                    this._setTarget(target);\n\n                    this.refresh();\n                }\n                return this.targetConnector ? this.targetConnector : this._targetPoint;\n            },\n\n            _setToOptions: function(to, toPoint) {\n                this.options.to = to;\n                if (toPoint) {\n                    this.options.toX = toPoint.x;\n                    this.options.toY = toPoint.y;\n                } else {\n                    this.options.toX = null;\n                    this.options.toY = null;\n                }\n            },\n\n            /**\n             * Gets or sets the PathDefiner of the targetPoint.\n             * The right part of this definer is always null since it defines the target tangent.\n             * @param value\n             * @returns {*}\n             */\n            targetDefiner: function(value) {\n                if (value) {\n                    if (value instanceof diagram.PathDefiner) {\n                        value.right = null;\n                        this._targetDefiner = value;\n                        this.target(value.point); // refresh implicit here\n                    } else {\n                        throw \"The sourceDefiner needs to be a PathDefiner.\";\n                    }\n                } else {\n                    if (!this._targetDefiner) {\n                        this._targetDefiner = new diagram.PathDefiner(this.targetPoint(), null, null);\n                    }\n                    return this._targetDefiner;\n                }\n            },\n\n            _updateConnectors: function() {\n                this._updateConnector(this.source(), \"source\");\n                this._updateConnector(this.target(), \"target\");\n            },\n\n            _updateConnector: function(instance, name) {\n                var that = this;\n                var diagram = that.diagram;\n                if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                    var dataItem = instance.shape.dataItem;\n                    var connectorName = instance.options.name;\n                    var setNewTarget = function() {\n                        var shape = diagram._dataMap[dataItem.id];\n                        instance = shape.getConnector(connectorName);\n                        that[name](instance, false);\n                        that.updateModel();\n                    };\n                    if (diagram._dataMap[dataItem.id]) {\n                       setNewTarget();\n                    } else {\n                        var inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                        if (inactiveItem) {\n                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                        }\n                    }\n                } else {\n                    that[name](instance, false);\n                }\n            },\n\n            content: function(content) {\n                var result = this._content(content);\n                if (defined(content)) {\n                    this._alignContent();\n                }\n                return result;\n            },\n\n            _createContentVisual: function(options) {\n                var visual;\n                if (isFunction(options.visual)) {\n                    visual = options.visual.call(this, options);\n                } else if (options.text) {\n                    visual = new TextBlock(options);\n                }\n\n                if (visual) {\n                    this._contentVisual = visual;\n                    visual._includeInBBox = false;\n                    this.visual.append(visual);\n                }\n\n                return visual;\n            },\n\n            _updateContentVisual: function(options) {\n                if (isFunction(options.visual)) {\n                    this.visual.remove(this._contentVisual);\n                    this._createContentVisual(options);\n                } else {\n                    this._contentVisual.redraw(options);\n                }\n            },\n\n            _alignContent: function() {\n                if (this._contentVisual) {\n                    var offset = CONNECTION_CONTENT_OFFSET;\n                    var points = this.allPoints();\n                    var endIdx = math.floor(points.length / 2);\n                    var startIdx = endIdx - 1;\n\n                    while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                        startIdx--;\n                        endIdx++;\n                    }\n\n                    var endPoint = points[endIdx];\n                    var startPoint = points[startIdx];\n\n                    var boundingBox = this._contentVisual._measure();\n                    var width = boundingBox.width;\n                    var height = boundingBox.height;\n                    var alignToPath = points.length % 2 === 0;\n                    var distance = startPoint.distanceTo(endPoint);\n\n                    if (alignToPath && points.length > 2 && distance > 0 &&\n                        ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                        alignToPath = false;\n                        offset = 0;\n                    }\n\n                    var point;\n\n                    if (alignToPath) {\n                        var angle = draw.util.deg(math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                        point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n\n                        if (math.abs(angle) === 90) {\n                            point.x += offset;\n                            point.y -= height / 2;\n                        } else if (angle % 180 === 0) {\n                            point.x -= width / 2;\n                            point.y -= height + offset;\n                        } else if (angle < -90 || (0 < angle && angle < 90)) {\n                            point.y -= height;\n                        } else if (angle < 0 || angle > 90) {\n                            point.x -= width;\n                            point.y -= height;\n                        }\n                    } else {\n                        var midIdx = math.floor(points.length / 2);\n                        point = points[midIdx].clone();\n                        startPoint = points[midIdx - 1];\n                        endPoint = points[midIdx + 1];\n\n                        var offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                        var offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n\n                        point.x += offsetX;\n                        point.y += offsetY;\n                    }\n\n                    this._contentVisual.position(point);\n                }\n            },\n\n            /**\n             * Selects or unselects this connections.\n             * @param value True to select, false to unselect.\n             */\n            select: function(value) {\n                var diagram = this.diagram, selected, deselected;\n                if (this._canSelect()) {\n                    if (this.isSelected !== value) {\n                        this.isSelected = value;\n                        selected = [];\n                        deselected = [];\n                        if (this.isSelected) {\n                            this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                            diagram._adorn(this.adorner, true);\n                            diagram._selectedItems.push(this);\n                            selected.push(this);\n                        } else {\n                            if (this.adorner) {\n                                diagram._adorn(this.adorner, false);\n                                Utils.remove(diagram._selectedItems, this);\n                                this.adorner = undefined$1;\n                                deselected.push(this);\n                            }\n                        }\n\n                        if (this.adorner) {\n                            this.adorner.refresh();\n                        }\n\n                        if (!diagram._internalSelection) {\n                            diagram._selectionChanged(selected, deselected);\n                        }\n                        return true;\n                    }\n                }\n            },\n            /**\n             * Gets or sets the bounds of this connection.\n             * @param value A Rect object.\n             * @remark This is automatically set in the refresh().\n             * @returns {Rect}\n             */\n            bounds: function(value) {\n                if (value && !isString(value)) {\n                    this._bounds = value;\n                } else {\n                    return this._bounds;\n                }\n            },\n            /**\n             * Gets or sets the connection type (see ConnectionType enumeration).\n             * @param value A ConnectionType value.\n             * @returns {ConnectionType}\n             */\n            type: function(value) {\n                var options = this.options;\n                if (value) {\n                    if (value !== options.type) {\n                        options.type = value;\n                        this._initRouter();\n                        this.refresh();\n                    }\n                } else {\n                    return options.type;\n                }\n            },\n\n            _initRouter: function() {\n                var type = (this.options.type || \"\").toLowerCase();\n                if (type == CASCADING) {\n                    this._router = new CascadingRouter(this);\n                } else {\n                    this._router = new PolylineRouter(this);\n                }\n            },\n            /**\n             * Gets or sets the collection of *intermediate* points.\n             * The 'allPoints()' property will return all the points.\n             * The 'definers' property returns the definers of the intermediate points.\n             * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n             * @param value\n             */\n            points: function(value) {\n                if (value) {\n                    this.definers = [];\n                    for (var i = 0; i < value.length; i++) {\n                        var definition = value[i];\n                        if (definition instanceof diagram.Point) {\n                            this.definers.push(new diagram.PathDefiner(definition));\n                        } else if (definition.hasOwnProperty(\"x\") && definition.hasOwnProperty(\"y\")) { // e.g. Clipboard does not preserve the Point definition and tunred into an Object\n                            this.definers.push(new diagram.PathDefiner(new Point(definition.x, definition.y)));\n                        } else {\n                            throw \"A Connection point needs to be a Point or an object with x and y properties.\";\n                        }\n                    }\n\n                } else {\n                    var pts = [];\n                    if (isDefined(this.definers)) {\n                        for (var k = 0; k < this.definers.length; k++) {\n                            pts.push(this.definers[k].point);\n                        }\n                    }\n                    return pts;\n                }\n            },\n            /**\n             * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n             * @returns {Array}\n             */\n            allPoints: function() {\n                var pts = [this.sourcePoint()];\n                if (this.definers) {\n                    for (var k = 0; k < this.definers.length; k++) {\n                        pts.push(this.definers[k].point);\n                    }\n                }\n                pts.push(this.targetPoint());\n                return pts;\n            },\n\n            refresh: function() {\n                this._resolveConnectors();\n                this._refreshPath();\n                this._alignContent();\n\n                if (this.adorner) {\n                    this.adorner.refresh();\n                }\n            },\n\n            _resolveConnectors: function() {\n                var connection = this,\n                    sourcePoint, targetPoint,\n                    sourceConnectors, targetConnectors,\n                    source = connection.source(),\n                    target = connection.target();\n\n                if (source instanceof Point) {\n                    sourcePoint = source;\n                } else if (source instanceof Connector) {\n                    if (isAutoConnector(source)) {\n                        sourceConnectors = source.shape.connectors;\n                    } else {\n                        sourceConnectors = [source];\n                    }\n                }\n\n                if (target instanceof Point) {\n                    targetPoint = target;\n                } else if (target instanceof Connector) {\n                    if (isAutoConnector(target)) {\n                        targetConnectors = target.shape.connectors;\n                    } else {\n                        targetConnectors = [target];\n                    }\n                }\n\n                if (sourcePoint) {\n                    if (targetConnectors) {\n                        connection._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                    }\n                } else if (sourceConnectors) {\n                    if (targetPoint) {\n                        connection._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                    } else if (targetConnectors) {\n                        this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                    }\n                }\n            },\n\n            _resolveAutoConnectors: function(sourceConnectors, targetConnectors) {\n                var minNonConflict = MAXINT;\n                var minDist = MAXINT;\n                var minNonConflictSource, minNonConflictTarget;\n                var sourcePoint, targetPoint;\n                var minSource, minTarget;\n                var sourceConnector, targetConnector;\n                var sourceIdx, targetIdx;\n                var dist;\n\n                for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                    sourceConnector = sourceConnectors[sourceIdx];\n                    if (!isAutoConnector(sourceConnector)) {\n                        sourcePoint = sourceConnector.position();\n\n                        for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                            targetConnector = targetConnectors[targetIdx];\n                            if (!isAutoConnector(targetConnector)) {\n                                targetPoint = targetConnector.position();\n                                dist = math.round(sourcePoint.distanceTo(targetPoint));\n\n                                if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                    minNonConflict = dist;\n                                    minNonConflictSource = sourceConnector;\n                                    minNonConflictTarget = targetConnector;\n                                }\n\n                                if (dist < minDist) {\n                                    minSource = sourceConnector;\n                                    minTarget = targetConnector;\n                                    minDist = dist;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (minNonConflictSource) {\n                    minSource = minNonConflictSource;\n                    minTarget = minNonConflictTarget;\n                }\n\n                this._resolvedSourceConnector = minSource;\n                this._resolvedTargetConnector = minTarget;\n            },\n\n            _testRoutePoints: function(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n                var router = this._router;\n                var passRoute = true;\n                if (router instanceof CascadingRouter) {\n                    var points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector),\n                        start, end,\n                         rect, exclude;\n\n                    exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                    points.unshift(sourcePoint);\n                    points.push(targetPoint);\n\n\n                    for (var idx = 1; idx < points.length; idx++) {\n                        start = points[idx - 1];\n                        end = points[idx];\n                        rect = new Rect(math.min(start.x, end.x), math.min(start.y, end.y),\n                                        math.abs(start.x - end.x), math.abs(start.y - end.y));\n                        if (rect.width > 0) {\n                            rect.x++;\n                            rect.width -= 2;\n                        }\n                        if (rect.height > 0) {\n                            rect.y++;\n                            rect.height -= 2;\n                        }\n\n                        if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                            passRoute = false;\n                            break;\n                        }\n                    }\n                }\n                return passRoute;\n            },\n\n            _getRouteExclude: function(sourcePoint, targetPoint, sourceShape, targetShape) {\n                var exclude = [];\n                if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                    exclude.push(sourceShape);\n                }\n                if (this._isPointInsideShape(targetPoint, targetShape)) {\n                    exclude.push(targetShape);\n                }\n                return exclude;\n            },\n\n            _isPointInsideShape: function(point, shape) {\n                var bounds = shape.bounds(), rotatedPoint,\n                    angle = shape.rotate().angle,\n                    pointX, pointY,\n                    boundsX = bounds.x,\n                    boundsY = bounds.y;\n\n                rotatedPoint = point.clone().rotate(angle, bounds.center());\n                pointX = rotatedPoint.x;\n                pointY = rotatedPoint.y;\n                return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    this.options = deepExtend({}, this.options, options);\n\n                    var points = this.options.points;\n\n                    if (defined(points) && points.length > 0) {\n                        this.points(points);\n                        this._refreshPath();\n                    }\n\n                    if ((options && options.content) || options.text) {\n                        this.content(options.content);\n                    }\n\n                    this.path.redraw({\n                        fill: options.fill,\n                        stroke: options.stroke,\n                        startCap: options.startCap,\n                        endCap: options.endCap\n                    });\n                }\n            },\n            /**\n             * Returns a clone of this connection.\n             * @returns {Connection}\n             */\n            clone: function() {\n                var json = this.serialize();\n\n                if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                    json.options.dataItem = cloneDataItem(this.dataItem);\n                }\n\n                return new Connection(this.from, this.to, json.options);\n            },\n            /**\n             * Returns a serialized connection in json format. Consist of the options and the dataItem.\n             * @returns {Connection}\n             */\n            serialize: function() {\n                var from = this.from.toJSON ? this.from.toJSON : this.from.toString(),\n                    to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n\n                var json = deepExtend({}, {\n                    options: this.options,\n                    from: from,\n                    to: to\n                });\n\n                if (defined(this.dataItem)) {\n                    json.dataItem = this.dataItem.toString();\n                }\n\n                json.options.points = this.points();\n                return json;\n            },\n\n            /**\n             * Returns whether the given Point or Rect hits this connection.\n             * @param value\n             * @returns {Connection}\n             * @private\n             */\n            _hitTest: function(value) {\n                if (this.visible()) {\n                    var p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                    if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                        return this;\n                    }\n                    if (this._router.hitTest(p)) {\n                        return this;\n                    }\n                }\n            },\n\n            _hover: function(value) {\n                var color = (this.options.stroke || {}).color;\n\n                if (value && isDefined(this.options.hover.stroke.color)) {\n                    color = this.options.hover.stroke.color;\n                }\n\n                this.path.redraw({\n                    stroke: {\n                        color: color\n                    }\n                });\n            },\n\n            _refreshPath: function() {\n                if (!defined(this.path)) {\n                    return;\n                }\n                this._drawPath();\n                this.bounds(this._router.getBounds());\n            },\n\n            _drawPath: function() {\n                if (this._router) {\n                    this._router.route(); // sets the intermediate points\n                }\n                var source = this.sourcePoint();\n                var target = this.targetPoint();\n                var points = this.points();\n\n                this.path.redraw({\n                    points: [source].concat(points, [target])\n                });\n            },\n\n            _clearSourceConnector: function() {\n                this.sourceConnector = undefined$1;\n                this._resolvedSourceConnector = undefined$1;\n            },\n\n            _clearTargetConnector: function() {\n                this.targetConnector = undefined$1;\n                this._resolvedTargetConnector = undefined$1;\n            },\n\n            _removeFromSourceConnector: function() {\n                if (this.sourceConnector) {\n                    Utils.remove(this.sourceConnector.connections, this);\n                }\n            },\n\n            _removeFromTargetConnector: function() {\n                if (this.targetConnector) {\n                    Utils.remove(this.targetConnector.connections, this);\n                }\n            },\n\n            toJSON: function() {\n                var connection = this;\n                var from, to, point;\n                if (connection.from && connection.from.toJSON) {\n                    from = connection.from.toJSON();\n                } else {\n                    point = connection._sourcePoint;\n                    from = {\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n\n                if (connection.to && connection.to.toJSON) {\n                    to = connection.to.toJSON();\n                } else {\n                    point = connection._targetPoint;\n                    to = {\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n\n                return {\n                    from: from,\n                    to: to\n                };\n            }\n        });\n\n        var Diagram = Widget.extend({\n            init: function(element, userOptions) {\n                var that = this;\n\n                kendo.destroy(element);\n                Widget.fn.init.call(that, element, userOptions);\n\n                that._initTheme();\n\n                that._initElements();\n                that._extendLayoutOptions(that.options);\n                that._initDefaults(userOptions);\n                that._interactionDefaults();\n\n                that._initCanvas();\n\n                that.mainLayer = new Group({\n                    id: \"main-layer\"\n                });\n                that.canvas.append(that.mainLayer);\n\n                that._shapesQuadTree = new ShapesQuadTree(that);\n\n                that._pan = new Point();\n                that._adorners = [];\n                that.adornerLayer = new Group({\n                    id: \"adorner-layer\"\n                });\n                that.canvas.append(that.adornerLayer);\n\n                that._createHandlers();\n\n                that._initialize();\n\n                that._resizingAdorner = new ResizingAdorner(that, { editable: that.options.editable });\n                that._connectorsAdorner = new ConnectorsAdorner(that);\n\n                that._adorn(that._resizingAdorner, true);\n                that._adorn(that._connectorsAdorner, true);\n\n                that.selector = new Selector(that);\n                // TODO: We may consider using real Clipboard API once is supported by the standard.\n                that._clipboard = [];\n\n                that.pauseMouseHandlers = false;\n\n                that._fetchFreshData();\n\n                that._createGlobalToolBar();\n\n                that._createOptionElements();\n\n                that.zoom(that.options.zoom);\n\n                that.canvas.draw();\n            },\n\n            options: {\n                name: \"Diagram\",\n                theme: \"sass\",\n                layout: \"\",\n                zoomRate: 0.1,\n                zoom: 1,\n                zoomMin: 0,\n                zoomMax: 2,\n                dataSource: {},\n                draggable: true,\n                template: \"\",\n                autoBind: true,\n                editable: {\n                    rotate: {},\n                    resize: {},\n                    text: true,\n                    tools: [],\n                    drag: {\n                        snap: {\n                            size: 10,\n                            angle: 10\n                        }\n                    },\n                    remove: true\n                },\n                pannable: {},\n                selectable: {\n                    key: \"none\"\n                },\n                tooltip: { enabled: true, format: \"{0}\" },\n                copy: {\n                    enabled: true,\n                    offsetX: 20,\n                    offsetY: 20\n                },\n                shapeDefaults: diagram.shapeDefaults({ undoable: true }),\n                connectionDefaults: {\n                    editable: {\n                        tools: []\n                    },\n                    type: CASCADING\n                },\n                shapes: [],\n                connections: []\n            },\n\n            events: [\n                ZOOM_END,\n                ZOOM_START,\n                PAN, SELECT,\n                ITEMROTATE,\n                ITEMBOUNDSCHANGE,\n                CHANGE,\n                CLICK,\n                MOUSE_ENTER,\n                MOUSE_LEAVE,\n                \"toolBarClick\",\n                \"save\",\n                \"cancel\",\n                \"edit\",\n                \"remove\",\n                \"add\",\n                \"dataBound\",\n                DRAG_START,\n                DRAG,\n                DRAG_END\n            ],\n\n            items: function() {\n                return $();\n            },\n\n            _createGlobalToolBar: function() {\n                var editable = this.options.editable;\n                if (editable) {\n                    var tools = editable.tools;\n                    if (this._isEditable && tools !== false && (!tools || tools.length === 0)) {\n                        tools = [\"createShape\", \"undo\", \"redo\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                    }\n\n                    if (tools && tools.length) {\n                        this.toolBar = new DiagramToolBar(this, {\n                            tools: tools || {},\n                            click: this._toolBarClick.bind(this),\n                            modal: false\n                        });\n\n                        this.toolBar.element.css({\n                            textAlign: \"left\"\n                        });\n\n                        this.element.prepend(this.toolBar.element);\n                        this._resize();\n                    }\n                }\n            },\n\n            createShape: function() {\n                if ((this.editor && this.editor.end()) || !this.editor) {\n                    var dataSource = this.dataSource;\n                    var view = dataSource.view() || [];\n                    var index = view.length;\n                    var model = createModel(dataSource, {});\n                    var shape = this._createShape(model, {});\n\n                    if (!this.trigger(\"add\", { shape: shape })) {\n                        dataSource.insert(index, model);\n                        var inactiveItem = this._inactiveShapeItems.getByUid(model.uid);\n                        inactiveItem.element = shape;\n                        this.edit(shape);\n                    }\n                }\n            },\n\n            _createShape: function(dataItem, options) {\n                options = deepExtend({}, this.options.shapeDefaults, options);\n                options.dataItem = dataItem;\n                var shape = new Shape(options, this);\n                return shape;\n            },\n\n            createConnection: function() {\n                if (((this.editor && this.editor.end()) || !this.editor)) {\n                    var connectionsDataSource = this.connectionsDataSource;\n                    var view = connectionsDataSource.view() || [];\n                    var index = view.length;\n                    var model = createModel(connectionsDataSource, {});\n                    var connection = this._createConnection(model);\n                    if (!this.trigger(\"add\", { connection: connection })) {\n                        this._connectionsDataMap[model.uid] = connection;\n                        connectionsDataSource.insert(index, model);\n                        this.addConnection(connection, false);\n                        this.edit(connection);\n                    }\n                }\n            },\n\n            _createConnection: function(dataItem, source, target) {\n                var options = deepExtend({}, this.options.connectionDefaults);\n                options.dataItem = dataItem;\n\n                var connection = new Connection(source || new Point(), target || new Point(), options);\n\n                return connection;\n            },\n\n            editModel: function(dataItem, editorType) {\n                this.cancelEdit();\n                var editors, template;\n                var editable = this.options.editable;\n\n                if (editorType == \"shape\") {\n                    editors = editable.shapeEditors;\n                    template = editable.shapeTemplate;\n                } else if (editorType == \"connection\") {\n                    var connectionSelectorHandler = connectionSelector.bind(this);\n                    editors = deepExtend({}, { from: connectionSelectorHandler, to: connectionSelectorHandler }, editable.connectionEditors);\n                    template = editable.connectionTemplate;\n                } else {\n                    return;\n                }\n\n                this.editor = new PopupEditor(this.element, {\n                    update: this._update.bind(this),\n                    cancel: this._cancel.bind(this),\n                    model: dataItem,\n                    type: editorType,\n                    target: this,\n                    editors: editors,\n                    template: template\n                });\n\n                this.trigger(\"edit\", this._editArgs());\n            },\n\n            edit: function(item) {\n                if (item.dataItem) {\n                    var editorType = item instanceof Shape ? \"shape\" : \"connection\";\n                    this.editModel(item.dataItem, editorType);\n                }\n            },\n\n            cancelEdit: function() {\n                if (this.editor) {\n                    this._getEditDataSource().cancelChanges(this.editor.model);\n\n                    this._destroyEditor();\n                }\n            },\n\n            saveEdit: function() {\n                if (this.editor && this.editor.end() &&\n                    !this.trigger(\"save\", this._editArgs())) {\n                    this._getEditDataSource().sync();\n                }\n            },\n\n            _update: function() {\n                if (this.editor && this.editor.end() &&\n                    !this.trigger(\"save\", this._editArgs())) {\n                    this._getEditDataSource().sync();\n                    this._destroyEditor();\n                }\n            },\n\n            _cancel: function() {\n                if (this.editor && !this.trigger(\"cancel\", this._editArgs())) {\n                    var model = this.editor.model;\n                    this._getEditDataSource().cancelChanges(model);\n                    var element = this._connectionsDataMap[model.uid] || this._dataMap[model.id];\n                    if (element) {\n                        element._setOptionsFromModel(model);\n                    }\n                    this._destroyEditor();\n                }\n            },\n\n            _getEditDataSource: function() {\n                return this.editor.options.type === \"shape\" ? this.dataSource : this.connectionsDataSource;\n            },\n\n            _editArgs: function() {\n                var result = { container: this.editor.wrapper };\n                result[this.editor.options.type] = this.editor.model;\n                return result;\n            },\n\n            _destroyEditor: function() {\n                if (this.editor) {\n                    this.editor.close();\n                    this.editor = null;\n                }\n            },\n\n            _initElements: function() {\n                this.wrapper = this.element.empty()\n                    .css(\"position\", \"relative\")\n                    .attr(\"tabindex\", 0)\n                    .addClass(\"k-widget k-diagram\");\n\n                this.scrollable = $(\"<div />\").appendTo(this.element);\n            },\n\n            _initDefaults: function(userOptions) {\n                var options = this.options;\n                var editable = options.editable;\n                var shapeDefaults = options.shapeDefaults;\n                var connectionDefaults = options.connectionDefaults;\n                var userShapeDefaults = (userOptions || {}).shapeDefaults;\n                if (editable === false) {\n                    shapeDefaults.editable = false;\n                    connectionDefaults.editable = false;\n                } else {\n                    copyDefaultOptions(editable, shapeDefaults.editable, [\"drag\", \"remove\", \"connect\"]);\n                    copyDefaultOptions(editable, connectionDefaults.editable, [\"drag\", \"remove\"]);\n                }\n\n                if (userShapeDefaults && userShapeDefaults.connectors) {\n                    options.shapeDefaults.connectors = userShapeDefaults.connectors;\n                }\n            },\n\n            _interactionDefaults: function() {\n                var options = this.options;\n                var selectable = options.selectable;\n                var pannable = options.pannable;\n                var mobile = kendo.support.mobileOS;\n\n                if (selectable && !defined(selectable.multiple)) {\n                    options.selectable = deepExtend({\n                        multiple: mobile ? false : true\n                    }, options.selectable);\n                }\n\n                if (pannable && !defined(pannable.key)) {\n                    options.pannable = deepExtend({\n                        key: mobile ? \"none\" : \"ctrl\"\n                    }, options.pannable);\n                }\n            },\n\n            _initCanvas: function() {\n                var canvasContainer = $(\"<div class='k-layer'></div>\").appendTo(this.scrollable)[0];\n                var viewPort = this.viewport();\n                this.canvas = new Canvas(canvasContainer, {\n                    width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                    height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n                });\n            },\n\n            _createHandlers: function() {\n                var that = this;\n                var element = that.element;\n\n                element.on(MOUSEWHEEL_NS, that._wheel.bind(that))\n                .on(\"keydown\" + NS, that._keydown.bind(that));\n\n                that._userEvents = new kendo.UserEvents(this.scrollable, {\n                    multiTouch: true,\n                    fastTap: true,\n                    tap: that._tap.bind(that),\n                    start: that._dragStart.bind(that),\n                    move: that._drag.bind(that),\n                    end: that._dragEnd.bind(that),\n                    gesturestart: that._gestureStart.bind(that),\n                    gesturechange: that._gestureChange.bind(that),\n                    gestureend: that._gestureEnd.bind(that),\n                    doubleTap: that._doubleTap.bind(that),\n                    supportDoubleTap: true\n                });\n\n                that.toolService = new ToolService(that);\n\n                this.scrollable\n                    .on(\"mouseover\" + NS, that._mouseover.bind(that))\n                    .on(\"mouseout\" + NS, that._mouseout.bind(that))\n                    .on(\"mousemove\" + NS, that._mouseMove.bind(that))\n                    .on(\"mousedown\" + NS, that._mouseDown.bind(that))\n                    .on(\"mouseup\" + NS, that._mouseUp.bind(that));\n\n                this._syncHandler = that._syncChanges.bind(that);\n\n                that._resizeHandler = that.resize.bind(that, false);\n                kendo.onResize(that._resizeHandler);\n\n                this.bind(ZOOM_START, that._destroyToolBar.bind(that));\n                this.bind(PAN, that._destroyToolBar.bind(that));\n            },\n\n            _dragStart: function(e) {\n                this._pauseMouseHandlers = true;\n                var point = this._eventPositions(e, true);\n\n                var event = e.event;\n                if (this.toolService.start(point, this._meta(event))) {\n                    this._destroyToolBar();\n                    event.preventDefault();\n                }\n            },\n\n            _drag: function(e) {\n                var p = this._eventPositions(e);\n                var event = e.event;\n                if (this.toolService.move(p, this._meta(event))) {\n                    event.preventDefault();\n                }\n            },\n\n            _dragEnd: function(e) {\n                this._pauseMouseHandlers = false;\n                var p = this._eventPositions(e);\n                var event = e.event;\n                if (this.toolService.end(p, this._meta(event))) {\n                    this._createToolBar();\n                    event.preventDefault();\n                }\n            },\n\n            _mouseMove: function(e) {\n                if (!this._pauseMouseHandlers) {\n                    var p = this._eventPositions(e);\n                    this.toolService._updateHoveredItem(p);\n                    this.toolService._updateCursor(p);\n                }\n            },\n\n            _mouseDown: function() {\n                this._pauseMouseHandlers = true;\n            },\n\n            _mouseUp: function() {\n                this._pauseMouseHandlers = false;\n            },\n\n            _tap: function(e) {\n                var toolService = this.toolService;\n                var selectable = this.options.selectable;\n                var point = this._eventPositions(e);\n                var focused = this.focus();\n\n                toolService._updateHoveredItem(point);\n\n                if (toolService.hoveredItem) {\n                    var item = toolService.hoveredItem;\n\n                    this.trigger(\"click\", {\n                        item: item,\n                        point: point,\n                        meta: this._meta(e.event)\n                    });\n\n                    if (selectable && item.options.selectable !== false) {\n                        var multiple = selectable.multiple !== false;\n                        var ctrlPressed = kendo.support.mobileOS || this._meta(e.event).ctrlKey;\n\n                        if (item.isSelected) {\n                            if (ctrlPressed) {\n                                this._destroyToolBar();\n                                item.select(false);\n                            } else {\n                                this._createToolBar(focused);\n                            }\n                        } else {\n                            this._destroyToolBar();\n                            this.select(item, {\n                                addToSelection: multiple && ctrlPressed\n                            });\n                            this._createToolBar(focused);\n                        }\n                    }\n                } else if (selectable) {\n                    this._destroyToolBar();\n                    this.deselect();\n                }\n            },\n\n            _keydown: function(e) {\n                if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                    e.preventDefault();\n                }\n            },\n\n            _wheel: function(e) {\n                var delta = mwDelta(e),\n                    p = this._eventPositions(e),\n                    meta = deepExtend(this._meta(e), { delta: delta });\n\n                if (this.toolService.wheel(p, meta)) {\n                    e.preventDefault();\n                }\n            },\n\n            _meta: function(e) {\n                return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n            },\n\n            _eventPositions: function(e, start) {\n                var point;\n                if (e.touch) {\n                    var field = start ? \"startLocation\" : \"location\";\n                    point = new Point(e.x[field], e.y[field]);\n                } else {\n                    var event = e.originalEvent;\n                    point = new Point(event.pageX, event.pageY);\n                }\n\n                return this.documentToModel(point);\n            },\n\n            _gestureStart: function(e) {\n                this._destroyToolBar();\n                this.scroller.disable();\n                var initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n                var eventArgs = {\n                    point: initialCenter,\n                    zoom: this.zoom()\n                };\n\n                if (this.trigger(ZOOM_START, eventArgs)) {\n                    return;\n                }\n\n                this._gesture = e;\n                this._initialCenter = initialCenter;\n            },\n\n            _gestureChange: function(e) {\n                var previousGesture = this._gesture;\n                var initialCenter = this._initialCenter;\n                var center = this.documentToView(new Point(e.center.x, e.center.y));\n                var scaleDelta = e.distance / previousGesture.distance;\n                var zoom = this._zoom;\n                var updateZoom = false;\n\n                if (math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                    this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                    this.options.zoom = zoom;\n                    this._gesture = e;\n                    updateZoom = true;\n                }\n\n                var zoomedPoint = initialCenter.times(zoom);\n                var pan = center.minus(zoomedPoint);\n                if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                    this._panTransform(pan);\n                    this._updateAdorners();\n                }\n\n                e.preventDefault();\n            },\n\n            _doubleTap: function(e) {\n                var diagram = this;\n                var pointPosition = this._eventPositions(e);\n                var options = diagram.options;\n                var zoomRate = options.zoomRate;\n                var zoom = diagram.zoom() + zoomRate;\n                var meta = this._meta(e);\n                var zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n\n\n                if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                    return;\n                }\n\n                zoom = kendo.drawing.util.round(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n                zoomOptions.zoom = zoom;\n\n                diagram.zoom(zoom, zoomOptions);\n                diagram.trigger(ZOOM_END, zoomOptions);\n            },\n\n            _gestureEnd: function() {\n                if (this.options.pannable !== false) {\n                    this.scroller.enable();\n                }\n                this.trigger(ZOOM_END, {\n                    point: this._initialCenter,\n                    zoom: this.zoom()\n                });\n            },\n\n            _resize: function() {\n                var viewport = this.viewport();\n                if (this.canvas) {\n                    this.canvas.size(viewport);\n                }\n\n                if (this.scrollable && this.toolBar) {\n                    this.scrollable.height(viewport.height);\n                }\n            },\n\n            _mouseover: function(e) {\n                var node = e.target._kendoNode;\n                if (node && node.srcElement._hover) {\n                    node.srcElement._hover(true, node.srcElement);\n                }\n            },\n\n            _mouseout: function(e) {\n                var node = e.target._kendoNode;\n                if (node && node.srcElement._hover) {\n                    node.srcElement._hover(false, node.srcElement);\n                }\n            },\n\n            _initTheme: function() {\n                var that = this;\n                var themeName = ((that.options || {}).theme || \"\").toLowerCase();\n                var themes = dataviz.ui.themes || {};\n                var themeOptions;\n\n                if (dataviz.SASS_THEMES.indexOf(themeName) != -1) {\n                    themeOptions = dataviz.autoTheme().diagram;\n                }\n                else {\n                    themeOptions = (themes[themeName] || {}).diagram;\n                }\n\n                that.options = deepExtend({}, themeOptions, that.options);\n                if (that.options.editable === true) {\n                    deepExtend(that.options, {\n                        editable: (themeOptions || {}).editable\n                    });\n                }\n            },\n\n            _createOptionElements: function() {\n                var options = this.options;\n                var shapesLength = options.shapes.length;\n\n                if (shapesLength) {\n                    this._createShapes();\n                }\n\n                if (options.connections.length) {\n                    this._createConnections();\n                }\n\n                if (shapesLength && options.layout) {\n                    this.layout(options.layout);\n                }\n            },\n\n            _createShapes: function() {\n                var that = this,\n                    options = that.options,\n                    shapes = options.shapes,\n                    shape, i;\n\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    that.addShape(shape);\n                }\n            },\n\n            _createConnections: function() {\n                var diagram = this,\n                    options = diagram.options,\n                    defaults = options.connectionDefaults,\n                    connections = options.connections,\n                    conn, source, target, i;\n\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    source = diagram._findConnectionTarget(conn.from);\n                    target = diagram._findConnectionTarget(conn.to);\n\n                    diagram.connect(source, target, deepExtend({}, defaults, conn));\n                }\n            },\n\n            _findConnectionTarget: function(options) {\n                options = options || {};\n                var diagram = this;\n                var shapeId = isString(options) ? options : options.shapeId || options.id;\n                var target;\n                if (shapeId) {\n                    target = diagram.getShapeById(shapeId);\n                    if (options.connector) {\n                        target = target.getConnector(options.connector);\n                    }\n                } else {\n                    target = new Point(options.x || 0, options.y || 0);\n                }\n\n                return target;\n            },\n\n            destroy: function() {\n                var that = this;\n                Widget.fn.destroy.call(that);\n\n                if (this._userEvents) {\n                    this._userEvents.destroy();\n                }\n\n                kendo.unbindResize(that._resizeHandler);\n\n                that.clear();\n                that.element.off(NS);\n                that.scroller.wrapper.off(NS);\n                that.canvas.destroy(true);\n                that.canvas = undefined$1;\n\n                that._destroyEditor();\n                that.destroyScroller();\n                that._destroyGlobalToolBar();\n                that._destroyToolBar();\n            },\n\n            destroyScroller: function() {\n                var scroller = this.scroller;\n\n                if (!scroller) {\n                    return;\n                }\n\n                scroller.destroy();\n                scroller.element.remove();\n                this.scroller = null;\n            },\n\n            save: function() {\n                var json = {\n                    shapes: [],\n                    connections: []\n                };\n                var i, connection, shape;\n\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    if (shape.options.serializable) {\n                        json.shapes.push(shape.options);\n                    }\n                }\n\n                for (i = 0; i < this.connections.length; i++) {\n                    connection = this.connections[i];\n\n                    json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n                }\n\n                return json;\n            },\n\n            focus: function() {\n                if (!this.element.is(kendo._activeElement())) {\n                    var element = this.element,\n                        scrollContainer = element[0],\n                        containers = [],\n                        offsets = [],\n                        documentElement = document.documentElement,\n                        i;\n\n                    do {\n                        scrollContainer = scrollContainer.parentNode;\n\n                        if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                            containers.push(scrollContainer);\n                            offsets.push(scrollContainer.scrollTop);\n                        }\n                    } while (scrollContainer != documentElement);\n\n                    element.trigger(\"focus\");\n\n                    for (i = 0; i < containers.length; i++) {\n                        containers[i].scrollTop = offsets[i];\n                    }\n                    return true;\n                }\n            },\n\n            load: function(options) {\n                this.clear();\n\n                this.setOptions(options);\n                this._createShapes();\n                this._createConnections();\n            },\n\n            setOptions: function(options) {\n                deepExtend(this.options, options);\n            },\n\n            clear: function() {\n                var that = this;\n\n                that.select(false);\n                that.mainLayer.clear();\n                that._shapesQuadTree.clear();\n                that._initialize();\n            },\n            /**\n             * Connects two items.\n             * @param source Shape, Connector, Point.\n             * @param target Shape, Connector, Point.\n             * @param options Connection options that will be passed to the newly created connection.\n             * @returns The newly created connection.\n             */\n            connect: function(source, target, options) {\n                var connection;\n                if (this.connectionsDataSource && this._isEditable) {\n                    var dataItem = this.connectionsDataSource.add({});\n                    connection = this._connectionsDataMap[dataItem.uid];\n                    connection.source(source);\n                    connection.target(target);\n                    connection.redraw(options);\n                    connection.updateModel();\n                } else {\n                    connection = new Connection(source, target,\n                        deepExtend({ }, this.options.connectionDefaults, options));\n\n                    this.addConnection(connection);\n                }\n\n                return connection;\n            },\n            /**\n             * Determines whether the the two items are connected.\n             * @param source Shape, Connector, Point.\n             * @param target Shape, Connector, Point.\n             * @returns true if the two items are connected.\n             */\n            connected: function(source, target) {\n                for (var i = 0; i < this.connections.length; i++) {\n                    var c = this.connections[i];\n                    if (c.from == source && c.to == target) {\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n            /**\n             * Adds connection to the diagram.\n             * @param connection Connection.\n             * @param undoable Boolean.\n             * @returns The newly created connection.\n             */\n            addConnection: function(connection, undoable) {\n                if (undoable !== false) {\n                    this.undoRedoService.add(\n                        new diagram.AddConnectionUnit(connection, this), false);\n                }\n\n                connection.diagram = this;\n                connection._setOptionsFromModel();\n                connection.refresh();\n                this.mainLayer.append(connection.visual);\n                this.connections.push(connection);\n\n                this.trigger(CHANGE, {\n                    added: [connection],\n                    removed: []\n                });\n\n                return connection;\n            },\n\n            _addConnection: function(connection, undoable) {\n                var connectionsDataSource = this.connectionsDataSource;\n                var dataItem;\n                if (connectionsDataSource && this._isEditable) {\n                    dataItem = createModel(connectionsDataSource, cloneDataItem(connection.dataItem));\n                    connection.dataItem = dataItem;\n                    connection.updateModel();\n\n                    if (!this.trigger(\"add\", { connection: connection })) {\n                        this._connectionsDataMap[dataItem.uid] = connection;\n\n                        connectionsDataSource.add(dataItem);\n                        this.addConnection(connection, undoable);\n                        connection._updateConnectors();\n\n                        return connection;\n                    }\n                } else if (!this.trigger(\"add\", { connection: connection })) {\n                    this.addConnection(connection, undoable);\n                    connection._updateConnectors();\n                    return connection;\n                }\n            },\n\n            /**\n             * Adds shape to the diagram.\n             * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n             * @param options. The options to be passed to the newly created Shape.\n             * @returns The newly created shape.\n             */\n            addShape: function(item, undoable) {\n                var shape,\n                    shapeDefaults = this.options.shapeDefaults;\n\n                if (item instanceof Shape) {\n                    shape = item;\n                    this._parseBounds(shape.bounds());\n                } else if (!(item instanceof kendo.Class)) {\n                    shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                    shape = new Shape(shapeDefaults, this);\n                    this._parseBounds(shape.bounds());\n                } else {\n                    return;\n                }\n\n                if (undoable !== false) {\n                    this.undoRedoService.add(new diagram.AddShapeUnit(shape, this), false);\n                }\n\n                this.shapes.push(shape);\n                if (shape.diagram !== this) {\n                    this._shapesQuadTree.insert(shape);\n                    shape.diagram = this;\n                }\n                this.mainLayer.append(shape.visual);\n\n                this.trigger(CHANGE, {\n                    added: [shape],\n                    removed: []\n                });\n\n                return shape;\n            },\n\n            _addShape: function(shape, undoable) {\n                var that = this;\n                var dataSource = that.dataSource;\n                var dataItem;\n                if (dataSource && this._isEditable) {\n                    dataItem = createModel(dataSource, cloneDataItem(shape.dataItem));\n                    shape.dataItem = dataItem;\n                    shape.updateModel();\n\n                    if (!this.trigger(\"add\", { shape: shape })) {\n                        this.dataSource.add(dataItem);\n                        var inactiveItem = this._inactiveShapeItems.getByUid(dataItem.uid);\n                        inactiveItem.element = shape;\n                        inactiveItem.undoable = undoable;\n                        return shape;\n                    }\n                } else if (!this.trigger(\"add\", { shape: shape })) {\n                    return this.addShape(shape, undoable);\n                }\n            },\n\n            _parseBounds: function(bounds) {\n                bounds.x = typeof(bounds.x) == \"string\" ? parseFloat(bounds.x) : bounds.x;\n                bounds.y = typeof(bounds.y) == \"string\" ? parseFloat(bounds.y) : bounds.y;\n            },\n            /**\n             * Removes items (or single item) from the diagram.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable.\n             */\n\n           remove: function(items, undoable) {\n                items = isArray(items) ? items.slice(0) : [items];\n                var elements = splitDiagramElements(items);\n                var shapes = elements.shapes;\n                var connections = elements.connections;\n                var i;\n\n                if (!defined(undoable)) {\n                    undoable = true;\n                }\n\n                if (undoable) {\n                    this.undoRedoService.begin();\n                }\n\n                this._suspendModelRefresh();\n                for (i = shapes.length - 1; i >= 0; i--) {\n                   this._removeItem(shapes[i], undoable, connections);\n                }\n\n                for (i = connections.length - 1; i >= 0; i--) {\n                    this._removeItem(connections[i], undoable);\n                }\n\n                this._resumeModelRefresh();\n\n                if (undoable) {\n                    this.undoRedoService.commit(false);\n                }\n\n                this.trigger(CHANGE, {\n                    added: [],\n                    removed: items\n                });\n            },\n\n            _removeShapeDataItem: function(item) {\n                if (this._isEditable) {\n                    this.dataSource.remove(item.dataItem);\n                    delete this._dataMap[item.dataItem.id];\n                }\n            },\n\n            _removeConnectionDataItem: function(item) {\n                if (this._isEditable) {\n                    this.connectionsDataSource.remove(item.dataItem);\n                    delete this._connectionsDataMap[item.dataItem.uid];\n                }\n            },\n\n            _triggerRemove: function(items) {\n                var toRemove = [];\n                var item, args, editable;\n\n                for (var idx = 0; idx < items.length; idx++) {\n                    item = items[idx];\n                    editable = item.options.editable;\n                    if (item instanceof Shape) {\n                        args = { shape: item };\n                    } else {\n                        args = { connection: item };\n                    }\n                    if (editable && editable.remove !== false && !this.trigger(\"remove\", args)) {\n                        toRemove.push(item);\n                    }\n                }\n                return toRemove;\n            },\n\n            /**\n             * Executes the next undoable action on top of the undo stack if any.\n             */\n            undo: function() {\n                this.undoRedoService.undo();\n            },\n            /**\n             * Executes the previous undoable action on top of the redo stack if any.\n             */\n            redo: function() {\n                this.undoRedoService.redo();\n            },\n            /**\n             * Selects items on the basis of the given input or returns the current selection if none.\n             * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n             * @param options\n             * @returns {Array}\n             */\n            select: function(item, options) {\n                if (isDefined(item)) {\n                    options = deepExtend({ addToSelection: false }, options);\n\n                    var addToSelection = options.addToSelection,\n                        items = [],\n                        selected = [],\n                        i, element;\n\n                    if (!addToSelection) {\n                        this.deselect();\n                    }\n\n                    this._internalSelection = true;\n\n                    if (item instanceof Array) {\n                        items = item;\n                    } else if (item instanceof DiagramElement) {\n                        items = [ item ];\n                    }\n\n                    for (i = 0; i < items.length; i++) {\n                        element = items[i];\n                        if (element.select(true)) {\n                            selected.push(element);\n                        }\n                    }\n\n                    this._selectionChanged(selected, []);\n\n                    this._internalSelection = false;\n                } else {\n                    return this._selectedItems;\n                }\n            },\n\n            selectAll: function() {\n                this.select(this.shapes.concat(this.connections));\n            },\n\n            selectArea: function(rect) {\n                var i, items, item;\n                this._internalSelection = true;\n                var selected = [];\n                if (rect instanceof Rect) {\n                    items = this.shapes.concat(this.connections);\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                            if (item.select(true)) {\n                                selected.push(item);\n                            }\n                        }\n                    }\n                }\n\n                this._selectionChanged(selected, []);\n                this._internalSelection = false;\n            },\n\n            deselect: function(item) {\n                this._internalSelection = true;\n                var deselected = [],\n                    items = [],\n                    element, i;\n\n                if (item instanceof Array) {\n                    items = item;\n                } else if (item instanceof DiagramElement) {\n                    items.push(item);\n                } else if (!isDefined(item)) {\n                    items = this._selectedItems.slice(0);\n                }\n\n                for (i = 0; i < items.length; i++) {\n                    element = items[i];\n                    if (element.select(false)) {\n                        deselected.push(element);\n                    }\n                }\n\n                this._selectionChanged([], deselected);\n                this._internalSelection = false;\n            },\n            /**\n             * Brings to front the passed items.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable. By default the action is undoable.\n             */\n            toFront: function(items, undoable) {\n                if (!items) {\n                    items = this._selectedItems.slice();\n                }\n\n                var result = this._getDiagramItems(items), indices;\n                if (!defined(undoable) || undoable) {\n                    indices = indicesOfItems(this.mainLayer, result.visuals);\n                    var unit = new ToFrontUnit(this, items, indices);\n                    this.undoRedoService.add(unit);\n                } else {\n                    this.mainLayer.toFront(result.visuals);\n                    this._fixOrdering(result, true);\n                }\n            },\n            /**\n             * Sends to back the passed items.\n             * @param items DiagramElement, Array of Items.\n             * @param undoable. By default the action is undoable.\n             */\n            toBack: function(items, undoable) {\n                if (!items) {\n                    items = this._selectedItems.slice();\n                }\n\n                var result = this._getDiagramItems(items), indices;\n                if (!defined(undoable) || undoable) {\n                    indices = indicesOfItems(this.mainLayer, result.visuals);\n                    var unit = new ToBackUnit(this, items, indices);\n                    this.undoRedoService.add(unit);\n                } else {\n                    this.mainLayer.toBack(result.visuals);\n                    this._fixOrdering(result, false);\n                }\n            },\n            /**\n             * Bring into view the passed item(s) or rectangle.\n             * @param items DiagramElement, Array of Items, Rect.\n             * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n             * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n             */\n            bringIntoView: function(item, options) { // jQuery|Item|Array|Rect\n                var viewport = this.viewport();\n                var aligner = new diagram.RectAlign(viewport);\n                var current, rect, original, newPan;\n\n                if (viewport.width === 0 || viewport.height === 0) {\n                    return;\n                }\n\n                options = deepExtend({ animate: false, align: \"center middle\" }, options);\n                if (options.align == \"none\") {\n                    options.align = \"center middle\";\n                }\n\n                if (item instanceof DiagramElement) {\n                    rect = item.bounds(TRANSFORMED);\n                } else if (isArray(item)) {\n                    rect = this.boundingBox(item);\n                } else if (item instanceof Rect) {\n                    rect = item.clone();\n                }\n\n                original = rect.clone();\n\n                rect.zoom(this._zoom);\n\n                if (rect.width > viewport.width || rect.height > viewport.height) {\n                    this._zoom = this._getValidZoom(math.min(viewport.width / original.width, viewport.height / original.height));\n                    rect = original.clone().zoom(this._zoom);\n                }\n\n                this._zoomMainLayer();\n\n                current = rect.clone();\n                aligner.align(rect, options.align);\n\n                newPan = rect.topLeft().minus(current.topLeft());\n                this.pan(newPan.times(-1), options.animate);\n            },\n\n            alignShapes: function(direction) {\n                if (isUndefined(direction)) {\n                    direction = \"Left\";\n                }\n                var items = this.select(),\n                    val,\n                    item,\n                    i;\n\n                if (items.length === 0) {\n                    return;\n                }\n\n                switch (direction.toLowerCase()) {\n                    case \"left\":\n                    case \"top\":\n                        val = MAX_VALUE;\n                        break;\n                    case \"right\":\n                    case \"bottom\":\n                        val = MIN_VALUE;\n                        break;\n                }\n\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof Shape) {\n                        switch (direction.toLowerCase()) {\n                            case \"left\":\n                                val = math.min(val, item.options.x);\n                                break;\n                            case \"top\":\n                                val = math.min(val, item.options.y);\n                                break;\n                            case \"right\":\n                                val = math.max(val, item.options.x);\n                                break;\n                            case \"bottom\":\n                                val = math.max(val, item.options.y);\n                                break;\n                        }\n                    }\n                }\n                var undoStates = [];\n                var shapes = [];\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (item instanceof Shape) {\n                        shapes.push(item);\n                        undoStates.push(item.bounds());\n                        switch (direction.toLowerCase()) {\n                            case \"left\":\n                            case \"right\":\n                                item.position(new Point(val, item.options.y));\n                                break;\n                            case \"top\":\n                            case \"bottom\":\n                                item.position(new Point(item.options.x, val));\n                                break;\n                        }\n                    }\n                }\n                var unit = new diagram.TransformUnit(shapes, undoStates);\n                this.undoRedoService.add(unit, false);\n            },\n\n            zoom: function(zoom, options) {\n                if (zoom) {\n                    var staticPoint = options ? options.point : new diagram.Point(0, 0);\n                    // var meta = options ? options.meta : 0;\n                    zoom = this._zoom = this._getValidZoom(zoom);\n\n                    if (!isUndefined(staticPoint)) {//Viewpoint vector is constant\n                        staticPoint = new diagram.Point(math.round(staticPoint.x), math.round(staticPoint.y));\n                        var zoomedPoint = staticPoint.times(zoom);\n                        var viewportVector = this.modelToView(staticPoint);\n                        var raw = viewportVector.minus(zoomedPoint);//pan + zoomed point = viewpoint vector\n                        this._storePan(new diagram.Point(math.round(raw.x), math.round(raw.y)));\n                    }\n\n                    if (options) {\n                        options.zoom = zoom;\n                    }\n\n                    this._panTransform();\n\n                    this.canvas.surface.hideTooltip();\n\n                    this._updateAdorners();\n                }\n\n                return this._zoom;\n            },\n\n            _getPan: function(pan) {\n                var canvas = this.canvas;\n                if (!canvas.translate) {\n                    pan = pan.plus(this._pan);\n                }\n                return pan;\n            },\n\n            pan: function(pan, animate) {\n                if (pan instanceof Point) {\n                    var that = this;\n                    var scroller = that.scroller;\n                    pan = that._getPan(pan);\n                    pan = pan.times(-1);\n\n                    if (animate) {\n                        scroller.animatedScrollTo(pan.x, pan.y, function() {\n                            that._updateAdorners();\n                        });\n                    } else {\n                        scroller.scrollTo(pan.x, pan.y);\n                        that._updateAdorners();\n                    }\n                } else {\n                    return this._pan.times(-1);\n                }\n            },\n\n            viewport: function() {\n                var element = this.element;\n                var width = element.width();\n                var height = element.height();\n\n                if (this.toolBar) {\n                    height -= outerHeight(this.toolBar.element);\n                }\n\n                return new Rect(0, 0, width, height);\n            },\n            copy: function() {\n                if (this.options.copy.enabled) {\n                    this._clipboard = [];\n                    this._copyOffset = 1;\n                    for (var i = 0; i < this._selectedItems.length; i++) {\n                        var item = this._selectedItems[i];\n                        this._clipboard.push(item);\n                    }\n                }\n            },\n            cut: function() {\n                if (this.options.copy.enabled) {\n                    this._clipboard = [];\n                    this._copyOffset = 0;\n                    for (var i = 0; i < this._selectedItems.length; i++) {\n                        var item = this._selectedItems[i];\n                        this._clipboard.push(item);\n                    }\n                    this.remove(this._clipboard, true);\n                }\n            },\n\n            paste: function() {\n                if (this._clipboard.length > 0) {\n                    var item, copied, i;\n                    var mapping = {};\n                    var elements = splitDiagramElements(this._clipboard);\n                    var connections = elements.connections;\n                    var shapes = elements.shapes;\n                    var offset = {\n                        x: this._copyOffset * this.options.copy.offsetX,\n                        y: this._copyOffset * this.options.copy.offsetY\n                    };\n                    this.deselect();\n                    // first the shapes\n                    for (i = 0; i < shapes.length; i++) {\n                        item = shapes[i];\n                        copied = item.clone();\n                        mapping[item.id] = copied;\n                        copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                        copied.diagram = this;\n                        copied = this._addShape(copied);\n                        if (copied) {\n                            copied.select();\n                        }\n                    }\n                    // then the connections\n                    for (i = 0; i < connections.length; i++) {\n                        item = connections[i];\n                        copied = this._addConnection(item.clone());\n                        if (copied) {\n                            this._updateCopiedConnection(copied, item, \"source\", mapping, offset);\n                            this._updateCopiedConnection(copied, item, \"target\", mapping, offset);\n\n                            copied.select(true);\n                            copied.updateModel();\n                        }\n                    }\n\n                    this._syncChanges();\n\n                    this._copyOffset += 1;\n                }\n            },\n\n            _updateCopiedConnection: function(connection, sourceConnection, connectorName, mapping, offset) {\n                var onActivate, inactiveItem, targetShape;\n                var target = sourceConnection[connectorName]();\n                var diagram = this;\n                if (target instanceof Connector && mapping[target.shape.id]) {\n                    targetShape = mapping[target.shape.id];\n                    if (diagram.getShapeById(targetShape.id)) {\n                        connection[connectorName](targetShape.getConnector(target.options.name));\n                    } else {\n                        inactiveItem = diagram._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                        if (inactiveItem) {\n                            onActivate = function(item) {\n                                targetShape = diagram._dataMap[item.id];\n                                connection[connectorName](targetShape.getConnector(target.options.name));\n                                connection.updateModel();\n                            };\n                            diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                        }\n                    }\n                } else {\n                    connection[connectorName](new Point(sourceConnection[connectorName + \"Point\"]().x + offset.x, sourceConnection[connectorName + \"Point\"]().y + offset.y));\n                }\n            },\n            /**\n             * Gets the bounding rectangle of the given items.\n             * @param items DiagramElement, Array of elements.\n             * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n             * @returns {Rect}\n             */\n            boundingBox: function(items, origin) {\n                var rect = Rect.empty(), temp,\n                    di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n                if (di.shapes.length > 0) {\n                    var item = di.shapes[0];\n                    rect = item.bounds(ROTATED);\n                    for (var i = 1; i < di.shapes.length; i++) {\n                        item = di.shapes[i];\n                        temp = item.bounds(ROTATED);\n                        if (origin === true) {\n                            temp.x -= item._rotationOffset.x;\n                            temp.y -= item._rotationOffset.y;\n                        }\n                        rect = rect.union(temp);\n                    }\n                }\n                return rect;\n            },\n\n            _containerOffset: function() {\n                var containerOffset = this.element.offset();\n                if (this.toolBar) {\n                    containerOffset.top += outerHeight(this.toolBar.element);\n                }\n                return containerOffset;\n            },\n\n            documentToView: function(point) {\n                var containerOffset = this._containerOffset();\n\n                return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n            },\n            viewToDocument: function(point) {\n                var containerOffset = this._containerOffset();\n\n                return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n            },\n            viewToModel: function(point) {\n                return this._transformWithMatrix(point, this._matrixInvert);\n            },\n            modelToView: function(point) {\n                return this._transformWithMatrix(point, this._matrix);\n            },\n            modelToLayer: function(point) {\n                return this._transformWithMatrix(point, this._layerMatrix);\n            },\n            layerToModel: function(point) {\n                return this._transformWithMatrix(point, this._layerMatrixInvert);\n            },\n            documentToModel: function(point) {\n                var viewPoint = this.documentToView(point);\n                if (!this.canvas.translate) {\n                    viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                    viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n                }\n                return this.viewToModel(viewPoint);\n            },\n            modelToDocument: function(point) {\n                return this.viewToDocument(this.modelToView(point));\n            },\n            _transformWithMatrix: function(point, matrix) {\n                var result = point;\n                if (point instanceof Point) {\n                    if (matrix) {\n                        result = matrix.apply(point);\n                    }\n                }\n                else {\n                    var tl = this._transformWithMatrix(point.topLeft(), matrix),\n                        br = this._transformWithMatrix(point.bottomRight(), matrix);\n                    result = Rect.fromPoints(tl, br);\n                }\n                return result;\n            },\n\n            setDataSource: function(dataSource) {\n                this.options.dataSource = dataSource;\n                this._dataSource();\n                if (this.options.autoBind) {\n                    this.dataSource.fetch();\n                }\n            },\n\n            setConnectionsDataSource: function(dataSource) {\n                this.options.connectionsDataSource = dataSource;\n                this._connectionDataSource();\n                if (this.options.autoBind) {\n                    this.connectionsDataSource.fetch();\n                }\n            },\n\n            /**\n             * Performs a diagram layout of the given type.\n             * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n             * @param options Layout-specific options.\n             */\n            layout: function(options) {\n                this._layouting = true;\n                // TODO: raise layout event?\n                var type;\n                if (isUndefined(options)) {\n                    options = this.options.layout;\n                }\n                if (isUndefined(options) || isUndefined(options.type)) {\n                    type = \"Tree\";\n                }\n                else {\n                    type = options.type;\n                }\n                var l;\n                switch (type.toLowerCase()) {\n                    case \"tree\":\n                        l = new diagram.TreeLayout(this);\n                        break;\n\n                    case \"layered\":\n                        l = new diagram.LayeredLayout(this);\n                        break;\n\n                    case \"forcedirected\":\n                    case \"force\":\n                    case \"spring\":\n                    case \"springembedder\":\n                        l = new diagram.SpringLayout(this);\n                        break;\n                    default:\n                        throw \"Layout algorithm '\" + type + \"' is not supported.\";\n                }\n                var initialState = new diagram.LayoutState(this);\n                var finalState = l.layout(options);\n                if (finalState) {\n                    var unit = new diagram.LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                    this.undoRedoService.add(unit);\n                }\n                this._layouting = false;\n                this._redrawConnections();\n            },\n            /**\n             * Gets a shape on the basis of its identifier.\n             * @param id (string) the identifier of a shape.\n             * @returns {Shape}\n             */\n            getShapeById: function(id) {\n                var found;\n                found = Utils.first(this.shapes, function(s) {\n                    return s.visual.id === id;\n                });\n                if (found) {\n                    return found;\n                }\n                found = Utils.first(this.connections, function(c) {\n                    return c.visual.id === id;\n                });\n                return found;\n            },\n\n            getShapeByModelId: function(id) {\n                var shape;\n                if (this._isEditable) {\n                    shape = this._dataMap[id];\n                } else {\n                    shape = Utils.first(this.shapes, function(shape) {\n                        return (shape.dataItem || {}).id === id;\n                    });\n                }\n                return shape;\n            },\n\n            getShapeByModelUid: function(uid) {\n                var shape;\n                if (this._isEditable) {\n                    shape = Utils.first(this.shapes, function(shape) {\n                        return (shape.dataItem || {}).uid === uid;\n                    });\n                } else {\n                    shape = this._dataMap[uid];\n                }\n                return shape;\n            },\n\n            getConnectionByModelId: function(id) {\n                var connection;\n                if (this.connectionsDataSource) {\n                    connection = Utils.first(this.connections, function(connection) {\n                        return (connection.dataItem || {}).id === id;\n                    });\n                }\n                return connection;\n            },\n\n            getConnectionByModelUid: function(uid) {\n                var connection;\n                if (this.connectionsDataSource) {\n                    connection = this._connectionsDataMap[uid];\n                }\n                return connection;\n            },\n\n            _extendLayoutOptions: function(options) {\n                if (options.layout) {\n                    options.layout = deepExtend({}, diagram.LayoutBase.fn.defaultOptions || {}, options.layout);\n                }\n            },\n\n            _selectionChanged: function(selected, deselected) {\n                if (selected.length || deselected.length) {\n                    this.trigger(SELECT, { selected: selected, deselected: deselected });\n                }\n            },\n            _getValidZoom: function(zoom) {\n                return math.min(math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n            },\n            _panTransform: function(pos) {\n                var diagram = this,\n                    pan = pos || diagram._pan;\n\n                if (diagram.canvas.translate) {\n                    diagram.scroller.scrollTo(pan.x, pan.y);\n                    diagram._zoomMainLayer();\n                } else {\n                    diagram._storePan(pan);\n                    diagram._transformMainLayer();\n                }\n            },\n\n            _finishPan: function() {\n                this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n            },\n            _storePan: function(pan) {\n                this._pan = pan;\n                this._storeViewMatrix();\n            },\n            _zoomMainLayer: function() {\n                var zoom = this._zoom;\n\n                var transform = new CompositeTransform(0, 0, zoom, zoom);\n                transform.render(this.mainLayer);\n                this._storeLayerMatrix(transform);\n                this._storeViewMatrix();\n            },\n            _transformMainLayer: function() {\n                var pan = this._pan,\n                    zoom = this._zoom;\n\n                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                transform.render(this.mainLayer);\n                this._storeLayerMatrix(transform);\n                this._storeViewMatrix();\n            },\n            _storeLayerMatrix: function(canvasTransform) {\n                this._layerMatrix = canvasTransform.toMatrix();\n                this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n            },\n            _storeViewMatrix: function() {\n                var pan = this._pan,\n                    zoom = this._zoom;\n\n                var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                this._matrix = transform.toMatrix();\n                this._matrixInvert = transform.invert().toMatrix();\n            },\n            _toIndex: function(items, indices) {\n                var result = this._getDiagramItems(items);\n                this.mainLayer.toIndex(result.visuals, indices);\n                this._fixOrdering(result, false);\n            },\n            _fixOrdering: function(result, toFront) {\n                var shapePos = toFront ? this.shapes.length - 1 : 0,\n                    conPos = toFront ? this.connections.length - 1 : 0,\n                    i, item;\n                for (i = 0; i < result.shapes.length; i++) {\n                    item = result.shapes[i];\n                    Utils.remove(this.shapes, item);\n                    Utils.insert(this.shapes, item, shapePos);\n                }\n                for (i = 0; i < result.cons.length; i++) {\n                    item = result.cons[i];\n                    Utils.remove(this.connections, item);\n                    Utils.insert(this.connections, item, conPos);\n                }\n            },\n            _getDiagramItems: function(items) {\n                var i, result = {}, args = items;\n                result.visuals = [];\n                result.shapes = [];\n                result.cons = [];\n\n                if (!items) {\n                    args = this._selectedItems.slice();\n                } else if (!isArray(items)) {\n                    args = [items];\n                }\n\n                for (i = 0; i < args.length; i++) {\n                    var item = args[i];\n                    if (item instanceof Shape) {\n                        result.shapes.push(item);\n                        result.visuals.push(item.visual);\n                    } else if (item instanceof Connection) {\n                        result.cons.push(item);\n                        result.visuals.push(item.visual);\n                    }\n                }\n\n                return result;\n            },\n\n            _removeItem: function(item, undoable, removedConnections) {\n                item.select(false);\n                if (item instanceof Shape) {\n                    this._removeShapeDataItem(item);\n                    this._removeShape(item, undoable, removedConnections);\n                } else if (item instanceof Connection) {\n                    this._removeConnectionDataItem(item);\n                    this._removeConnection(item, undoable);\n                }\n\n                this.mainLayer.remove(item.visual);\n            },\n\n            _removeShape: function(shape, undoable, removedConnections) {\n                var i, connection, connector,\n                    sources = [], targets = [];\n                this.toolService._removeHover();\n\n                if (undoable) {\n                    this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n                }\n                Utils.remove(this.shapes, shape);\n                this._shapesQuadTree.remove(shape);\n\n                for (i = 0; i < shape.connectors.length; i++) {\n                    connector = shape.connectors[i];\n                    for (var j = 0; j < connector.connections.length; j++) {\n                        connection = connector.connections[j];\n                        if (!removedConnections || !dataviz.inArray(connection, removedConnections)) {\n                            if (connection.sourceConnector == connector) {\n                                sources.push(connection);\n                            } else if (connection.targetConnector == connector) {\n                                targets.push(connection);\n                            }\n                        }\n                    }\n                }\n\n                for (i = 0; i < sources.length; i++) {\n                    sources[i].source(null, undoable);\n                    sources[i].updateModel();\n                }\n                for (i = 0; i < targets.length; i++) {\n                    targets[i].target(null, undoable);\n                    targets[i].updateModel();\n                }\n            },\n\n            _removeConnection: function(connection, undoable) {\n                if (connection.sourceConnector) {\n                    Utils.remove(connection.sourceConnector.connections, connection);\n                }\n                if (connection.targetConnector) {\n                    Utils.remove(connection.targetConnector.connections, connection);\n                }\n                if (undoable) {\n                    this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n                }\n\n                Utils.remove(this.connections, connection);\n            },\n\n            _removeDataItems: function(items, recursive) {\n                var item, children, shape, idx;\n                items = isArray(items) ? items : [items];\n\n                while (items.length) {\n                    item = items.shift();\n                    shape = this._dataMap[item.uid];\n                    if (shape) {\n                        this._removeShapeConnections(shape);\n                        this._removeItem(shape, false);\n                        delete this._dataMap[item.uid];\n                        if (recursive && item.hasChildren && item.loaded()) {\n                            children = item.children.data();\n                            for (idx = 0; idx < children.length; idx++) {\n                                items.push(children[idx]);\n                            }\n                        }\n                    }\n                }\n            },\n\n            _removeShapeConnections: function(shape) {\n                var connections = shape.connections();\n                var idx;\n\n                if (connections) {\n                    for (idx = 0; idx < connections.length; idx++) {\n                        this._removeItem(connections[idx], false);\n                    }\n                }\n            },\n\n            _addDataItem: function(dataItem, undoable) {\n                if (!defined(dataItem)) {\n                    return;\n                }\n\n                var shape = this._dataMap[dataItem.id];\n                if (shape) {\n                    return shape;\n                }\n\n                var options = deepExtend({}, this.options.shapeDefaults);\n                options.dataItem = dataItem;\n                shape = new Shape(options, this);\n                this.addShape(shape, undoable !== false);\n                this._dataMap[dataItem.id] = shape;\n                return shape;\n            },\n\n            _addDataItemByUid: function(dataItem) {\n                if (!defined(dataItem)) {\n                    return;\n                }\n\n                var shape = this._dataMap[dataItem.uid];\n                if (shape) {\n                    return shape;\n                }\n\n                var options = deepExtend({}, this.options.shapeDefaults);\n                options.dataItem = dataItem;\n                shape = new Shape(options, this);\n                this.addShape(shape);\n                this._dataMap[dataItem.uid] = shape;\n                return shape;\n            },\n\n            _addDataItems: function(items, parent) {\n                var item, idx, shape, parentShape, connection;\n                for (idx = 0; idx < items.length; idx++) {\n                    item = items[idx];\n                    shape = this._addDataItemByUid(item);\n                    parentShape = this._addDataItemByUid(parent);\n                    if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                        connection = this.connect(parentShape, shape);\n                    }\n                }\n            },\n\n            _refreshSource: function(e) {\n                var that = this,\n                    node = e.node,\n                    action = e.action,\n                    items = e.items,\n                    options = that.options,\n                    idx,\n                    dataBound;\n\n                if (e.field) {\n                    for (idx = 0; idx < items.length; idx++) {\n                        if (this._dataMap[items[idx].uid]) {\n                            this._dataMap[items[idx].uid].redrawVisual();\n                        }\n                    }\n                    return;\n                }\n\n                if (action == \"remove\") {\n                    this._removeDataItems(e.items, true);\n                } else {\n\n                    if ((!action || action === \"itemloaded\") && !this._bindingRoots) {\n                        this._bindingRoots = true;\n                        dataBound = true;\n                    }\n\n                    if (!action && !node) {\n                        that.clear();\n                    }\n\n                    this._addDataItems(items, node);\n\n                    for (idx = 0; idx < items.length; idx++) {\n                        items[idx].load();\n                    }\n                }\n\n                if (options.layout && (dataBound || action == \"remove\" || action == \"add\")) {\n                    that.layout(options.layout);\n                }\n\n                if (dataBound) {\n                    this.trigger(\"dataBound\");\n                    this._bindingRoots = false;\n                }\n            },\n\n            _addItem: function(item) {\n                if (item instanceof Shape) {\n                    this.addShape(item);\n                } else if (item instanceof Connection) {\n                    this.addConnection(item);\n                }\n            },\n\n            _createToolBar: function(preventClosing) {\n                var diagram = this.toolService.diagram;\n\n                if (!this.singleToolBar && diagram.select().length === 1) {\n                    var element = diagram.select()[0];\n                    if (element && element.options.editable !== false) {\n                        var editable = element.options.editable;\n                        var tools = editable.tools;\n                        if (this._isEditable && tools.length === 0) {\n                            if (element instanceof Shape) {\n                                tools = [\"edit\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                            } else if (element instanceof Connection) {\n                                tools = [\"edit\"];\n                            }\n\n                            if (editable && editable.remove !== false) {\n                                tools.push(\"delete\");\n                            }\n                        }\n\n                        if (tools && tools.length) {\n                            var padding = 20;\n                            var point;\n                            this.singleToolBar = new DiagramToolBar(diagram, {\n                                tools: tools,\n                                click: this._toolBarClick.bind(this),\n                                modal: true,\n                                popupZIndex: parseInt(diagram.element.closest(\".k-window\").css(\"zIndex\"), 10) + 10\n                            });\n                            var popupWidth = outerWidth(this.singleToolBar._popup.element);\n                            var popupHeight = outerHeight(this.singleToolBar._popup.element);\n                            if (element instanceof Shape) {\n                                var shapeBounds = this.modelToView(element.bounds(ROTATED));\n                                point = new Point(shapeBounds.x, shapeBounds.y).minus(new Point(\n                                    (popupWidth - shapeBounds.width) / 2,\n                                    popupHeight + padding));\n                            } else if (element instanceof Connection) {\n                                var connectionBounds = this.modelToView(element.bounds());\n\n                                point = new Point(connectionBounds.x, connectionBounds.y)\n                                    .minus(new Point(\n                                        (popupWidth - connectionBounds.width - 20) / 2,\n                                        popupHeight + padding\n                                    ));\n                            }\n\n                            if (point) {\n                                if (!this.canvas.translate) {\n                                    point = point.minus(new Point(this.scroller.scrollLeft, this.scroller.scrollTop));\n                                }\n                                point = this.viewToDocument(point);\n                                point = new Point(math.max(point.x, 0), math.max(point.y, 0));\n                                this.singleToolBar.showAt(point);\n                                if (preventClosing) {\n                                    this.singleToolBar._popup.one(\"close\", preventDefault);\n                                }\n                            } else {\n                                this._destroyToolBar();\n                            }\n                        }\n                    }\n                }\n            },\n\n            _toolBarClick: function(e) {\n                this.trigger(\"toolBarClick\", e);\n                this._destroyToolBar();\n            },\n\n            _normalizePointZoom: function(point) {\n                return point.times(1 / this.zoom());\n            },\n\n            _initialize: function() {\n                this.shapes = [];\n                this._selectedItems = [];\n                this.connections = [];\n                this._dataMap = {};\n                this._connectionsDataMap = {};\n                this._inactiveShapeItems = new InactiveItemsCollection();\n                this._deferredConnectionUpdates = [];\n                this.undoRedoService = new UndoRedoService({\n                    undone: this._syncHandler,\n                    redone: this._syncHandler\n                });\n                this.id = diagram.randomId();\n            },\n\n            _fetchFreshData: function() {\n                var that = this;\n                that._dataSource();\n\n                if (that._isEditable) {\n                    that._connectionDataSource();\n                }\n\n                if (that.options.autoBind) {\n                    if (that._isEditable) {\n                        this._loadingShapes = true;\n                        this._loadingConnections = true;\n                        that.dataSource.fetch();\n                        that.connectionsDataSource.fetch();\n                    } else {\n                        that.dataSource.fetch();\n                    }\n                }\n            },\n\n            _dataSource: function() {\n                if (defined(this.options.connectionsDataSource)) {\n                    this._isEditable = true;\n                    var dsOptions = this.options.dataSource || {};\n                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                    if (this.dataSource && this._shapesRefreshHandler) {\n                        this.dataSource\n                            .unbind(\"change\", this._shapesRefreshHandler)\n                            .unbind(\"requestStart\", this._shapesRequestStartHandler)\n                            .unbind(\"error\", this._shapesErrorHandler);\n                    } else {\n                        this._shapesRefreshHandler = this._refreshShapes.bind(this);\n                        this._shapesRequestStartHandler = this._shapesRequestStart.bind(this);\n                        this._shapesErrorHandler = this._error.bind(this);\n                    }\n\n                    this.dataSource = kendo.data.DataSource.create(ds)\n                        .bind(\"change\", this._shapesRefreshHandler)\n                        .bind(\"requestStart\", this._shapesRequestStartHandler)\n                        .bind(\"error\", this._shapesErrorHandler);\n                } else {\n                    this._treeDataSource();\n                    this._isEditable = false;\n                }\n            },\n\n            _connectionDataSource: function() {\n                var dsOptions = this.options.connectionsDataSource;\n                if (dsOptions) {\n                    var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                    if (this.connectionsDataSource && this._connectionsRefreshHandler) {\n                        this.connectionsDataSource\n                            .unbind(\"change\", this._connectionsRefreshHandler)\n                            .unbind(\"requestStart\", this._connectionsRequestStartHandler)\n                            .unbind(\"error\", this._connectionsErrorHandler);\n                    } else {\n                        this._connectionsRefreshHandler = this._refreshConnections.bind(this);\n                        this._connectionsRequestStartHandler = this._connectionsRequestStart.bind(this);\n                        this._connectionsErrorHandler = this._connectionsError.bind(this);\n                    }\n\n                    this.connectionsDataSource = kendo.data.DataSource.create(ds)\n                        .bind(\"change\", this._connectionsRefreshHandler)\n                        .bind(\"requestStart\", this._connectionsRequestStartHandler)\n                        .bind(\"error\", this._connectionsErrorHandler);\n                }\n            },\n\n            _shapesRequestStart: function(e) {\n                if (e.type == \"read\") {\n                    this._loadingShapes = true;\n                }\n            },\n\n            _connectionsRequestStart: function(e) {\n                if (e.type == \"read\") {\n                    this._loadingConnections = true;\n                }\n            },\n\n            _error: function() {\n                this._loadingShapes = false;\n            },\n\n            _connectionsError: function() {\n                this._loadingConnections = false;\n            },\n\n            _refreshShapes: function(e) {\n                if (e.action === \"remove\") {\n                    if (this._shouldRefresh()) {\n                        this._removeShapes(e.items);\n                    }\n                } else if (e.action === \"itemchange\") {\n                    if (this._shouldRefresh()) {\n                        this._updateShapes(e.items, e.field);\n                    }\n                } else if (e.action === \"add\") {\n                    this._inactiveShapeItems.add(e.items);\n                } else if (e.action === \"sync\") {\n                    this._syncShapes(e.items);\n                } else {\n                    this.refresh();\n                }\n            },\n\n            _shouldRefresh: function() {\n                return !this._suspended;\n            },\n\n            _suspendModelRefresh: function() {\n                this._suspended = (this._suspended || 0) + 1;\n            },\n\n            _resumeModelRefresh: function() {\n                this._suspended = math.max((this._suspended || 0) - 1, 0);\n            },\n\n            refresh: function() {\n                this._loadingShapes = false;\n                if (!this._loadingConnections) {\n                    this._rebindShapesAndConnections();\n                }\n            },\n\n            _rebindShapesAndConnections: function() {\n                this.clear();\n                this._addShapes(this.dataSource.view());\n                if (this.connectionsDataSource) {\n                    this._addConnections(this.connectionsDataSource.view(), false);\n                }\n\n                if (this.options.layout) {\n                    this.layout(this.options.layout);\n                } else {\n                    this._redrawConnections();\n                }\n                this.trigger(\"dataBound\");\n            },\n\n            refreshConnections: function() {\n                this._loadingConnections = false;\n                if (!this._loadingShapes) {\n                    this._rebindShapesAndConnections();\n                }\n            },\n\n            _redrawConnections: function() {\n                var connections = this.connections;\n                for (var idx = 0; idx < connections.length; idx++) {\n                    connections[idx].refresh();\n                }\n            },\n\n            _removeShapes: function(items) {\n                var dataMap = this._dataMap;\n                var item, i;\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if (dataMap[item.id]) {\n                        this.remove(dataMap[item.id], false);\n                        dataMap[item.id] = null;\n                    }\n                }\n            },\n\n            _syncShapes: function() {\n                var diagram = this;\n                var inactiveItems = diagram._inactiveShapeItems;\n                inactiveItems.forEach(function(inactiveItem) {\n                    var dataItem = inactiveItem.dataItem;\n                    var shape = inactiveItem.element;\n                    if (!dataItem.isNew()) {\n                        if (shape) {\n                            shape._setOptionsFromModel();\n                            diagram.addShape(shape, inactiveItem.undoable);\n                            diagram._dataMap[dataItem.id] = shape;\n                        } else {\n                            diagram._addDataItem(dataItem);\n                        }\n                        inactiveItem.activate();\n                        inactiveItems.remove(dataItem);\n                    }\n                });\n            },\n\n            _updateShapes: function(items, field) {\n                for (var i = 0; i < items.length; i++) {\n                    var dataItem = items[i];\n\n                    var shape = this._dataMap[dataItem.id];\n                    if (shape) {\n                        shape.updateOptionsFromModel(dataItem, field);\n                    }\n                }\n            },\n\n            _addShapes: function(dataItems) {\n                for (var i = 0; i < dataItems.length; i++) {\n                    this._addDataItem(dataItems[i], false);\n                }\n            },\n\n            _refreshConnections: function(e) {\n                if (e.action === \"remove\") {\n                    if (this._shouldRefresh()) {\n                        this._removeConnections(e.items);\n                    }\n                } else if (e.action === \"add\") {\n                    this._addConnections(e.items);\n                } else if (e.action === \"sync\") {\n                    //TO DO: include logic to update the connections with different values returned from the server.\n                } else if (e.action === \"itemchange\") {\n                    if (this._shouldRefresh()) {\n                        this._updateConnections(e.items);\n                    }\n                } else {\n                    this.refreshConnections();\n                }\n            },\n\n            _removeConnections: function(items) {\n                for (var i = 0; i < items.length; i++) {\n                    this.remove(this._connectionsDataMap[items[i].uid], false);\n                    this._connectionsDataMap[items[i].uid] = null;\n                }\n            },\n\n            _updateConnections: function(items) {\n                for (var i = 0; i < items.length; i++) {\n                    var dataItem = items[i];\n\n                    var connection = this._connectionsDataMap[dataItem.uid];\n                    connection.updateOptionsFromModel(dataItem);\n                }\n            },\n\n            _addConnections: function(connections, undoable) {\n                var length = connections.length;\n\n                for (var i = 0; i < length; i++) {\n                    var dataItem = connections[i];\n                    this._addConnectionDataItem(dataItem, undoable);\n                }\n            },\n\n            _addConnectionDataItem: function(dataItem, undoable) {\n                if (!this._connectionsDataMap[dataItem.uid]) {\n                    var from = this._validateConnector(dataItem.from);\n                    if (!defined(from) || from === null) {\n                        from = new Point(dataItem.fromX, dataItem.fromY);\n                    }\n\n                    var to = this._validateConnector(dataItem.to);\n                    if (!defined(to) || to === null) {\n                        to = new Point(dataItem.toX, dataItem.toY);\n                    }\n\n                    if (defined(from) && defined(to)) {\n                        var options = deepExtend({}, this.options.connectionDefaults);\n                        options.dataItem = dataItem;\n                        var connection = new Connection(from, to, options);\n\n                        this._connectionsDataMap[dataItem.uid] = connection;\n                        this.addConnection(connection, undoable);\n                    }\n                }\n            },\n\n            _validateConnector: function(value) {\n                var connector;\n\n                if (defined(value) && value !== null) {\n                    connector = this._dataMap[value];\n                }\n\n                return connector;\n            },\n\n            _treeDataSource: function() {\n                var that = this,\n                    options = that.options,\n                    dataSource = options.dataSource;\n\n                dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n                if (dataSource instanceof kendo.data.DataSource && !(dataSource instanceof kendo.data.HierarchicalDataSource)) {\n                    throw new Error(\"Incorrect DataSource type. If a single dataSource instance is set to the diagram then it should be a HierarchicalDataSource. You should set only the options instead of an instance or a HierarchicalDataSource instance or supply connectionsDataSource as well.\");\n                }\n\n                if (!dataSource.fields) {\n                    dataSource.fields = [\n                        { field: \"text\" },\n                        { field: \"url\" },\n                        { field: \"spriteCssClass\" },\n                        { field: \"imageUrl\" }\n                    ];\n                }\n                if (that.dataSource && that._refreshHandler) {\n                    that._unbindDataSource();\n                }\n\n                that._refreshHandler = that._refreshSource.bind(that);\n                that._errorHandler = that._error.bind(that);\n\n                that.dataSource = HierarchicalDataSource.create(dataSource)\n                    .bind(CHANGE, that._refreshHandler)\n                    .bind(ERROR, that._errorHandler);\n            },\n\n            _unbindDataSource: function() {\n                var that = this;\n\n                that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(ERROR, that._errorHandler);\n            },\n\n            _adorn: function(adorner, isActive) {\n                if (isActive !== undefined$1 && adorner) {\n                    if (isActive) {\n                        this._adorners.push(adorner);\n                        this.adornerLayer.append(adorner.visual);\n                    }\n                    else {\n                        Utils.remove(this._adorners, adorner);\n                        this.adornerLayer.remove(adorner.visual);\n                    }\n                }\n            },\n\n            _showConnectors: function(shape, value) {\n                if (value) {\n                    this._connectorsAdorner.show(shape);\n                } else {\n                    this._connectorsAdorner.destroy();\n                }\n            },\n\n            _updateAdorners: function() {\n                var adorners = this._adorners;\n\n                for (var i = 0; i < adorners.length; i++) {\n                    var adorner = adorners[i];\n\n                    if (adorner.refreshBounds) {\n                        adorner.refreshBounds();\n                    }\n                    adorner.refresh();\n                }\n            },\n\n            _refresh: function() {\n                for (var i = 0; i < this.connections.length; i++) {\n                    this.connections[i].refresh();\n                }\n            },\n\n            _destroyToolBar: function() {\n                if (this.singleToolBar) {\n                    this.singleToolBar.hide();\n                    this.singleToolBar.destroy();\n                    this.singleToolBar = null;\n                }\n            },\n\n            _destroyGlobalToolBar: function() {\n                if (this.toolBar) {\n                    this.toolBar.hide();\n                    this.toolBar.destroy();\n                    this.toolBar = null;\n                }\n            },\n\n            exportDOMVisual: function() {\n                var viewBox = this.canvas._viewBox;\n                var scrollOffset = geom.transform()\n                                       .translate(-viewBox.x, -viewBox.y);\n\n                var viewRect = new geom.Rect([0, 0], [viewBox.width, viewBox.height]);\n                var clipPath = draw.Path.fromRect(viewRect);\n                var wrap = new draw.Group({ transform: scrollOffset });\n                var clipWrap = new draw.Group({ clip: clipPath });\n                var root = this.canvas.drawingElement.children[0];\n\n                clipWrap.append(wrap);\n\n                // Don't reparent the root\n                wrap.children.push(root);\n\n                return clipWrap;\n            },\n\n            exportVisual: function() {\n                var scale = geom.transform().scale(1 / this._zoom);\n                var wrap = new draw.Group({\n                    transform: scale\n                });\n\n                var root = this.mainLayer.drawingElement;\n                wrap.children.push(root);\n\n                return wrap;\n            },\n\n            _syncChanges: function() {\n                this._syncShapeChanges();\n                this._syncConnectionChanges();\n            },\n\n            _syncShapeChanges: function() {\n                if (this.dataSource && this._isEditable) {\n                    this.dataSource.sync();\n                }\n            },\n\n            _syncConnectionChanges: function() {\n                var that = this;\n                if (that.connectionsDataSource && that._isEditable) {\n                    $.when.apply($, that._deferredConnectionUpdates).then(function() {\n                        that.connectionsDataSource.sync();\n                    });\n                    that.deferredConnectionUpdates = [];\n                }\n            }\n        });\n\n        dataviz.ExportMixin.extend(Diagram.fn, true);\n\n        if (kendo.PDFMixin) {\n            kendo.PDFMixin.extend(Diagram.fn);\n        }\n\n        function filterShapeDataItem(dataItem) {\n            var result = {};\n\n            dataItem = dataItem || {};\n\n            if (defined(dataItem.text) && dataItem.text !== null) {\n                result.text = dataItem.text;\n            }\n\n            if (defined(dataItem.x) && dataItem.x !== null) {\n                result.x = dataItem.x;\n            }\n\n            if (defined(dataItem.y) && dataItem.y !== null) {\n                result.y = dataItem.y;\n            }\n\n            if (defined(dataItem.width) && dataItem.width !== null) {\n                result.width = dataItem.width;\n            }\n\n            if (defined(dataItem.height) && dataItem.height !== null) {\n                result.height = dataItem.height;\n            }\n\n            if (defined(dataItem.type) && dataItem.type !== null) {\n                result.type = dataItem.type;\n            }\n\n            return result;\n        }\n\n        function filterConnectionDataItem(dataItem) {\n            var result = {};\n\n            dataItem = dataItem || {};\n\n            if (defined(dataItem.text) && dataItem.text !== null) {\n                result.content = dataItem.text;\n            }\n\n            if (defined(dataItem.type) && dataItem.type !== null) {\n                result.type = dataItem.type;\n            }\n\n            if (defined(dataItem.from) && dataItem.from !== null) {\n                result.from = dataItem.from;\n            }\n\n            if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n                result.fromConnector = dataItem.fromConnector;\n            }\n\n            if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n                result.fromX = dataItem.fromX;\n            }\n\n            if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n                result.fromY = dataItem.fromY;\n            }\n\n            if (defined(dataItem.to) && dataItem.to !== null) {\n                result.to = dataItem.to;\n            }\n\n            if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n                result.toConnector = dataItem.toConnector;\n            }\n\n            if (defined(dataItem.toX) && dataItem.toX !== null) {\n                result.toX = dataItem.toX;\n            }\n\n            if (defined(dataItem.toY) && dataItem.toY !== null) {\n                result.toY = dataItem.toY;\n            }\n\n            return result;\n        }\n\n\n        var DiagramToolBar = kendo.Observable.extend({\n            init: function(diagram, options) {\n                kendo.Observable.fn.init.call(this);\n                this.diagram = diagram;\n                this.options = deepExtend({}, this.options, options);\n                this._tools = [];\n                this.createToolBar();\n                this.createTools();\n                this.appendTools();\n\n                if (this.options.modal) {\n                    this.createPopup();\n                }\n\n                this.bind(this.events, options);\n            },\n\n            events: [\"click\"],\n\n            createPopup: function() {\n                this.container = $(\"<div/>\").append(this.element);\n                this._popup = this.container.kendoPopup({}).getKendoPopup();\n            },\n\n            appendTools: function() {\n                for (var i = 0; i < this._tools.length; i++) {\n                    var tool = this._tools[i];\n                    if (tool.buttons && tool.buttons.length || !defined(tool.buttons)) {\n                        this._toolBar.add(tool);\n                    }\n                }\n            },\n\n            createToolBar: function() {\n                this.element = $(\"<div/>\");\n                this._toolBar = this.element\n                    .kendoToolBar({\n                        click: this.click.bind(this),\n                        resizable: false\n                    }).getKendoToolBar();\n\n                this.element.css(\"border\", \"none\");\n            },\n\n            createTools: function() {\n                for (var i = 0; i < this.options.tools.length; i++) {\n                    this.createTool(this.options.tools[i]);\n                }\n            },\n\n            createTool: function(tool) {\n                if (!isPlainObject(tool)) {\n                    tool = {\n                        name: tool\n                    };\n                }\n                var toolName = tool.name + \"Tool\";\n                if (this[toolName]) {\n                    this[toolName](tool);\n                } else {\n                    this._tools.push(deepExtend({}, tool, {\n                        attributes: this._setAttributes({ action: tool.name })\n                    }));\n                }\n            },\n\n            showAt: function(point) {\n                var popupZIndex = parseInt(this.options.popupZIndex, 10);\n\n                if (this._popup) {\n                    this._popup.open(point.x, point.y);\n\n                    if (popupZIndex) {\n                        this._popup.wrapper.css(\"zIndex\", popupZIndex);\n                    }\n                }\n            },\n\n            hide: function() {\n                if (this._popup) {\n                    this._popup.close();\n                }\n            },\n\n            newGroup: function() {\n                return {\n                    type: \"buttonGroup\",\n                    buttons: []\n                };\n            },\n\n            editTool: function() {\n                this._tools.push({\n                    icon: \"pencil\",\n                    showText: \"overflow\",\n                    type: \"button\",\n                    text: \"Edit\",\n                    attributes: this._setAttributes({ action: \"edit\" })\n                });\n            },\n\n            deleteTool: function() {\n                this._tools.push({\n                    icon: \"x\",\n                    showText: \"overflow\",\n                    type: \"button\",\n                    text: \"Delete\",\n                    attributes: this._setAttributes({ action: \"delete\" })\n                });\n            },\n\n            rotateAnticlockwiseTool: function(options) {\n                this._appendGroup(\"rotate\");\n                this._rotateGroup.buttons.push({\n                    icon: \"rotate-left\",\n                    showText: \"overflow\",\n                    text: \"RotateAnticlockwise\",\n                    group: \"rotate\",\n                    attributes: this._setAttributes({ action: \"rotateAnticlockwise\", step: options.step })\n                });\n            },\n\n            rotateClockwiseTool: function(options) {\n                this._appendGroup(\"rotate\");\n                this._rotateGroup.buttons.push({\n                    icon: \"rotate-right\",\n                    attributes: this._setAttributes({ action: \"rotateClockwise\", step: options.step }),\n                    showText: \"overflow\",\n                    text: \"RotateClockwise\",\n                    group: \"rotate\"\n                });\n            },\n\n            createShapeTool: function() {\n                this._appendGroup(\"create\");\n                this._createGroup.buttons.push({\n                    icon: \"shapes\",\n                    showText: \"overflow\",\n                    text: \"CreateShape\",\n                    group: \"create\",\n                    attributes: this._setAttributes({ action: \"createShape\" })\n                });\n            },\n\n            createConnectionTool: function() {\n                this._appendGroup(\"create\");\n                this._createGroup.buttons.push({\n                    icon: \"connector\",\n                    showText: \"overflow\",\n                    text: \"CreateConnection\",\n                    group: \"create\",\n                    attributes: this._setAttributes({ action: \"createConnection\" })\n                });\n            },\n\n            undoTool: function() {\n                this._appendGroup(\"history\");\n                this._historyGroup.buttons.push({\n                    icon: \"undo\",\n                    showText: \"overflow\",\n                    text: \"Undo\",\n                    group: \"history\",\n                    attributes: this._setAttributes({ action: \"undo\" })\n                });\n            },\n\n            redoTool: function() {\n                this._appendGroup(\"history\");\n                this._historyGroup.buttons.push({\n                    icon: \"redo\",\n                    showText: \"overflow\",\n                    text: \"Redo\",\n                    group: \"history\",\n                    attributes: this._setAttributes({ action: \"redo\" })\n                });\n            },\n\n            _appendGroup: function(name) {\n                var prop = \"_\" + name + \"Group\";\n                if (!this[prop]) {\n                    this[prop] = this.newGroup();\n                    this._tools.push(this[prop]);\n                }\n            },\n\n            _setAttributes: function(attributes) {\n                var attr = {};\n\n                if (attributes.action) {\n                    attr[kendo.attr(\"action\")] = attributes.action;\n                }\n\n                if (attributes.step) {\n                    attr[kendo.attr(\"step\")] = attributes.step;\n                }\n\n                return attr;\n            },\n\n            _getAttributes: function(element) {\n                var attr = {};\n\n                var action = element.attr(kendo.attr(\"action\"));\n                if (action) {\n                    attr.action = action;\n                }\n\n                var step = element.attr(kendo.attr(\"step\"));\n                if (step) {\n                    attr.step = step;\n                }\n\n                return attr;\n            },\n\n            click: function(e) {\n                var attributes = this._getAttributes($(e.target));\n                var action = attributes.action;\n\n                if (action && this[action]) {\n                    this[action](attributes);\n                }\n\n                this.trigger(\"click\", this.eventData(action, e.target));\n            },\n\n            eventData: function(action, target) {\n                var elements = this.selectedElements(),\n                    length = elements.length,\n                    shapes = [], connections = [], element;\n\n                for (var idx = 0; idx < length; idx++) {\n                    element = elements[idx];\n                    if (element instanceof Shape) {\n                        shapes.push(element);\n                    } else {\n                        connections.push(element);\n                    }\n                }\n\n                return {\n                    shapes: shapes,\n                    connections: connections,\n                    action: action,\n                    target: target\n                };\n            },\n\n            \"delete\": function() {\n                var diagram = this.diagram;\n                var toRemove = diagram._triggerRemove(this.selectedElements());\n                if (toRemove.length) {\n                    this.diagram.remove(toRemove, true);\n                    this.diagram._syncChanges();\n                }\n            },\n\n            edit: function() {\n                var selectedElemens = this.selectedElements();\n                if (selectedElemens.length === 1) {\n                    this.diagram.edit(selectedElemens[0]);\n                }\n            },\n\n            rotateClockwise: function(options) {\n                var angle = parseFloat(options.step || 90);\n                this._rotate(angle);\n            },\n\n            rotateAnticlockwise: function(options) {\n                var angle = parseFloat(options.step || 90);\n                this._rotate(-angle);\n            },\n\n            _rotate: function(angle) {\n                var adorner = this.diagram._resizingAdorner;\n                adorner.angle(adorner.angle() + angle);\n                adorner.rotate();\n            },\n\n            selectedElements: function() {\n                return this.diagram.select();\n            },\n\n            createShape: function() {\n                this.diagram.createShape();\n            },\n\n            createConnection: function() {\n                this.diagram.createConnection();\n            },\n\n            undo: function() {\n                this.diagram.undo();\n            },\n\n            redo: function() {\n                this.diagram.redo();\n            },\n\n            destroy: function() {\n                this.diagram = null;\n                this.element = null;\n                this.options = null;\n\n                if (this._toolBar) {\n                    this._toolBar.destroy();\n                }\n\n                if (this._popup) {\n                    this._popup.destroy();\n                }\n            }\n        });\n\n        var Editor = kendo.Observable.extend({\n            init: function(element, options) {\n                kendo.Observable.fn.init.call(this);\n\n                this.options = extend(true, {}, this.options, options);\n                this.element = element;\n                this.model = this.options.model;\n                this.fields = this._getFields();\n                this._initContainer();\n                this.createEditable();\n            },\n\n            options: {\n                editors: {}\n            },\n\n            _initContainer: function() {\n                this.wrapper = this.element;\n            },\n\n            createEditable: function() {\n                var options = this.options;\n\n                this.editable = new kendo.ui.Editable(this.wrapper, {\n                    fields: this.fields,\n                    target: options.target,\n                    clearContainer: false,\n                    model: this.model\n                });\n            },\n\n            _isEditable: function(field) {\n                return this.model.editable && this.model.editable(field);\n            },\n\n            _getFields: function() {\n                var fields = [];\n                var modelFields = this.model.fields;\n\n                for (var field in modelFields) {\n                    var result = {};\n                    if (this._isEditable(field)) {\n                        var editor = this.options.editors[field];\n                        if (editor) {\n                            result.editor = editor;\n                        }\n                        result.field = field;\n                        fields.push(result);\n                    }\n                }\n\n                return fields;\n            },\n\n            end: function() {\n                return this.editable.end();\n            },\n\n            destroy: function() {\n                this.editable.destroy();\n                this.editable.element.find(\"[\" + kendo.attr(\"container-for\") + \"]\").empty();\n                this.model = this.wrapper = this.element = this.columns = this.editable = null;\n            }\n        });\n\n        var PopupEditor = Editor.extend({\n            init: function(element, options) {\n                Editor.fn.init.call(this, element, options);\n                this.bind(this.events, this.options);\n\n                this.open();\n            },\n\n            events: [ \"update\", \"cancel\" ],\n\n            options: {\n                window: {\n                    modal: true,\n                    resizable: false,\n                    draggable: true,\n                    title: \"Edit\",\n                    visible: false\n                }\n            },\n\n            _initContainer: function() {\n                var that = this;\n                this.wrapper = $('<div class=\"k-popup-edit-form\"/>')\n                    .attr(kendo.attr(\"uid\"), this.model.uid);\n\n                var formContent = \"\";\n\n                if (this.options.template) {\n                    formContent += this._renderTemplate();\n                    this.fields = [];\n                } else {\n                    formContent += this._renderFields();\n                }\n\n                formContent += this._renderButtons();\n\n                this.wrapper.append(\n                    $('<div class=\"k-edit-form-container\"/>').append(formContent));\n\n                this.window = new kendo.ui.Window(this.wrapper.appendTo(this.element), this.options.window);\n                this.window.bind(\"close\", function(e) {\n                    //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n                    if (e.userTriggered) {\n                        e.sender.element.trigger(\"focus\");\n                        that._cancelClick(e);\n                    }\n                });\n\n                this._attachButtonEvents();\n            },\n\n            _renderTemplate: function() {\n                var template = this.options.template;\n\n                if (typeof template === \"string\") {\n                    template = kendo.unescape(template);\n                }\n\n                template = kendo.template(template)(this.model);\n\n                return template;\n            },\n\n            _renderFields: function() {\n                var form = \"\";\n                for (var i = 0; i < this.fields.length; i++) {\n                    var field = this.fields[i];\n\n                    form += '<div class=\"k-edit-label\"><label for=\"' + field.field + '\">' + (field.field || \"\") + '</label></div>';\n\n                    if (this._isEditable(field.field)) {\n                        form += '<div ' + kendo.attr(\"container-for\") + '=\"' + field.field +\n                        '\" class=\"k-edit-field\"></div>';\n                    }\n                }\n\n                return form;\n            },\n\n            _renderButtons: function() {\n                var form = '<div class=\"k-edit-buttons\">';\n                form += this._createButton(\"update\");\n                form += this._createButton(\"cancel\");\n                form += '</div>';\n                return form;\n            },\n\n            _createButton: function(name) {\n                return kendo.template(BUTTON_TEMPLATE)(defaultButtons[name]);\n            },\n\n            _attachButtonEvents: function() {\n                this._cancelClickHandler = this._cancelClick.bind(this);\n                this.window.element.on(CLICK + NS, \"button.k-diagram-cancel\", this._cancelClickHandler);\n\n                this._updateClickHandler = this._updateClick.bind(this);\n                this.window.element.on(CLICK + NS, \"button.k-diagram-update\", this._updateClickHandler);\n            },\n\n            _updateClick: function(e) {\n                e.preventDefault();\n                this.trigger(\"update\");\n            },\n\n            _cancelClick: function(e) {\n                e.preventDefault();\n                this.trigger(\"cancel\");\n            },\n\n            open: function() {\n                this.window.center().open();\n            },\n\n            close: function() {\n                this.window.bind(\"deactivate\", this.destroy.bind(this)).close();\n            },\n\n            destroy: function() {\n                this.window.close().destroy();\n                this.window.element.off(CLICK + NS, \"a.k-diagram-cancel\", this._cancelClickHandler);\n                this.window.element.off(CLICK + NS, \"a.k-diagram-update\", this._updateClickHandler);\n                this._cancelClickHandler = null;\n                this._editUpdateClickHandler = null;\n                this.window = null;\n                Editor.fn.destroy.call(this);\n            }\n        });\n\n        function connectionSelector(container, options) {\n            var model = this.dataSource.reader.model;\n            if (model) {\n                var textField = model.fn.fields.text ? \"text\" : model.idField;\n                $(\"<input name='\" + options.field + \"' />\")\n                    .appendTo(container).kendoDropDownList({\n                        dataValueField: model.idField,\n                        dataTextField: textField,\n                        dataSource: this.dataSource.data().toJSON(),\n                        optionLabel: \" \",\n                        valuePrimitive: true\n                    });\n            }\n        }\n\n        function InactiveItem(dataItem) {\n            this.dataItem = dataItem;\n            this.callbacks = [];\n        }\n\n        InactiveItem.fn = InactiveItem.prototype = {\n            onActivate: function(callback) {\n                var deffered = $.Deferred();\n                this.callbacks.push({\n                    callback: callback,\n                    deferred: deffered\n                });\n                return deffered;\n            },\n\n            activate: function() {\n                var callbacks = this.callbacks;\n                var item;\n                for (var idx = 0; idx < callbacks.length; idx++) {\n                    item = this.callbacks[idx];\n                    item.callback(this.dataItem);\n                    item.deferred.resolve();\n                }\n                this.callbacks = [];\n            }\n        };\n\n        function InactiveItemsCollection() {\n            this.items = {};\n        }\n\n        InactiveItemsCollection.fn = InactiveItemsCollection.prototype = {\n            add: function(items) {\n                for (var idx = 0; idx < items.length; idx++) {\n                    this.items[items[idx].uid] = new InactiveItem(items[idx]);\n                }\n            },\n\n            forEach: function(callback) {\n                for (var uid in this.items) {\n                    callback(this.items[uid]);\n                }\n            },\n\n            getByUid: function(uid) {\n                return this.items[uid];\n            },\n\n            remove: function(item) {\n                delete this.items[item.uid];\n            }\n        };\n\n        var QuadRoot = Class.extend({\n            init: function() {\n                this.shapes = [];\n            },\n\n            _add: function(shape, bounds) {\n                this.shapes.push({\n                    bounds: bounds,\n                    shape: shape\n                });\n                shape._quadNode = this;\n            },\n\n            insert: function(shape, bounds) {\n                this._add(shape, bounds);\n            },\n\n            remove: function(shape) {\n                var shapes = this.shapes;\n                var length = shapes.length;\n\n                for (var idx = 0; idx < length; idx++) {\n                    if (shapes[idx].shape === shape) {\n                        shapes.splice(idx, 1);\n                        break;\n                    }\n                }\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var shapes = this.shapes;\n                var length = shapes.length;\n\n                for (var i = 0; i < length; i++) {\n                    if (this._testRect(shapes[i].shape, rect) && !dataviz.inArray(shapes[i].shape, exclude)) {\n                        return true;\n                    }\n                }\n            },\n\n            _testRect: function(shape, rect) {\n                var angle = shape.rotate().angle;\n                var bounds = shape.bounds();\n                var hit;\n                if (!angle) {\n                    hit = bounds.overlaps(rect);\n                } else {\n                    hit = Intersect.rects(rect, bounds, -angle);\n                }\n                return hit;\n            }\n        });\n\n        var QuadNode = QuadRoot.extend({\n            init: function(rect) {\n                QuadRoot.fn.init.call(this);\n                this.children = [];\n                this.rect = rect;\n            },\n\n            inBounds: function(rect) {\n                var nodeRect = this.rect;\n                var nodeBottomRight = nodeRect.bottomRight();\n                var bottomRight = rect.bottomRight();\n                var inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                    bottomRight.y <= nodeBottomRight.y;\n                return inBounds;\n            },\n\n            overlapsBounds: function(rect) {\n                return this.rect.overlaps(rect);\n            },\n\n            insert: function(shape, bounds) {\n                var inserted = false;\n                var children = this.children;\n                var length = children.length;\n                if (this.inBounds(bounds)) {\n                    if (!length && this.shapes.length < 4) {\n                        this._add(shape, bounds);\n                    } else {\n                        if (!length) {\n                            this._initChildren();\n                        }\n\n                        for (var idx = 0; idx < children.length; idx++) {\n                            if (children[idx].insert(shape, bounds)) {\n                                inserted = true;\n                                break;\n                            }\n                        }\n\n                        if (!inserted) {\n                            this._add(shape, bounds);\n                        }\n                    }\n                    inserted = true;\n                }\n\n                return inserted;\n            },\n\n            _initChildren: function() {\n                var rect = this.rect,\n                    children = this.children,\n                    shapes = this.shapes,\n                    center = rect.center(),\n                    halfWidth = rect.width / 2,\n                    halfHeight = rect.height / 2,\n                    childIdx, shapeIdx;\n\n                children.push(\n                    new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)),\n                    new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight))\n                );\n                for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                    for (childIdx = 0; childIdx < children.length; childIdx++) {\n                        if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                            shapes.splice(shapeIdx, 1);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var idx;\n                var children = this.children;\n                var length = children.length;\n                var hit = false;\n\n                if (this.overlapsBounds(rect)) {\n                    if (QuadRoot.fn.hitTestRect.call(this, rect, exclude)) {\n                        hit = true;\n                    } else {\n                         for (idx = 0; idx < length; idx++) {\n                            if (children[idx].hitTestRect(rect, exclude)) {\n                               hit = true;\n                               break;\n                            }\n                        }\n                    }\n                }\n\n                return hit;\n            }\n        });\n\n        var ShapesQuadTree = Class.extend({\n            ROOT_SIZE: 1000,\n\n            init: function(diagram) {\n                var boundsChangeHandler = this._boundsChange.bind(this);\n                diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n                diagram.bind(ITEMROTATE, boundsChangeHandler);\n                this.initRoots();\n            },\n\n            initRoots: function() {\n                this.rootMap = {};\n                this.root = new QuadRoot();\n            },\n\n            clear: function() {\n                this.initRoots();\n            },\n\n            _boundsChange: function(e) {\n                if (e.item._quadNode) {\n                    e.item._quadNode.remove(e.item);\n                }\n                this.insert(e.item);\n            },\n\n            insert: function(shape) {\n                var bounds = shape.bounds(ROTATED);\n                var rootSize = this.ROOT_SIZE;\n                var sectors = this.getSectors(bounds);\n                var x = sectors[0][0];\n                var y = sectors[1][0];\n\n                if (this.inRoot(sectors)) {\n                    this.root.insert(shape, bounds);\n                } else {\n                    if (!this.rootMap[x]) {\n                        this.rootMap[x] = {};\n                    }\n\n                    if (!this.rootMap[x][y]) {\n                        this.rootMap[x][y] = new QuadNode(\n                            new Rect(x * rootSize, y * rootSize, rootSize, rootSize)\n                        );\n                    }\n\n                    this.rootMap[x][y].insert(shape, bounds);\n                }\n            },\n\n            remove: function(shape) {\n                if (shape._quadNode) {\n                    shape._quadNode.remove(shape);\n                }\n            },\n\n            inRoot: function(sectors) {\n                return sectors[0].length > 1 || sectors[1].length > 1;\n            },\n\n            getSectors: function(rect) {\n                var rootSize = this.ROOT_SIZE;\n                var bottomRight = rect.bottomRight();\n                var bottomX = math.floor(bottomRight.x / rootSize);\n                var bottomY = math.floor(bottomRight.y / rootSize);\n                var sectors = [[],[]];\n                for (var x = math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                    sectors[0].push(x);\n                }\n                for (var y = math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                    sectors[1].push(y);\n                }\n                return sectors;\n            },\n\n            hitTestRect: function(rect, exclude) {\n                var sectors = this.getSectors(rect);\n                var xIdx, yIdx, x, y;\n                var root;\n\n                if (this.root.hitTestRect(rect, exclude)) {\n                    return true;\n                }\n\n                for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                    x = sectors[0][xIdx];\n                    for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                        y = sectors[1][yIdx];\n                        root = (this.rootMap[x] || {})[y];\n                        if (root && root.hitTestRect(rect, exclude)) {\n                            return true;\n                        }\n                    }\n                }\n\n                return false;\n            }\n        });\n\n        function cloneDataItem(dataItem) {\n            var result = dataItem;\n            if (dataItem instanceof kendo.data.Model) {\n                result = dataItem.toJSON();\n                result[dataItem.idField] = dataItem._defaultId;\n            }\n            return result;\n        }\n\n        function splitDiagramElements(elements) {\n            var connections = [];\n            var shapes = [];\n            var element, idx;\n            for (idx = 0; idx < elements.length; idx++) {\n                element = elements[idx];\n                if (element instanceof Shape) {\n                    shapes.push(element);\n                } else {\n                    connections.push(element);\n                }\n            }\n            return {\n                shapes: shapes,\n                connections: connections\n            };\n        }\n\n        function createModel(dataSource, model) {\n            if (dataSource.reader.model) {\n                return new dataSource.reader.model(model);\n            }\n\n            return new kendo.data.ObservableObject(model);\n        }\n\n        function clearField(field, model) {\n            if (defined(model[field])) {\n                model.set(field, null);\n            }\n        }\n\n        function copyDefaultOptions(mainOptions, elementOptions, fields) {\n            var field;\n            for (var idx = 0; idx < fields.length; idx++) {\n                field = fields[idx];\n                if (elementOptions && !defined(elementOptions[field])) {\n                    elementOptions[field] = mainOptions[field];\n                }\n            }\n        }\n\n        function translateToOrigin(visual) {\n            var bbox = visual.drawingContainer().clippedBBox(null);\n            if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n                visual.position(-bbox.origin.x, -bbox.origin.y);\n            }\n        }\n\n        function preventDefault(e) {\n            e.preventDefault();\n        }\n\n        dataviz.ui.plugin(Diagram);\n\n        deepExtend(diagram, {\n            Shape: Shape,\n            Connection: Connection,\n            Connector: Connector,\n            DiagramToolBar: DiagramToolBar,\n            QuadNode: QuadNode,\n            QuadRoot: QuadRoot,\n            ShapesQuadTree: ShapesQuadTree,\n            PopupEditor: PopupEditor\n        });\n})(window.kendo.jQuery);\n\nconst __meta__ = {\n        id: \"dataviz.diagram\",\n        name: \"Diagram\",\n        category: \"dataviz\",\n        description: \"The Kendo DataViz Diagram \",\n        depends: [ \"data\", \"userevents\", \"mobile.scroller\", \"draganddrop\", \"drawing\", \"dataviz.core\", \"dataviz.themes\", \"toolbar\" ],\n        features: [{\n            id: \"dataviz.diagram-pdf-export\",\n            name: \"PDF export\",\n            description: \"Export Diagram as PDF\",\n            depends: [ \"pdf\" ]\n        },{\n            id: \"dataviz.diagram-editing\",\n            name: \"Editing\",\n            description: \"Support for model editing\",\n            depends: [ \"editable\", \"window\", \"dropdownlist\" ]\n        }]\n    };\n    var kendo$1 = kendo;\n\nexport { __meta__, kendo$1 as default };\n"]}